<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Japan Azure IaaS Core Support Blog</title>
  
  <subtitle>日本マイクロソフトの Azure IaaS テクニカル サポート チームより、情報をお届けします！</subtitle>
  <link href="https://jpaztech.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://jpaztech.github.io/blog/"/>
  <updated>2023-01-10T02:14:50.788Z</updated>
  <id>https://jpaztech.github.io/blog/</id>
  
  <author>
    <name>Japan Azure IaaS Core Support Team</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Project Flash : Azure 仮想マシンの可用性の監視を高める</title>
    <link href="https://jpaztech.github.io/blog/vm/vm-availability-monitoring-with-project-flash/"/>
    <id>https://jpaztech.github.io/blog/vm/vm-availability-monitoring-with-project-flash/</id>
    <published>2023-01-06T03:00:00.000Z</published>
    <updated>2023-01-10T02:14:50.788Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポート チームの鳥越です。</p><p>2022年に Azure 仮想マシンの可用性の監視を進化するプロジェクトである Project Flash について、以下のブログで紹介されました。</p><blockquote><p> <strong>Project Flash で Azure 仮想マシンの可用性の監視を進化させる</strong><br> <a href="https://azure.microsoft.com/ja-jp/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash/">https://azure.microsoft.com/ja-jp/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash/</a></p></blockquote><p>このプロジェクトは Azure 仮想マシンに対して、お客様の可用性監視ニーズを満たすために、次のようなことが行えるように進められております。</p><ul><li>VM の可用性障害 (VM のリブートや再起動のほか、ネットワーク ドライバーの更新によるアプリケーションのフリーズ、30 秒間のホスト OS の更新など) に関する正確で実用的なデータ、および障害の詳細 (プラットフォームのものかユーザー操作によるものか、リブートかフリーズか、計画的か非計画的かなど) を入手する。</li><li>VM の可用性の傾向を分析してアラートを生成し、迅速なデバッグと前月比のレポート作成を実現する。</li><li>データを定期的かつ大規模に監視し、カスタム ダッシュボードを作成して、すべてのリソースの最新の可用性状態について常に最新の情報を提供する。</li><li>影響を受けた VM、ダウンタイムの原因および期間、結果的な修正などの詳細を示す自動根本原因分析 (RCA) を受け取り、ターゲットを絞った調査および事後分析を行えるようにする。</li><li>VM の可用性に重大な変化があった場合、即座に通知を受け取り、迅速に修復アクションをトリガーし、エンドユーザーへの影響を防止する。</li><li>刻々と変化するワークロードの感度やフェールオーバーのニーズに基づき、プラットフォームの回復ポリシーを動的に調整し、自動化する。</li></ul><p>その中で、上記ブログではプレビューであった <a href="https://learn.microsoft.com/ja-jp/azure/governance/resource-graph/overview">Azure Resource Graph</a> を用いた VM の可用性情報の監視が GA として公開され、Azure Monitor による VM 可用性メトリックがパブリック プレビューとして公開されました。</p><blockquote><p> <strong>New Project Flash Update: Advancing Azure Virtual Machine availability monitoring</strong><br> <a href="https://azure.microsoft.com/en-us/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash-update/">https://azure.microsoft.com/en-us/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash-update/</a></p></blockquote><p>このブログでは、Azure Resource Graph を用いた VM の可用性情報がどのように利用できるのかを解説します。<br>本内容がお客様の VM の監視に少しでもお役に立てられれば幸いです。</p><span id="more"></span><hr><h2 id="Azure-Resource-Graph-を用いたVMの可用性情報の監視"><a href="#Azure-Resource-Graph-を用いたVMの可用性情報の監視" class="headerlink" title="Azure Resource Graph を用いたVMの可用性情報の監視"></a>Azure Resource Graph を用いたVMの可用性情報の監視</h2><p>Azure Portal より <a href="https://learn.microsoft.com/ja-jp/azure/governance/resource-graph/first-query-portal">Azure Resource Graph エクスプローラー</a>をご利用いただけます。<br>Azure Resource Graph エクスプローラーの画面を開き、テーブルから <code>healthresources</code> を選択します。</p><p><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-01.png"></p><p>たとえば、次のようなクエリで実行します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">healthresources</span><br><span class="line">| where id contains &quot;eda570ec&quot; //This is subscription id</span><br><span class="line">| project id, type, location, properties</span><br></pre></td></tr></table></figure><div class="alert is-success"><p class="alert-title">ヒント</p><p>Azure Resource Graph では、<a href="https://learn.microsoft.com/ja-jp/azure/data-explorer/kusto/query/">Kusto Query Language (KQL) クエリ</a>を用いて、情報を出力することが可能です。</p><p>上記は <a href="https://learn.microsoft.com/ja-jp/azure/data-explorer/kusto/query/whereoperator">where 演算子</a>で <code>id</code> の中に <code>&quot;eba570ec&quot;</code> があるものに限定して、<a href="https://learn.microsoft.com/ja-jp/azure/data-explorer/kusto/query/projectoperator">project 演算子</a>で表示される項目を記載しています。  </p></div><p>実行後、次のような結果を得ることができます。</p><p><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-02.png"></p><p>右側の詳細の表示を選択することで値を見やすく見ることが可能となります。</p><p><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-03.png"></p><p>この <code>healthresources</code> テーブルには次の項目が存在します。</p><ul><li><code>&quot;microsoft.resourcehealth/availabilitystatuses&quot;</code></li><li><code>&quot;microsoft.resourcehealth/resourceannotations&quot;</code></li></ul><p>それぞれについて紹介します。</p><p><code>&quot;microsoft.resourcehealth/availabilitystatuses&quot;</code> は、Azure プラットフォームによって実行された正常性チェックに基づいて、VM の最新の可用性状態を示します。<br>VM に対して現在出力されている可用性の状態を次に示します。</p><ul><li><strong>available</strong>: VM は期待どおりに稼働しています。</li><li><strong>unavailable</strong>: VM の正常な機能の中断が検出されたため、アプリケーションは期待どおりに実行されません。</li><li><strong>unknown</strong>: プラットフォームは VM の正常性を正確に検出できません。ユーザーは通常、数分後に更新された状態を確認できます。</li></ul><blockquote><p>ご参考情報:<br><strong>Resource Health の概要</strong><br><a href="https://learn.microsoft.com/ja-jp/azure/service-health/resource-health-overview">https://learn.microsoft.com/ja-jp/azure/service-health/resource-health-overview</a><br>　<br><strong>Microsoft.compute/virtualmachines</strong><br><a href="https://learn.microsoft.com/ja-jp/azure/service-health/resource-health-checks-resource-types#microsoftcomputevirtualmachines">https://learn.microsoft.com/ja-jp/azure/service-health/resource-health-checks-resource-types#microsoftcomputevirtualmachines</a></p></blockquote><p><code>&quot;microsoft.resourcehealth/resourceannotations&quot;</code>は、VM の可用性に変化があった場合、必要な障害属性を詳細に説明することで、ユーザーが必要に応じて状態を確認調査し、軽減できるようにします。</p><ul><li><strong>Downtime Annotations</strong>: プラットフォームが VM の可用性が Unavailable に遷移したことを検出すると発行されます。<ul><li>たとえば、予期しないホストのクラッシュ、リブートによる修復操作時など</li></ul></li><li><strong>Informational Annotations</strong>: VM の可用性に影響を与えない Azure 基盤に対する処理実施時に発行されます。<ul><li>VM の割り当て / 停止 / 削除 / 開始など</li><li>通常、これに対するお客様の追加アクションは必要ありません。</li></ul></li><li><strong>Degraded Annotations</strong>: VM の可用性が危険にさらされていることが検出されると発行されます。<ul><li>たとえば、故障予測モデルが、任意の時点で VM を再起動させる可能性のあるハードウェア・コンポーネントの劣化を予測した場合など</li><li>予期せぬデータ損失やダウンタイムを避けるため、アノテーション メッセージで指定された期限までに再デプロイするよう強く求めます。</li></ul></li></ul><blockquote><p>ご参考情報:<br><strong>Resource Health 仮想マシンの正常性に関する注釈</strong><br><a href="https://learn.microsoft.com/ja-jp/azure/service-health/resource-health-vm-annotation">https://learn.microsoft.com/ja-jp/azure/service-health/resource-health-vm-annotation</a></p></blockquote><p>なお、VM の停止 (割り当て解除) を行った場合には、次のような アノテーション イベントを検知することが可能となります。</p><p><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-04.png"></p><p>これらを用いることによりお客様の仮想マシンの可用性の状態を把握することが可能となります。</p><div class="alert is-info"><p class="alert-title">Note</p><p>将来的には、この HealthResources データセットに表示されるアノテーション・メタデータについて複数の機能強化が予定されています。</p><p>これらの機能強化により、ユーザーはより豊富な障害属性に確認することができるようになり、障害への対応策を決定的に準備することができるようになります。</p><p>これと並行して、履歴のルックバック期間を最低 30 日間に延長し、ユーザーが VM の可用性の過去の変化を包括的に追跡できるようにすることを目標としています。</p></div><h2 id="HealthResources-に対する便利な-クエリ"><a href="#HealthResources-に対する便利な-クエリ" class="headerlink" title="HealthResources に対する便利な クエリ"></a>HealthResources に対する便利な クエリ</h2><h3 id="可用性の状態とサブスクリプション-ID-別の仮想マシンの数"><a href="#可用性の状態とサブスクリプション-ID-別の仮想マシンの数" class="headerlink" title="可用性の状態とサブスクリプション ID 別の仮想マシンの数"></a>可用性の状態とサブスクリプション ID 別の仮想マシンの数</h3><p>各サブスクリプションの可用性の状態で集計された仮想マシン (種類 Microsoft.Compute/virtualMachines) の数を返します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type =~ &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">| summarize count() by subscriptionId, AvailabilityState = tostring(properties.availabilityState)</span><br></pre></td></tr></table></figure><p>実行結果:<br>Unknown の VM が1台あることが確認できます。<br><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-05.png"></p><h3 id="リソース-ID-別の仮想マシンおよび関連する可用性状態の一覧"><a href="#リソース-ID-別の仮想マシンおよび関連する可用性状態の一覧" class="headerlink" title="リソース ID 別の仮想マシンおよび関連する可用性状態の一覧"></a>リソース ID 別の仮想マシンおよび関連する可用性状態の一覧</h3><p>可用性の状態で集計された仮想マシン (種類 Microsoft.Compute/virtualMachines) の最新の一覧を返します。<br>また、このクエリでは、デバッグと軽減を容易にするため、properties.targetResourceId に基づいて関連付けられているリソース ID も提供されます。<br>可用性の状態は、4 つの値、Available、Unavailable、Degraded、Unknown のいずれかです。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type =~ &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">| summarize by ResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState)</span><br></pre></td></tr></table></figure><p>実行結果:<br>Unknown の対象 VM は先ほど停止を実施した VM であることが確認できました。<br><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-06.png"></p><h3 id="可用性状態と電源状態別の仮想マシンの一覧と、そのリソース-ID-およびリソース-グループ"><a href="#可用性状態と電源状態別の仮想マシンの一覧と、そのリソース-ID-およびリソース-グループ" class="headerlink" title="可用性状態と電源状態別の仮想マシンの一覧と、そのリソース ID およびリソース グループ"></a>可用性状態と電源状態別の仮想マシンの一覧と、そのリソース ID およびリソース グループ</h3><p>仮想マシンの正常性のまとまりのある状態を提供するために、電源状態と可用性状態で集計された仮想マシン (種類 Microsoft.Compute/virtualMachines) の一覧を返します。<br>また、このクエリでは、各エントリに関連付けられているリソース グループとリソース ID に関する詳細も提供され、リソースを詳細に表示できます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Resources</span><br><span class="line">| where type =~ &#x27;microsoft.compute/virtualmachines&#x27;</span><br><span class="line">| project resourceGroup, Id = tolower(id), PowerState = tostring( properties.extended.instanceView.powerState.code)</span><br><span class="line">| join kind=leftouter (</span><br><span class="line">    HealthResources</span><br><span class="line">    | where type =~ &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">    | where tostring(properties.targetResourceType) =~ &#x27;microsoft.compute/virtualmachines&#x27;</span><br><span class="line">    | project targetResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState))</span><br><span class="line">    on $left.Id == $right.targetResourceId</span><br><span class="line">| project-away targetResourceId</span><br><span class="line">| where PowerState != &#x27;PowerState/deallocated&#x27;</span><br></pre></td></tr></table></figure><p>実行結果:<br>停止 (割り当て解除) 状態の VM が除外され表示されます。<br><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-07.png"></p><h3 id="リソース-ID-別の使用できない仮想マシンの一覧"><a href="#リソース-ID-別の使用できない仮想マシンの一覧" class="headerlink" title="リソース ID 別の使用できない仮想マシンの一覧"></a>リソース ID 別の使用できない仮想マシンの一覧</h3><p>可用性の状態で集計された仮想マシン (種類 Microsoft.Compute/virtualMachines) の最新の一覧を返します。<br>表示された一覧では、可用性の状態が “Available” ではない仮想マシンだけが強調表示され、仮想マシンに関する状態すべてについて確実に認識できます。<br>すべての仮想マシンが使用可能な場合は、結果が表示されないことが想定できます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type =~ &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">| where tostring(properties.availabilityState) != &#x27;Available&#x27;</span><br><span class="line">| summarize by ResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState)</span><br></pre></td></tr></table></figure><p>実行結果:<br>Unavailable や Unknown ステータスの VM が表示されます。<br><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-08.png"></p><p>その他、次のようなクエリが利用可能です。</p><h3 id="プラットフォーム主導の計画外の正常性イベントによる影響を受けた可用性状態をもつリソースの一覧"><a href="#プラットフォーム主導の計画外の正常性イベントによる影響を受けた可用性状態をもつリソースの一覧" class="headerlink" title="プラットフォーム主導の計画外の正常性イベントによる影響を受けた可用性状態をもつリソースの一覧"></a>プラットフォーム主導の計画外の正常性イベントによる影響を受けた可用性状態をもつリソースの一覧</h3><p>Azure プラットフォームによって予期せず発生した計画外の中断の影響を受けた仮想マシンの最新の一覧を返します。<br>このクエリは、影響を受けたすべての仮想マシンを ID プロパティで集約し、対応する可用性状態と、特定の中断を要約した関連する注釈 (properties.reason) と共に返します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type == &quot;microsoft.resourcehealth/resourceannotations&quot;</span><br><span class="line">| where  properties.category == &#x27;Unplanned&#x27; and  properties.context != &#x27;Customer Initiated&#x27;</span><br><span class="line">| project ResourceId = tolower(tostring(properties.targetResourceId)), Annotation = tostring(properties.reason)</span><br><span class="line">| join (</span><br><span class="line">    HealthResources</span><br><span class="line">    | where type == &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">    | project ResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState))</span><br><span class="line">    on ResourceId</span><br><span class="line">| project ResourceId, AvailabilityState, Annotation</span><br></pre></td></tr></table></figure><h3 id="使用できないリソースとそれぞれの注釈詳細の一覧"><a href="#使用できないリソースとそれぞれの注釈詳細の一覧" class="headerlink" title="使用できないリソースとそれぞれの注釈詳細の一覧"></a>使用できないリソースとそれぞれの注釈詳細の一覧</h3><p>現在、使用可能な状態ではない仮想マシンの一覧を、ID プロパティで集約して返します。<br>また、このクエリによって、仮想マシンの実際の可用性状態と、使用できない理由を含む関連する詳細も示されます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type == &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">| where  properties.availabilityState != &#x27;Available&#x27;</span><br><span class="line">| project ResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState)</span><br><span class="line">| join ( </span><br><span class="line">     HealthResources</span><br><span class="line">    | where type == &quot;microsoft.resourcehealth/resourceannotations&quot;</span><br><span class="line">    | project ResourceId = tolower(tostring(properties.targetResourceId)), Reason = tostring(properties.reason), Context = tostring(properties.context), Category = tostring(properties.category))</span><br><span class="line">    on ResourceId</span><br><span class="line">| project ResourceId, AvailabilityState, Reason, Context, Category</span><br></pre></td></tr></table></figure><p>実行結果:<br><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-09.png"></p><h3 id="可用性の障害による影響を受けたリージョン内のリソースの数と、その影響の種類"><a href="#可用性の障害による影響を受けたリージョン内のリソースの数と、その影響の種類" class="headerlink" title="可用性の障害による影響を受けたリージョン内のリソースの数と、その影響の種類"></a>可用性の障害による影響を受けたリージョン内のリソースの数と、その影響の種類</h3><p>現在、使用可能な状態ではない仮想マシンの数を、ID プロパティで集約して返します。<br>また、クエリによって示される対応する場所と注釈の詳細には、VM が使用可能な状態ではない原因も含まれます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type == &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">| where  properties.availabilityState != &#x27;Available&#x27;</span><br><span class="line">| project ResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState), Location = location</span><br><span class="line">| join (</span><br><span class="line">    HealthResources</span><br><span class="line">    | where type == &quot;microsoft.resourcehealth/resourceannotations&quot;</span><br><span class="line">    | project ResourceId = tolower(tostring(properties.targetResourceId)), Context = tostring(properties.context), Category = tostring(properties.category), Location = location)</span><br><span class="line">    on ResourceId</span><br><span class="line">| summarize NumResources = count(ResourceId) by Location, Context, Category</span><br></pre></td></tr></table></figure><h3 id="特定の正常性イベントによる影響を受けるリソースの一覧と、影響時間、影響の詳細、可用性の状態、リージョン"><a href="#特定の正常性イベントによる影響を受けるリソースの一覧と、影響時間、影響の詳細、可用性の状態、リージョン" class="headerlink" title="特定の正常性イベントによる影響を受けるリソースの一覧と、影響時間、影響の詳細、可用性の状態、リージョン"></a>特定の正常性イベントによる影響を受けるリソースの一覧と、影響時間、影響の詳細、可用性の状態、リージョン</h3><p>VirtualMachineHostRebootedForRepair 注釈の影響を受ける仮想マシンの一覧を、その ID プロパティで集約して返します。<br>また、このクエリは、仮想マシンの対応する可用性状態、中断の時間、影響の原因を含む注釈の詳細を返します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type == &quot;microsoft.resourcehealth/resourceannotations&quot;</span><br><span class="line">| where properties.AnnotationName contains &#x27;VirtualMachineHostRebootedForRepair&#x27;</span><br><span class="line">| project ResourceId = tolower(tostring(properties.targetResourceId)), Reason = tostring(properties.reason), Context = tostring(properties.context), Category = tostring(properties.category), Location = location, Timestamp = tostring(properties.occurredTime)</span><br><span class="line">| join ( </span><br><span class="line">    HealthResources</span><br><span class="line">    | where type == &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">    | project ResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState), Location = location)</span><br><span class="line">    on ResourceId</span><br><span class="line">| project ResourceId, Reason, Context, Category, AvailabilityState, Timestamp</span><br></pre></td></tr></table></figure><h3 id="計画イベントによる影響を受けたリソースのリージョンごとの一覧"><a href="#計画イベントによる影響を受けたリソースのリージョンごとの一覧" class="headerlink" title="計画イベントによる影響を受けたリソースのリージョンごとの一覧"></a>計画イベントによる影響を受けたリソースのリージョンごとの一覧</h3><p>Azure プラットフォームによって実施された計画的なメンテナンスまたは修復操作の影響を受けた仮想マシンの一覧を、ID プロパティで集約して返します。<br>また、このクエリは、仮想マシンの対応する可用性状態、中断の時間、場所、影響の原因を含む注釈の詳細を返します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type == &quot;microsoft.resourcehealth/resourceannotations&quot;</span><br><span class="line">| where properties.category contains &#x27;Planned&#x27;</span><br><span class="line">| project ResourceId = tolower(tostring(properties.targetResourceId)), Reason = tostring(properties.reason), Location = location, Timestamp = tostring(properties.occuredTime)</span><br><span class="line">| join ( </span><br><span class="line">    HealthResources</span><br><span class="line">    | where type == &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">    | project ResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState), Location = location)</span><br><span class="line">    on ResourceId</span><br><span class="line">| project ResourceId, Reason, AvailabilityState, Timestamp, Location</span><br></pre></td></tr></table></figure><h3 id="計画外のプラットフォーム中断の影響を受けたリソースの一覧と、可用性、電力状態、場所"><a href="#計画外のプラットフォーム中断の影響を受けたリソースの一覧と、可用性、電力状態、場所" class="headerlink" title="計画外のプラットフォーム中断の影響を受けたリソースの一覧と、可用性、電力状態、場所"></a>計画外のプラットフォーム中断の影響を受けたリソースの一覧と、可用性、電力状態、場所</h3><p>Azure プラットフォームによって実施された計画的なメンテナンスまたは修復操作の影響を受けた仮想マシンの一覧を、ID プロパティで集約して返します。<br>また、このクエリによって、仮想マシンの対応する可用性状態、電力状態、場所の詳細も示されます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type =~ &#x27;microsoft.resourcehealth/resourceannotations&#x27;</span><br><span class="line">| where tostring(properties.context) == &#x27;Platform Initiated&#x27; and tostring(properties.category) == &#x27;Planned&#x27;</span><br><span class="line">| project ResourceId = tolower(properties.targetResourceId), Location = location</span><br><span class="line">| join (</span><br><span class="line">    HealthResources</span><br><span class="line">    | where type =~ &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">    | project ResourceId = tolower(properties.targetResourceId), AvailabilityState = tostring(properties.availabilityState), Location = location)</span><br><span class="line">    on ResourceId</span><br><span class="line">| join (</span><br><span class="line">    Resources</span><br><span class="line">    | where type =~ &#x27;microsoft.compute/virtualmachines&#x27;</span><br><span class="line">    | project ResourceId = tolower(id), PowerState = properties.extended.instanceView.powerState.code, Location = location)</span><br><span class="line">    on ResourceId</span><br><span class="line">| project ResourceId, AvailabilityState, PowerState, Location</span><br></pre></td></tr></table></figure><p>次に Azure Monitor による VM の可用性メトリックを紹介します。</p><h2 id="Azure-Monitor-による-VM-の可用性メトリック-Preview"><a href="#Azure-Monitor-による-VM-の可用性メトリック-Preview" class="headerlink" title="Azure Monitor による VM の可用性メトリック (Preview)"></a>Azure Monitor による VM の可用性メトリック (Preview)</h2><p>VM 可用性についてのメトリックが取得できるようになりました。<br>このメトリックを用いることで、可用性が低下した場合に、しきい値ベースのメトリックアラートを設定し、適切な軽減措置を迅速にトリガーするよう設定することが可能となりました。</p><p><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-10.png"><br><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-11.png"></p><p>上記の結果より、VM を停止したことで可用性の低下が発生したことを確認できます。</p><h2 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h2><p>Azure ではこの Project Flash を通じて、お客様のエクスペリエンスの継続的な改善を目的とし監視プラットフォームの強化を実施してまいります。</p><p>以前は Azure 基盤で発生した問題について、何が起こったのかわからず大きな不安を抱えることもあったかと存じます。</p><p>Azure 基盤で発生した問題について、お客様の視認性を強化し、可能な限り迅速に情報提供をすることで、お客様への影響とご不安を最小限にするように引き続き信頼性向上に努めてまいります。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポート チームの鳥越です。&lt;/p&gt;
&lt;p&gt;2022年に Azure 仮想マシンの可用性の監視を進化するプロジェクトである Project Flash について、以下のブログで紹介されました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; &lt;strong&gt;Project Flash で Azure 仮想マシンの可用性の監視を進化させる&lt;/strong&gt;&lt;br&gt; &lt;a href=&quot;https://azure.microsoft.com/ja-jp/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash/&quot;&gt;https://azure.microsoft.com/ja-jp/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;このプロジェクトは Azure 仮想マシンに対して、お客様の可用性監視ニーズを満たすために、次のようなことが行えるように進められております。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VM の可用性障害 (VM のリブートや再起動のほか、ネットワーク ドライバーの更新によるアプリケーションのフリーズ、30 秒間のホスト OS の更新など) に関する正確で実用的なデータ、および障害の詳細 (プラットフォームのものかユーザー操作によるものか、リブートかフリーズか、計画的か非計画的かなど) を入手する。&lt;/li&gt;
&lt;li&gt;VM の可用性の傾向を分析してアラートを生成し、迅速なデバッグと前月比のレポート作成を実現する。&lt;/li&gt;
&lt;li&gt;データを定期的かつ大規模に監視し、カスタム ダッシュボードを作成して、すべてのリソースの最新の可用性状態について常に最新の情報を提供する。&lt;/li&gt;
&lt;li&gt;影響を受けた VM、ダウンタイムの原因および期間、結果的な修正などの詳細を示す自動根本原因分析 (RCA) を受け取り、ターゲットを絞った調査および事後分析を行えるようにする。&lt;/li&gt;
&lt;li&gt;VM の可用性に重大な変化があった場合、即座に通知を受け取り、迅速に修復アクションをトリガーし、エンドユーザーへの影響を防止する。&lt;/li&gt;
&lt;li&gt;刻々と変化するワークロードの感度やフェールオーバーのニーズに基づき、プラットフォームの回復ポリシーを動的に調整し、自動化する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;その中で、上記ブログではプレビューであった &lt;a href=&quot;https://learn.microsoft.com/ja-jp/azure/governance/resource-graph/overview&quot;&gt;Azure Resource Graph&lt;/a&gt; を用いた VM の可用性情報の監視が GA として公開され、Azure Monitor による VM 可用性メトリックがパブリック プレビューとして公開されました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; &lt;strong&gt;New Project Flash Update: Advancing Azure Virtual Machine availability monitoring&lt;/strong&gt;&lt;br&gt; &lt;a href=&quot;https://azure.microsoft.com/en-us/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash-update/&quot;&gt;https://azure.microsoft.com/en-us/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash-update/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;このブログでは、Azure Resource Graph を用いた VM の可用性情報がどのように利用できるのかを解説します。&lt;br&gt;本内容がお客様の VM の監視に少しでもお役に立てられれば幸いです。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Monitoring / Alert" scheme="https://jpaztech.github.io/blog/tags/Monitoring-Alert/"/>
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
  </entry>
  
  <entry>
    <title>Classic VM から ARM への移行についての注意事項 (VM、ストレージ編)</title>
    <link href="https://jpaztech.github.io/blog/vm/migrate_classic_vm_and_storage/"/>
    <id>https://jpaztech.github.io/blog/vm/migrate_classic_vm_and_storage/</id>
    <published>2022-12-29T08:30:00.000Z</published>
    <updated>2023-01-10T02:14:50.704Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポート チームの鳥越です。<br>2014年に Azure Resource Manager モデルがリリースされており、リタイアがアナウンスされた 2020 年 7 月時点で既に 90% が Azure Resource Manager モデルで利用されておりました。  </p><p>Azure 初期で利用されておりました Azure Service Manager (ASM) を介した IaaS 仮想マシン (VM) の管理を2020 年 2 月 28 日 に 非推奨として <strong>2023 年 3 月 1 日</strong> に完全に廃止される予定です。  </p><blockquote><p>■ご参考： 2023 年 3 月 1 日までに IaaS リソースを Azure Resource Manager に移行する<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/classic-vm-deprecation">https://learn.microsoft.com/ja-jp/azure/virtual-machines/classic-vm-deprecation</a></p></blockquote><p>そのため、これから 2023 年 3 月 1 日までに移行計画を立てていらっしゃるお客様に対して、移行がスムーズに行えるようにあらかじめ確認しておくべきポイントをお纏めしました。<br>本内容がお客様の移行作業に少しでもお役に立てば幸いでございます。  </p><hr><h2 id="移行作業の全体像"><a href="#移行作業の全体像" class="headerlink" title="移行作業の全体像"></a>移行作業の全体像</h2><blockquote><p>■ご参考：プラットフォームでサポートされているクラシックから Azure Resource Manager への移行に関する技術的な詳細<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/migration-classic-resource-manager-deep-dive">https://learn.microsoft.com/ja-jp/azure/virtual-machines/migration-classic-resource-manager-deep-dive</a></p></blockquote><p>Azure ではリソースの管理操作にかかわる Control Plane と実際のリソースに対する Data Plane が存在します。<br>ASM (Azure Service Manager) から ARM (Azure Resource Manager) への移行は Control Plane に対する操作となります。  </p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image1.png"></p><p>原則として Data Plane はそのまま使用可能なので、ユーザー目線から見た場合、VM の動作状況や、ストレージアカウント上へのアクセスには影響がないように見えます。<br>しかしながら、移行非対応の機能のための構成変更に伴い、ユーザー目線でのダウンタイムが発生する可能性はございます。  </p><p>例えば、クラシック VM においては、「仮想ネットワークに配置されていない VM」という構成があり得ましたが、ARM<br>における VM では全ての仮想マシンが仮想ネットワーク上に配置されます。<br>従いまして、仮想ネットワークに配置されていないクラシック VM を、ARM に移行する場合、移行手順の途上で VM の停止が伴います。  </p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image2.png"></p><hr><h2 id="移行をサポートしていないリソース"><a href="#移行をサポートしていないリソース" class="headerlink" title="移行をサポートしていないリソース"></a>移行をサポートしていないリソース</h2><p>また、移行中は、管理系の操作が行えないことも合わせてご理解いただく必要がございます。<br>例えば、VMのサイズ変更、開始、停止、再起動、再デプロイ、ディスクの構成変更、ネットワーク的な構成変更<br>が実施できなくなる操作となります。<br>そのため、移行で問題が生じたときに、VM 側の操作ができないといった事態に陥る可能性もゼロではございません。  </p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image3.png"></p><p>全体的な移行の流れは上記図のようになります。  </p><hr><h2 id="事前準備-重要"><a href="#事前準備-重要" class="headerlink" title="事前準備 (重要)"></a>事前準備 (重要)</h2><h3 id="1-クラシックリソースの操作に対応した、クラシック用の-Azure-PowerShell-を実施前にご用意ください。"><a href="#1-クラシックリソースの操作に対応した、クラシック用の-Azure-PowerShell-を実施前にご用意ください。" class="headerlink" title="(1) クラシックリソースの操作に対応した、クラシック用の Azure PowerShell を実施前にご用意ください。"></a>(1) クラシックリソースの操作に対応した、クラシック用の Azure PowerShell を実施前にご用意ください。</h3><p>クラシックリソース用の Azure PowerShell コマンドは、現行の ARM 対応の”AzureRM” や “Az” というモジュールではなく、”Azure” という名称で配布されています。<br>インストール方法は、以下の技術文書をご参照ください。  </p><blockquote><p>■ご参考：Azure PowerShell Service Management モジュールのインストール<br><a href="https://learn.microsoft.com/ja-jp/powershell/azure/servicemanagement/install-azure-ps?view=azuresmps-4.0.0">https://learn.microsoft.com/ja-jp/powershell/azure/servicemanagement/install-azure-ps?view=azuresmps-4.0.0 </a></p></blockquote><p>なお、クラシック Azure PowerShell によるリソース管理には、Azure サブスクリプションにおける [従来の管理者]<br>の割り当てが必要になることにご注意ください。  </p><blockquote><p>■ご参考：Azure の従来のサブスクリプション管理者<br><a href="https://learn.microsoft.com/ja-jp/azure/role-based-access-control/classic-administrators">https://learn.microsoft.com/ja-jp/azure/role-based-access-control/classic-administrators</a></p></blockquote><p>多くの場合、移行が失敗した場合には、コマンドベースで回復作業を実施します。<br>そのため、事前にクラシックリソース用 Azure PowerShell を利用いただける環境をご用意いただけますと幸いです。  </p><h3 id="2-クラシック-Azure-PowerShellを用いて事前チェックをお願いいたします"><a href="#2-クラシック-Azure-PowerShellを用いて事前チェックをお願いいたします" class="headerlink" title="(2) クラシック Azure PowerShellを用いて事前チェックをお願いいたします"></a>(2) クラシック Azure PowerShellを用いて事前チェックをお願いいたします</h3><p>例えば、よくあるお問合せとして、ストレージアカウント内にディスクリソースが存在するためクラシックストレージアカウントの移行に失敗するといったお問い合わせがございます。  </p><p>Portal 側の手順ではこの点考慮されていない部分がございますので、下記について PowerShell を利用いただきチェックいただけますと幸いです。<br>VM が移行完了しておらず、クラシックストレージアカウントに VM で利用中のディスクリソースが残ってしまっていないかの等のチェック方法は以下の通りです。  </p><ul><li>(2-1) ディスクがストレージ アカウントに格納されている仮想マシンを移行する。  </li></ul><p>次のコマンドは、ストレージ アカウント内のすべての VM ディスクの<br>RoleName および DiskName プロパティを返します。 RoleName<br>はディスクが接続される仮想マシンの名前です。<br>このコマンドでディスクが返される場合、ストレージ<br>アカウントを移行する前にこれらのディスクが接続されている仮想マシンが移行されている必要があります。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$storageAccountName</span> = <span class="string">&#x27;yourStorageAccountName&#x27;</span></span><br><span class="line"></span><br><span class="line">Get-AzureDisk | where-Object &#123;<span class="variable">$_</span>.MediaLink.Host.Contains(<span class="variable">$storageAccountName</span>)&#125; | Select-Object -ExpandProperty AttachedTo -Property DiskName | Format-List -Property RoleName, DiskName  </span><br></pre></td></tr></table></figure><ul><li>(2-2) ストレージ アカウントに格納されている、接続されていない VM ディスクを削除する。  </li></ul><p>次のコマンドを使用して、ストレージ アカウントの接続されていない VM<br>ディスクを探します。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$storageAccountName</span> = <span class="string">&#x27;yourStorageAccountName&#x27;</span></span><br><span class="line"></span><br><span class="line">Get-AzureDisk | where-Object</span><br><span class="line">&#123;<span class="variable">$_</span>.MediaLink.Host.Contains(<span class="variable">$storageAccountName</span>)&#125; | Where-Object -Property AttachedTo -EQ <span class="variable">$null</span> | Format-List -Property DiskName</span><br></pre></td></tr></table></figure><p>上記のコマンドでディスクが返された場合、次のコマンドを使用してこれらのディスクを削除します。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Remove-AzureDisk -DiskName <span class="string">&#x27;yourDiskName&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>(2-3) ストレージ アカウントに格納されている VM イメージを削除する。  </li></ul><p>次のコマンドは、ストレージ アカウントに格納されたすべての VM イメージと OS ディスクを返します。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-AzureVmImage | Where-Object &#123; <span class="variable">$_</span>.OSDiskConfiguration.MediaLink -ne <span class="variable">$null</span> -and <span class="variable">$_</span>.OSDiskConfiguration.MediaLink.Host.Contains(<span class="variable">$storageAccountName</span>)&#125; | Select-Object -Property ImageName, ImageLabel</span><br></pre></td></tr></table></figure><p>次のコマンドは、ストレージ アカウントに格納されたすべての VM イメージとデータ ディスクを返します。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-AzureVmImage | Where-Object &#123;<span class="variable">$_</span>.DataDiskConfigurations -ne <span class="variable">$null</span> -and (<span class="variable">$_</span>.DataDiskConfigurations | Where-Object &#123;<span class="variable">$_</span>.MediaLink -ne <span class="variable">$null</span> -and <span class="variable">$_</span>.MediaLink.Host.Contains(<span class="variable">$storageAccountName</span>)&#125;).Count -gt 0 &#125; | Select-Object -Property ImageName, ImageLabel</span><br></pre></td></tr></table></figure><p>次のコマンドを使用して、上記のコマンドによって返されるすべての VM イメージを削除します。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Remove-AzureVMImage -ImageName <span class="string">&#x27;yourImageName&#x27;</span>  </span><br></pre></td></tr></table></figure><hr><h2 id="検証フェーズ"><a href="#検証フェーズ" class="headerlink" title="検証フェーズ"></a>検証フェーズ</h2><p>検証フェーズでは移行対象リソースが前提条件を満たしているのかチェックします。<br>ただし、この検証フェーズですべての前提条件がチェックされる訳ではない点注意が必要です。  </p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image4.png"></p><hr><h2 id="準備フェーズ"><a href="#準備フェーズ" class="headerlink" title="準備フェーズ"></a>準備フェーズ</h2><p>準備フェーズでは、リソースの実体に対して、ASM側にもARM側にもリソースが表示されるようになります。  </p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image5.png"></p><p>このタイミングで管理系操作はロックされるため、Commit で実行フェーズに進むか Abort で強制終了するかのどちらかの作業が必要となります。  </p><h3 id="準備フェーズでの重要な注意点"><a href="#準備フェーズでの重要な注意点" class="headerlink" title="準備フェーズでの重要な注意点"></a>準備フェーズでの重要な注意点</h3><p>注意点となりますが、ASM から ARM への移行に際し VM 単位で実施する場合に  </p><p>Prepare -&gt; Commit<br>の間に 4 分間の間隔を空けないと移行処理が失敗するという報告がございます。  </p><p>このような状態に陥った場合、Portalでの対処ができず、先にご案内しましたクラシック用の PowerShell により以下のコマンドで Commit を実行いただく必要がございます。  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># クラシック VM が配置されているクラウドサービス名に置き換えてください</span></span><br><span class="line"><span class="variable">$serviceName</span> = <span class="string">&quot;My Service&quot;</span></span><br><span class="line"><span class="variable">$deployment</span> = Get-AzureDeployment -ServiceName <span class="variable">$serviceName</span>  </span><br><span class="line"><span class="variable">$deploymentName</span> = <span class="variable">$deployment</span>.DeploymentName  </span><br><span class="line">Move-AzureService -Commit -ServiceName <span class="variable">$serviceName</span> -DeploymentName <span class="variable">$deploymentName</span>  </span><br></pre></td></tr></table></figure><hr><h2 id="実行フェーズ"><a href="#実行フェーズ" class="headerlink" title="実行フェーズ"></a>実行フェーズ</h2><p>実行フェーズにてリソースの実体に対してクラシック側の参照が切り離される動作となります。  </p><p>これにより ARM への移行が完了します。  </p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image6.png"></p><hr><h2 id="ASMから-ARM-に移行される際の-FAQ"><a href="#ASMから-ARM-に移行される際の-FAQ" class="headerlink" title="ASMから ARM に移行される際の FAQ"></a>ASMから ARM に移行される際の FAQ</h2><p>公式ドキュメントとしては以下のご用意がございます。  </p><blockquote><p>■ご参考：クラシックから Azure Resource Manager への移行に関してよく寄せられる質問<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/migration-classic-resource-manager-faq">https://learn.microsoft.com/ja-jp/azure/virtual-machines/migration-classic-resource-manager-faq</a></p></blockquote><p>問題が発生した場合の対処コマンドについては、以下に記載させていただきます。</p><ol><li>移行の Abort  </li></ol><p>移行作業をどうしても Abort したい場合には下記コマンドを実施ください。<br>デバッグ出力も併せて表示されますので、何らかのエラーが発生する場合は、デバッグ出力も添えて Azure サポート窓口へのお問い合わせをご検討ください。  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># クラシック VM が配置されているクラウドサービス名に置き換えてください</span></span><br><span class="line"><span class="variable">$serviceName</span> = <span class="string">&quot;My Service&quot;</span></span><br><span class="line"><span class="variable">$deployment</span> = Get-AzureDeployment -ServiceName <span class="variable">$serviceName</span>  </span><br><span class="line"><span class="variable">$deploymentName</span> = <span class="variable">$deployment</span>.DeploymentName  </span><br><span class="line">Move-AzureService -Abort -ServiceName <span class="variable">$serviceName</span> -DeploymentName <span class="variable">$deploymentName</span> -debug -verbose</span><br></pre></td></tr></table></figure><ol start="2"><li>ストレージアカウントのコミット方法  </li></ol><p>移行作業でポータルから操作ができず、Azure PowerShell を利用してコミットが必要なケースが存在します。<br>そのような場合には以下のように Commit の実施をお願いいたします。<br>デバッグ出力も併せて表示されますので、何らかのエラーが発生する場合は、デバッグ出力も添えて Azure サポート窓口へのお問い合わせをご検討ください。  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$storageAccountName</span> = <span class="string">&quot;myStorageAccount&quot;</span>  </span><br><span class="line">Move-AzureStorageAccount -Commit -StorageAccountName <span class="variable">$storageAccountName</span> -debug -verbose  </span><br></pre></td></tr></table></figure><ol start="3"><li>VNETを含んだVM の移行について  </li></ol><p>VNETを含んだVM移行については今回割愛しておりますが、移行に問題が発生した際に、PowerShell を利用した切り分け作業の実施が必要となります。  </p><p>上記の通り、PowerShell 環境の事前の準備と問題が発生した際には -debug オプションと -verbose オプションを利用した原因調査の実施が必要となりますのであらかじめご承知おきいただけますと幸いです。</p><ol start="4"><li>移行がスタックした際にクラシック VM から新規 の ARM の VM を手動で作成する  </li></ol><p>移行が途中でスタックした際には上記記載の通り管理操作を行うことができません。<br>そのため、VM の起動再開といった作業が実現できないこととなります。<br>この場合、VM で利用されていた VHD を利用して新たにVMを作成することで、スタックの状況を回避することが可能となります。<br>作業としては以下の流れで作業の実施をお願いいたします。  </p><h3 id="4-1-コピー先-URL-を準備"><a href="#4-1-コピー先-URL-を準備" class="headerlink" title="4-1 コピー先 URL を準備"></a>4-1 コピー先 URL を準備</h3><p>a.ARM 仮想マシン用のストレージ アカウントを作成します。  </p><p>a-1.Azure Portal より [ストレージ アカウント] を開き、[追加] をクリックします。<br>適宜値を設定し、ストレージ アカウントを作成します。  </p><p>a-2.作成後、[ストレージ アカウント] - [&lt;当該ストレージ アカウント&gt;] を選択し、左メニュー &quot;Blob service&quot; から [コンテナー] を選択します。<br>[+ コンテナー] をクリックし [vhds] という名前でコンテナーを作成します。  </p><p>b.VHD ファイルをコピーするためのコピー先の SAS を発行します。  </p><p>b-1.a-1 で作成した [&lt;当該ストレージ アカウント&gt;] を選択し、左メニュー &quot;設定&quot;から、[Shared Access Signature] を選択します。  </p><p>b-2.適宜設定を行い、[SAS と接続文字列を生成する] をクリックします。  </p><p>b-3.[Blob service の SAS URL] をテキストエディタ等にコピーしておきます。  </p><p>c.b-3 を下記の通り編集し、テキスト エディタ等にコピーしておきます。  </p><blockquote><p>編集前: https://&lt;ストレージ アカウント名&gt;.blob.core.windows.net/?&lt;SAS&gt;  </p></blockquote><blockquote><p>編集後: https://&lt;ストレージ アカウント名&gt;.blob.core.windows.net/vhds/&lt;コピー後の VHD ファイル名&gt;?&lt;SAS&gt;  </p></blockquote><p>コピー後の VHD ファイル名は「.vhd」拡張子となるようにご指定ください。  </p><blockquote><p>【ご参考】<br>a から c の手順は、当初より公開しております以下の記事にも記載がございます。<br>Azure VM からエクスポートした VHD ファイルを用いた複製 VM の作成方法のページにおける<br>[1] コピー先のストレージ アカウントおよびコンテナ―を作成する、[2] コピー先の SAS を発行する<br>の手順と同様です。  </p><p>■ご参考：Azure VM からエクスポートした VHD ファイルを用いた複製 VM の作成方法<br><a href="https://jpaztech.github.io/blog/vm/create-vm-using-vhd/">https://jpaztech.github.io/blog/vm/create-vm-using-vhd/</a></p></blockquote><h3 id="4-2-コピー元のVMの停止"><a href="#4-2-コピー元のVMの停止" class="headerlink" title="4-2 コピー元のVMの停止"></a>4-2 コピー元のVMの停止</h3><p>d. コピー元の仮想マシンを停止します。  </p><h3 id="4-3-コピー元-URL-を準備"><a href="#4-3-コピー元-URL-を準備" class="headerlink" title="4-3 コピー元 URL を準備"></a>4-3 コピー元 URL を準備</h3><p>事前に VM のディスクに関してスナップショットを取得します。  </p><p>e.クラシック仮想マシン の VHD にてスナップショットを取得します。  </p><p>e-1.Azure Portal にて、[ストレージ アカウント] - [&lt;当該 (クラシック) ストレージアカウント名&gt;] を選択し、左メニュー &quot;Blob service&quot; から [コンテナー] を選択します。  </p><p>e-2.[vhds (コンテナー名)] - [&lt;ファイル名.vhd&gt;] の […] をクリックし、[スナップショットの作成] をクリックします。  </p><p>e-3.[vhds (コンテナー名)] - [&lt;ファイル名.vhd&gt;] の […] をクリックし、[スナップショットの表示] をクリックします。  </p><p>該当スナップショットの […] をクリックし、ダブルクリックして表示される [スナップショットのプロパティ] から URL をテキスト エディタ等にコピーしておきます。  </p><p>f.クラシック仮想マシン で作成した VHD ファイルをコピーするための SAS を発行します。  </p><p>f-1.上記 e-2, 3 と同様に [vhds (コンテナー名)] - [&lt;ファイル名.vhd&gt;] の […] をクリックし、[SAS の生成] をクリックします。</p><p>f-2.適宜設定を行い、[SAS トークンおよび URL を生成] をクリックします。  </p><p>f-3.[BLOB SAS トークン] をテキスト エディタ等にコピーしておきます。  </p><p>g.コピー元の URL を合わせ、テキスト エディタ等準備しておきます。  </p><p>スナップショットを azcopy で複製する場合のコピー元URL作成手順は　以下のようになります。  </p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image7.png"></p><p>g-1.e-3 で準備したURLを前半（VHDのパスまで）、後半（?マークから後ろ）に分けます。  </p><blockquote><p>元々のスナップショットの URL は以下とした場合の例。  </p><p>https://&lt;コピー元のストレージアカウント＞.blob.core.windows.net/vhds/ファイル名.vhd ?snapshot=YYYY-MM-DDThhmm:ss.nnnnnnnZ  </p></blockquote><blockquote><p>前半：<br>https://&lt;コピー元のストレージアカウント＞.blob.core.windows.net/vhds/ファイル名.vhd  </p></blockquote><blockquote><p>後半（?マークから後ろ）：<br>snapshot=YYYY-MM-DDThhmm:xxxxxxxxx  </p></blockquote><p>g-2. （g-1の前半部分）＋（?）＋（SAS文字列）+ (＆) +（g-1の後半部分）を連結し、以下のようなコピー元URLを準備します。  </p><blockquote><p>https://&lt;コピー元のストレージアカウント＞.blob.core.windows.net/vhds/ファイル名.vhd?＜SAS文字列＞&amp;snapshot=YYYY-MM-DDThh:mmss.nnnnnnnZ  </p></blockquote><h3 id="4-4-AzCopy-コマンドを準備Azcopy-で-vhd-ファイルをコピー"><a href="#4-4-AzCopy-コマンドを準備Azcopy-で-vhd-ファイルをコピー" class="headerlink" title="4-4 AzCopy コマンドを準備Azcopy で vhd ファイルをコピー"></a>4-4 AzCopy コマンドを準備Azcopy で vhd ファイルをコピー</h3><p>h.作業環境に AzCopy コマンドをダウンロードします。<br>(Cloud Shell をご利用の場合は不要です。)  </p><blockquote><p>■ご参考：AzCopy を使ってみる<br><a href="https://docs.microsoft.com/ja-jp/azure/storage/common/storage-use-azcopy-v10">https://docs.microsoft.com/ja-jp/azure/storage/common/storage-use-azcopy-v10</a></p></blockquote><p>i.以下のようにコマンドを実行し、VHD をコピーします。  </p><p>azcopy copy &quot;&lt;事前準備 g で準備した URL ファイル名.vhd?SAS文字列&amp;snapshot=日時を含む文字列&gt;&quot; &quot;&lt;事前準備 c でコピーした URL? SAS&gt;&quot; --blob-type PageBlob  </p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image8.png"></p><p>正常に転送が完了した場合は以下のような例の表示となります。</p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image9.png"></p><p>これにより、ARM 環境のストレージアカウントに ASM 環境の VHD ファイルのコピーができました。  </p><h3 id="4-5-vhdを元にディスクを作成、仮想マシンを作成"><a href="#4-5-vhdを元にディスクを作成、仮想マシンを作成" class="headerlink" title="4-5 vhdを元にディスクを作成、仮想マシンを作成"></a>4-5 vhdを元にディスクを作成、仮想マシンを作成</h3><p>j.ARM 環境の仮想マシンを作成します。  </p><p>j-1.Azure Portal より [ディスク] を開き、[+ 追加] をクリックします。  </p><p>j-2.適宜設定を行い、[確認および作成] - [作成] をクリックします。  </p><p>・d-1 のストレージ アカウントと同様の &quot;リソース グループ&quot; を選択します。<br>・&quot;ソースの種類&quot; は [ストレージ BLOB] を選択します。<br>・&quot;ソース BLOB&quot; は d-1 のストレージ アカウントの vhds にコピーした VHD ファイルを選択します。<br>・&quot;OS の種類&quot; は適宜選択します。  </p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image10.png"></p><p>j-3.Azure Portal より作成した OS ディスクを開き、[+ VM の作成] をクリックします。  </p><p>j-4.適宜設定を行い、[確認および作成] - [作成] をクリックします。  </p><p>k.ARM 仮想マシンに接続し、必要に応じて動作を確認します。  </p><blockquote><p>【ご参考】<br>j から k の手順は、当初より公開しております以下の記事にも記載がございます。<br>Azure VM からエクスポートした VHD ファイルを用いた複製 VM の作成方法のページにおける<br>[5] VHD ファイルから管理ディスクを作成する<br>[6] VHD ファイルから作成したディスクで VM を作成する。<br>と同様です。  </p><p>■ご参考：Azure VM からエクスポートした VHD ファイルを用いた複製 VM の作成方法<br><a href="https://jpaztech.github.io/blog/vm/create-vm-using-vhd/">https://jpaztech.github.io/blog/vm/create-vm-using-vhd/</a></p></blockquote><p>以上の手順で、移行がスタックした際にクラシック VM から新規 の ARM の VM を手動で作成することが可能となります。<br>これらの記事の内容が皆様のお役にたてれば幸いでございます。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポート チームの鳥越です。&lt;br&gt;2014年に Azure Resource Manager モデルがリリースされており、リタイアがアナウンスされた 2020 年 7 月時点で既に 90% が Azure Resource Manage</summary>
      
    
    
    
    
    <category term="Migration" scheme="https://jpaztech.github.io/blog/tags/Migration/"/>
    
    <category term="Storage" scheme="https://jpaztech.github.io/blog/tags/Storage/"/>
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes の監査ログで AKS クラスターで起こるすべてのことを追跡しよう</title>
    <link href="https://jpaztech.github.io/blog/containers/aks-kube-audit/"/>
    <id>https://jpaztech.github.io/blog/containers/aks-kube-audit/</id>
    <published>2022-12-24T06:00:00.000Z</published>
    <updated>2023-01-10T02:14:50.320Z</updated>
    
    <content type="html"><![CDATA[<p>この記事は <a href="https://qiita.com/advent-calendar/2022/microsoft-azure-tech">Microsoft Azure Tech Advent Calendar 2022</a> の 24 日目の記事になります🎅</p><p>こんにちは。Azure テクニカル サポートチームの桐井です。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/aks/intro-kubernetes">Azure Kubernetes Service (AKS)</a> のクラスターを利用しているときに、アプリケーションがデプロイされたタイミングや、ノードのステータスがいつどのような理由で変わったのかなど、過去にクラスターで起こったイベントの履歴を確認したい場合があります。Kubernetes の監査ログを活用すると、これらのイベントをログから確認できるようになります。</p><p>本記事では、Kubernetes の監査ログの紹介と、AKS において監査ログ利用する方法を、実例を交えて解説します。</p><span id="more"></span><hr><h2 id="Kubernetes-の監査ログ-kube-audit"><a href="#Kubernetes-の監査ログ-kube-audit" class="headerlink" title="Kubernetes の監査ログ (kube-audit)"></a>Kubernetes の監査ログ (kube-audit)</h2><p>Kubernetes のクラスターは大きく分けて、<strong>コントロール プレーン</strong> と <strong>ノード</strong> の 2 つのコンポーネントで構成されています。<br>クラスターに対する各種操作は、コントロール プレーンに存在する <strong><a href="https://kubernetes.io/ja/docs/concepts/overview/components/#kube-apiserver">API サーバー (kube-apiserver)</a></strong> が提供する Kubernetes API を介して行われます。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit01.png" alt="Kubernetes クラスターのアーキテクチャー"></p><p>クラスターの利用者が実行する <a href="https://kubernetes.io/ja/docs/reference/kubectl/overview/">kubectl コマンド</a>は、API サーバーに対してリクエストを送信することで、Pod をはじめとするクラスター内のオブジェクトの作成や変更をします。</p><p>また、ノード上で稼働する <a href="https://kubernetes.io/ja/docs/concepts/overview/components/#kubelet">kubelet</a> やシステム Pod、さらにはコントロール プレーンを構成するコンポーネントも、API サーバーに対してアクセスをしています。各コンポーネントが自身の役割を果たすことで、Kubernetes クラスターの動作が成り立っています。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p>たとえば、新しい Pod が作成された際には、<a href="https://kubernetes.io/ja/docs/concepts/overview/components/#kube-scheduler">kube-scheduler</a> が Pod のデプロイに最適なノードを決定し、その結果を API サーバーへ報告します。Pod が割り当てられたノードでは、kubelet が Pod の仕様を読み取り、その内容に従ってコンテナー ランタイムにコンテナーの起動を指示します。コンテナーの起動が成功すると、API サーバーに対して Pod ステータスの更新がリクエストされ、Pod が動作中であると記録します。</p></div><p>そのため、API サーバーにどのようなリクエストが届いて、そのレスポンス (実行結果) はどのような内容であったのか記録されたログがあれば、クラスターで過去に行われた操作や発生したイベントを追跡できます。</p><p>Kubernetes では<strong>監査ログ (kube-audit)</strong> 機能を利用することで、API サーバーのアクセス ログを得ることができます。監査ログには、クラスター内で行われた一連の操作が記録されています。</p><blockquote><p><strong>Kubernetesドキュメント / 監査</strong><br><a href="https://kubernetes.io/ja/docs/tasks/debug/debug-cluster/audit/">https://kubernetes.io/ja/docs/tasks/debug/debug-cluster/audit/</a></p></blockquote><h3 id="Kubernetes-の監査ログの内容"><a href="#Kubernetes-の監査ログの内容" class="headerlink" title="Kubernetes の監査ログの内容"></a>Kubernetes の監査ログの内容</h3><p>Kubernetes の監査ログの構造や、どのような情報が記録されているかについて、実例をもとに解説します。<br>ここでは、<code>kubectl get pod</code> コマンドで Pod の情報を取得した際のログを確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pod nginx</span></span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx   1/1     Running   0          6d4h</span><br></pre></td></tr></table></figure><p>コマンドを実行すると、<code>GET https://&#123;API Server FQDN&#125;:443/api/v1/namespaces/default/pods/nginx</code> のように、API サーバーに対して HTTPS のリクエストが送信されます。</p><p>API サーバーは、リクエストにしたがって必要な処理を行い、クライアントへレスポンスを返します。そして、監査ログにその記録を出力します。監査ログは JSON 形式で出力されます。</p><blockquote><p><strong>Kubernetes Documentation / Reference / Configuration APIs / kube-apiserver Audit Configuration (v1) - Event</strong><br><a href="https://kubernetes.io/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event">https://kubernetes.io/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event</a></p></blockquote><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit02.png" alt="Pod の情報を取得した際の kube-audit ログの例"></p><p>このログから、次のことがわかります。ログの該当箇所を抜粋して解説します。</p><h4 id="WHAT-何が起きたのか？"><a href="#WHAT-何が起きたのか？" class="headerlink" title="WHAT: 何が起きたのか？"></a>WHAT: 何が起きたのか？</h4><p><code>&quot;verb&quot;</code> は <a href="https://kubernetes.io/docs/reference/using-api/api-concepts/#single-resource-api">Kubernetes API verbs</a> を表します。個々の Pod のように、単一のオブジェクトに対して行われた操作では、get、 create、 apply、 update、 patch、 delete、 proxy といった verb が使用されます。<br>この情報から、オブジェクトの作成・削除といった、どのような操作が実行されたか判断できます。</p><p>この例では、<code>nginx</code> Pod の情報を取得したため <code>&quot;get&quot;</code> が記録されています。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;verb&quot;</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WHEN-いつ起こったのか？"><a href="#WHEN-いつ起こったのか？" class="headerlink" title="WHEN: いつ起こったのか？"></a>WHEN: いつ起こったのか？</h4><p>タイムスタンプの情報から、そのイベントがいつ起こったのかがわかります。</p><p><code>&quot;requestReceivedTimestamp&quot;</code>は、クライアントからのリクエストが API サーバーに到着した日時です。</p><p>監査ログは、API サーバーがリクエストを処理する<a href="https://kubernetes.io/docs/tasks/debug/debug-cluster/audit/">段階 (stage)</a> ごとに出力されます。<br>この例では、<code>&quot;stage&quot;</code>は<code>&quot;ResponseComplete&quot;</code>と記録されています。API サーバーがクライアントにレスポンスを転送し終わった際のログとなっており、<code>&quot;stageTimestamp&quot;</code>はレスポンスが完了した日時を表します。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;stage&quot;</span>: <span class="string">&quot;ResponseComplete&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;requestReceivedTimestamp&quot;</span>: <span class="string">&quot;2022-12-18T07:21:50.6437530Z&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;stageTimestamp&quot;</span>: <span class="string">&quot;2022-12-18T07:21:50.6480500Z&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WHO-誰がその操作を始めたのか？"><a href="#WHO-誰がその操作を始めたのか？" class="headerlink" title="WHO: 誰がその操作を始めたのか？"></a>WHO: 誰がその操作を始めたのか？</h4><p><code>&quot;user&quot;</code> の情報から、どのユーザーが行った操作であるか特定できます。<br>AKS では、<a href="https://learn.microsoft.com/ja-jp/Azure/aks/control-kubeconfig-access#available-cluster-roles-permissions"><code>az aks get-credentials</code> コマンドで取得した資格情報</a>を使ってクラスターを操作した場合に <code>&quot;user.username&quot;</code> が <code>&quot;masterclient&quot;</code> となります。</p><p><code>&quot;userAgent&quot;</code> にはリクエストを送信したクライアントの <a href="https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/User-Agent">User Agent</a> の情報が記録されます。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;user&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;masterclient&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;groups&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;system:masters&quot;</span>,</span><br><span class="line">      <span class="string">&quot;system:authenticated&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;userAgent&quot;</span>: <span class="string">&quot;kubectl/v1.26.0 (linux/amd64) kubernetes/b46a3f8&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>たとえば、<a href="https://learn.microsoft.com/ja-jp/azure/aks/kubernetes-portal?tabs=azure-cli">Azure Portal から AKS クラスター内のリソースにアクセス</a>した場合には、<code>&quot;userAgent&quot;</code> は次のように Web ブラウザーからのアクセスを示す文字列となります。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;userAgent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1462.54&quot;</span>,</span><br></pre></td></tr></table></figure><p>User Agent を調べることで、クラスター上にデプロイされているツールやコントローラーによる操作も特定できます。<br>次の例では、<a href="https://kubernetes.github.io/ingress-nginx/">NGINX Ingress Controller</a>のコントローラー Pod からリクエストされた操作であることがわかります。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;userAgent&quot;</span>: <span class="string">&quot;nginx-ingress-controller/v1.4.0 (linux/amd64) ingress-nginx/50be2bf95fd1ef480420e2aa1d6c5c7c138c95ea&quot;</span>,</span><br></pre></td></tr></table></figure><h4 id="WHERE-どこから操作をされたのか？"><a href="#WHERE-どこから操作をされたのか？" class="headerlink" title="WHERE: どこから操作をされたのか？"></a>WHERE: どこから操作をされたのか？</h4><p><code>&quot;sourceIPs&quot;</code> にはリクエスト元の IP アドレスが記録されます。IP アドレスを調べることによって、操作がどこから行われたのか特定できます。<br>(次の例では<a href="https://www.rfc-editor.org/rfc/rfc5737">例示用 IP アドレス</a>に置き換えています)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;sourceIPs&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;203.0.113.10&quot;</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WHAT-何に対する操作が行われたのか？"><a href="#WHAT-何に対する操作が行われたのか？" class="headerlink" title="WHAT: 何に対する操作が行われたのか？"></a>WHAT: 何に対する操作が行われたのか？</h4><p><code>&quot;requestURI&quot;</code> はクライアントから API サーバーに送信されたリクエスト URI を示します。</p><p><code>&quot;objectRef&quot;</code> (<a href="https://kubernetes.io/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-ObjectReference">Object Reference</a>) は、操作のターゲットとなったオブジェクトを表します。</p><p>次の例では、<code>&quot;default&quot;</code> ネームスペースに存在する <code>&quot;pods&quot;</code> リソースで、名前が <code>&quot;nginx&quot;</code> であるオブジェクトが操作対象であったことがわかります。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;requestURI&quot;</span>: <span class="string">&quot;/api/v1/namespaces/default/pods/nginx&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;objectRef&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;resource&quot;</span>: <span class="string">&quot;pods&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;namespace&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;nginx&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;apiVersion&quot;</span>: <span class="string">&quot;v1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="操作の結果はどうなったのか"><a href="#操作の結果はどうなったのか" class="headerlink" title="操作の結果はどうなったのか"></a>操作の結果はどうなったのか</h4><p><code>&quot;responseStatus&quot;</code> は、API サーバーがクライアントに返したレスポンス ステータスを表します。</p><p>次の例では、リクエスト対象の Pod がクラスターに存在し、Pod の情報を応答することが成功した (HTTP Status 200) ことがわかります。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;responseStatus&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="number">200</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>リクエストがエラーとなった場合には、エラーの内容を示すステータスが記録されます。<br>次の例では、存在しない Pod の情報を取得しようとしたために、HTTP Status 404 が返されたことがわかります。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;requestURI&quot;</span>: <span class="string">&quot;/api/v1/namespaces/default/pods/nginxxxxxx&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;responseStatus&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;Failure&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;NotFound&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="number">404</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="API-リクエストとレスポンスのオブジェクト内容"><a href="#API-リクエストとレスポンスのオブジェクト内容" class="headerlink" title="API リクエストとレスポンスのオブジェクト内容"></a>API リクエストとレスポンスのオブジェクト内容</h4><p><code>&quot;requestObject&quot;</code> には、クライアントから API サーバーに送信されたリクエストの内容が記録されています。Pod や Deployment といったオブジェクトを作成する際には、YAML 形式のマニフェスト ファイルに記載した内容が記録されます。監査ログ上では JSON 形式で記録されますが、フィールド名や値、オブジェクトの構造は YAML 形式の場合と同様です。<br>ノードや Pod などのステータスが更新された場合には、更新が必要な情報 (フィールド) のみを抜粋した patch リクエストが行われる場合もあります。</p><p>次の例は、Deployment を作成した際のログの抜粋です。<code>spec.replicas</code> に Pod のレプリカ数が指定されていることがわかります。Deployment オブジェクトはまだ作成されていない状態のため、作成日時のタイムスタンプは <code>null</code> です。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;requestObject&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;Deployment&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;apiVersion&quot;</span>: <span class="string">&quot;apps/v1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;azure-vote-back&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;namespace&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;creationTimestamp&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;spec&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;replicas&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&quot;responseObject&quot;</code> には、API サーバーからクライアントへ返されたレスポンスの内容が記録されています。</p><p>次の例は、Deployment の作成リクエストに対するレスポンスです。Deployment オブジェクトが作成されたため、作成日時のタイムスタンプ情報があり、オブジェクトの <code>&quot;uid&quot;</code> が割り当てられていることが確認できます。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;responseObject&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;Deployment&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;apiVersion&quot;</span>: <span class="string">&quot;apps/v1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;azure-vote-back&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;namespace&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;uid&quot;</span>: <span class="string">&quot;b5154018-c171-4155-8d95-2a1866a25a6b&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;resourceVersion&quot;</span>: <span class="string">&quot;144810978&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;generation&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;creationTimestamp&quot;</span>: <span class="string">&quot;2022-12-19T11:13:27.0000000Z&quot;</span>,</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このように、監査ログには、API サーバーにリクエストされた操作の内容やリクエストの発生元、そしてその結果となるレスポンスがどうなったのかについて情報が記録されています。</p><p>前述のとおり、クラスターに対する操作は、クラスターの利用者の操作、ツール / Kubernetes のコントローラーの自動化処理など、すべて API サーバーに対してリクエストが送信されます。<br>監査ログをみることで、どのような操作が行われたのかを追跡でき、過去にクラスターで何が起こったのかを手に取るように把握できます。</p><h2 id="AKS-クラスターの監査ログ出力を設定する"><a href="#AKS-クラスターの監査ログ出力を設定する" class="headerlink" title="AKS クラスターの監査ログ出力を設定する"></a>AKS クラスターの監査ログ出力を設定する</h2><p>監査ログの出力を有効化するには、kube-apiserver に対して設定が必要となります。<br>AKS はマネージドの Kubernetes サービスであるため、ご利用者様において kube-apiserver の設定を直接変更することはできませんが、AKS クラスター (managedCluster) リソースの<a href="https://learn.microsoft.com/ja-jp/azure/azure-monitor/essentials/resource-logs"><strong>診断設定</strong></a>を構成することで、Kubernetes の監査ログを Log Analytics ワークスペースやストレージ アカウントに送信できます。</p><blockquote><p><strong>AKS データの監視に関するリファレンス - リソース ログ</strong><br><a href="https://learn.microsoft.com/ja-jp/azure/aks/monitor-aks-reference#resource-logs">https://learn.microsoft.com/ja-jp/azure/aks/monitor-aks-reference#resource-logs</a></p></blockquote><p>Azure ポータルでは、対象となる AKS クラスターを開いたあと、左に表示されるメニューの <strong>[診断設定]</strong> の画面から設定できます。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit03.png" alt="ポータルの左メニューから[診断設定]を開きます"></p><p>診断設定の作成画面では、設定につける名前とログのカテゴリ、ログの転送先の選択をします。<br>次の例では、Kubernetes の監査ログを Log Analytics ワークスペースへ送信するように設定しています。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit04.png" alt="新しい診断設定を作成します"></p><p>監査ログに該当するカテゴリには、<strong>Kubernetes Audit</strong> と <strong>Kubernetes Audit Admin Logs</strong> の 2 つが存在します。それぞれ、次の違いがあります。</p><ul><li><strong>Kubernetes Audit (kube-audit)</strong><ul><li>get、list、create、update、delete、patch、post を含む、すべての監査イベントのログを出力します</li></ul></li><li><strong>Kubernetes Audit Admin Logs (kube-audit-admin)</strong><ul><li>Kubernetes Audit (kube-audit) カテゴリのログから、get および list の監査イベント (参照系のイベント) を除外したログを出力します</li></ul></li></ul><p>Kubernetes クラスターの動作は、さまざまなコントローラー (ソフトウェア) がリソース オブジェクトを操作することによって成り立っています。そのため、オブジェクトの get や list、watch といったリクエストが継続的に発生しています。<strong>Kubernetes Audit</strong> カテゴリは、コントローラーによる参照系リクエストもふくめ、すべてのイベントのログが出力されます。</p><p>一方、クラスターに対する変更系の操作のみを追跡したいというシナリオでは、get や list といった参照系のログは必要ないということがあります。その場合、<strong>Kubernetes Admit Admin Logs</strong> を選択することで、ログの数を大幅に削減でき、Log Analytics ワークスペースやストレージ アカウントの容量・料金の節約になります。</p><p>診断設定で出力できる AKS クラスターのリソース ログについては、次のドキュメントに一般的な推奨事項が記載されていますので、あわせてご参照ください。</p><blockquote><p><strong>Azure Monitor のコンテナー正常性機能を使用して Azure Kubernetes Service (AKS) を監視する - リソース ログを収集する</strong><br><a href="https://learn.microsoft.com/ja-jp/azure/aks/monitor-aks#collect-resource-logs">https://learn.microsoft.com/ja-jp/azure/aks/monitor-aks#collect-resource-logs</a><br>　<br>このドキュメントでは、kube-audit を Azure ストレージへ転送し、kube-audit-admin を Log Analytics ワークスペースへ転送する構成が紹介されています。</p></blockquote><h3 id="監査ログの取得方法"><a href="#監査ログの取得方法" class="headerlink" title="監査ログの取得方法"></a>監査ログの取得方法</h3><p>診断設定で Log Analytics ワークスペースへ送信したログは、Azure ポータルの <a href="https://portal.azure.com/#view/Microsoft_Azure_Monitoring/AzureMonitoringBrowseBlade/~/overview"><strong>[モニター]</strong></a> 画面から、<a href="https://learn.microsoft.com/ja-jp/azure/azure-monitor/logs/log-query-overview">Kusto クエリ</a>を実行することで取得できます。</p><p>左のメニューから <strong>[ログ]</strong> 画面へ移動し、ログの出力先の Log Analytics ワークスペースを選択して新しいクエリを実行します。</p><p>診断設定のログは <strong>AzureDiagnostics</strong> テーブルに格納されています。<br><code>Category</code> カラムの値が <code>kube-audit</code> となっているログを絞り込むことで、Kubernetes の監査ログが取得できます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AzureDiagnostics </span><br><span class="line">| where Category == &quot;kube-audit&quot;</span><br><span class="line">| take 10</span><br></pre></td></tr></table></figure><p>次のスクリーンショットは、クエリを実行してログを取得した画面です。<code>log_s</code> カラムに、Kubernetes の監査ログが JSON 形式で記録されています。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit05.png" alt="AzureDiagnostics テーブルで Category が &quot;kube-audit&quot; のログを取得します"></p><p><code>log_s</code> カラムの値を <a href="https://learn.microsoft.com/ja-jp/azure/data-explorer/kusto/query/parsejsonfunction">parse_json()</a> 関数で変換することで、監査ログ内部の値にアクセスしやすくなります。<br><a href="https://learn.microsoft.com/ja-jp/azure/data-explorer/kusto/query/extendoperator">extend 演算子</a>でログの項目ごとに新しい列を作成しておくと、クエリに検索条件を追加する際に便利です。また、必要な列のみに絞ってログを表示することが可能になります。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AzureDiagnostics </span><br><span class="line">| where Category == &quot;kube-audit&quot;</span><br><span class="line">| extend audit = parse_json(log_s)</span><br><span class="line">| extend Method = audit.verb</span><br><span class="line">| extend RequestURI = audit.requestURI</span><br><span class="line">| extend RequestObject = audit.requestObject</span><br><span class="line">| extend ResponseObject = audit.responseObject</span><br><span class="line">| extend ResponseStatusCode = audit.responseStatus.code</span><br><span class="line">| extend UserAgent = audit.userAgent</span><br><span class="line">| extend User = audit.user.username</span><br><span class="line">| project TimeGenerated, Method, ResponseStatusCode, RequestURI, User, UserAgent, RequestObject, ResponseObject</span><br><span class="line">| order by TimeGenerated asc</span><br></pre></td></tr></table></figure><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit06.png" alt="extend 演算子を使用したクエリ結果"></p><h2 id="クエリとログの例"><a href="#クエリとログの例" class="headerlink" title="クエリとログの例"></a>クエリとログの例</h2><p>ここまでの手順で、AKS クラスターの監査ログを Log Analytics ワークスペースへ転送し、クエリの実行でログ取得ができるようになりました。</p><p>ここでは 4 つのシナリオをもとに、監査ログの情報を取得する例を紹介します。</p><h3 id="シナリオ-1-アプリケーション-Pod-Deployment-の作成履歴を確認する"><a href="#シナリオ-1-アプリケーション-Pod-Deployment-の作成履歴を確認する" class="headerlink" title="シナリオ 1: アプリケーション (Pod/Deployment) の作成履歴を確認する"></a>シナリオ 1: アプリケーション (Pod/Deployment) の作成履歴を確認する</h3><p>AKS クラスターにアプリケーションをデプロイした際のログを見てみましょう。<a href="https://learn.microsoft.com/ja-jp/azure/aks/tutorial-kubernetes-deploy-application">AKS チュートリアル</a>で使用されている azure-vote アプリケーションをクラスターにデプロイし、Kubernetes の監査ログからDeployment の作成履歴を確認します。</p><p><code>kubectl</code> コマンドでアプリケーションの YAML マニフェストをクラスターに適用します。次のコマンド例では Deployment と Service が2つずつ作成されています。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f azure-vote-all-in-one-redis.yaml</span></span><br><span class="line">deployment.apps/azure-vote-back created</span><br><span class="line">service/azure-vote-back created</span><br><span class="line">deployment.apps/azure-vote-front created</span><br><span class="line">service/azure-vote-front created</span><br></pre></td></tr></table></figure><p>次のクエリ例では、監査ログ (<code>audit</code>) 内に <code>&quot;azure-vote&quot;</code> の文字列を含むログを抽出しています。<br>その他の条件として、create リクエスト (<code>Method</code>)、kubectl コマンドからのアクセス (<code>UserAgent</code>) を指定しています。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AzureDiagnostics </span><br><span class="line">| where Category == &quot;kube-audit&quot;</span><br><span class="line">| extend audit = parse_json(log_s)</span><br><span class="line">| extend Method = audit.verb</span><br><span class="line">| extend RequestURI = audit.requestURI</span><br><span class="line">| extend RequestObject = audit.requestObject</span><br><span class="line">| extend ResponseObject = audit.responseObject</span><br><span class="line">| extend ResponseStatusCode = audit.responseStatus.code</span><br><span class="line">| extend UserAgent = audit.userAgent</span><br><span class="line">| extend User = audit.user.username</span><br><span class="line">| where audit contains &quot;azure-vote&quot;     // 監査ログ内に &quot;azure-vote&quot; の文字列を含む</span><br><span class="line">| where Method == &quot;create&quot;              // create リクエスト</span><br><span class="line">| where UserAgent contains &quot;kubectl&quot;    // クライアントが kubectl のログ</span><br><span class="line">| project TimeGenerated, Method, ResponseStatusCode, RequestURI, User, UserAgent, RequestObject, ResponseObject</span><br><span class="line">| order by TimeGenerated asc</span><br></pre></td></tr></table></figure><p>クエリを実行すると、次のスクリーンショットのようにログが取得されました。ログの内容を表示された順に上から確認してみましょう。</p><p>まずは、 API サーバーに対して、<code>2022-12-19 11:13:27 (UTC)</code> に <code>/apis/apps/v1/namespace/default/deployments</code> のパスに <code>create</code> リクエストが送信されたことがわかります。</p><p><code>User</code> カラムの情報から、<code>az aks get-credentials</code> コマンドで取得した AKS クラスターの資格情報 (<code>masterclient</code>) が使用されていることがわかります。また、<code>UserAgent</code> カラムの情報から、<code>kubectl</code> コマンドによる操作が実行されたことがわかります。</p><p><code>RequestObject</code> には Deployment の YAML マニフェストの内容が記録されています。<code>spec</code> には Deployment の仕様が記録されており、Pod のレプリカ数 (<code>spec.replicas</code>) や Pod テンプレート (<code>spec.template</code>) の内容が含まれていることが確認できます。 </p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit07.png" alt="Deployment オブジェクトの作成ログ"></p><p>Kubernetes では、Deployment オブジェクトが作成・更新されると、その内容をもとに ReplicaSet オブジェクトが作成されます。そして、指定されたレプリカの数だけ Pod オブジェクトが作成されます。この動作は、Kubernetes クラスターを構成するコントローラーによって自動的に行われます。</p><p>上記のクエリ例では、人によって開始された Deployment 作成のログを確認しましたが、コントローラーによる自動処理についても Kubernetes の監査ログから確認できます。<br>作成した Deployment から最終的に Pod が起動するまでの様子を、実際に監査ログから追ってみましょう。ここでは、ReplicaSet が作成される箇所は割愛し、最終的に Pod が作成される様子を紹介します。</p><p>先ほど使用したクエリの条件 (kubectl によるリクエスト) を削除して、ログ内に <code>&quot;azure-vote&quot;</code> の文字列を含む create リクエストのすべてを検索します。すると、<code>/api/v1/namespaces/default/pods</code> パスに対する create リクエストが確認できます。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit08.png" alt="Pod オブジェクトの作成ログ"></p><p><code>User</code> および <code>UserAgent</code> から、<a href="https://kubernetes.io/ja/docs/concepts/overview/components/#kube-controller-manager">kube-controller-manager</a> 内の ReplicaSet Controller によって、Pod の作成がリクエストされたことがわかります。</p><p>Deployment の場合と同様に、<code>ResponseObject</code> には Pod のデプロイ内容が記録されています。<code>metadata.name</code> の情報から、<code>azure-vote-back-59d587dbb7-pjkxr</code> という名前で Pod が作成されたことがわかります。<br>また、<code>status.phase</code> が <code>Pending</code> となっています。この時点では Pod がノードにスケジューリングされておらず、ステータスが <code>Pending</code> の状態であったことがわかります。</p><p>Pod の名前が特定できました。この Pod 名を <code>RequestURI</code> に含むログを検索してみましょう。クエリを実行すると、次のリクエストのログが表示されました。</p><ul><li><code>create /api/v1/namespaces/default/pods/azure-vote-back-59d587dbb7-pjkxr/binding</code> <strong>(binding)</strong></li><li><code>patch /api/v1/namespaces/default/pods/azure-vote-back-59d587dbb7-pjkxr/status</code> <strong>(status)</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| where RequestURI contains &quot;azure-vote-back-59d587dbb7-pjkxr&quot;  // Pod 名を指定</span><br></pre></td></tr></table></figure><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit09.png" alt="ノードの割り当てと Pod ステータスが更新された際のログ"></p><p><code>RequestURI</code> の末尾が <code>/binding</code> のログは、Pod がノードにスケジューリングされた際のリクエストです。<code>UserAgent</code> から kube-scheduler によるリクエストであることが確認できます。<br>また、<code>RequestObject.target</code> の情報から、Pod がノード <code>aks-nodepool2-20356098-vmss000001</code> に割り当てられたことがわかります。</p><p><code>RequestURI</code> の末尾が <code>/status</code> のログは、Pod のステータス情報が更新された際のリクエストです。<code>User</code> と <code>UserAgent</code> から、Pod がスケジューリングされたノード <code>aks-nodepool2-20356098-vmss000001</code> の kubelet から送信されたことが確認できます。</p><p>ノード上の kubelet は、コンテナー ランタイムにコンテナーの起動を指示し、その結果を API サーバーに送信する役割を持っています。コンテナーの状態にあわせて Pod のステータスを更新しています (<code>Method</code> も <code>create</code> ではなく <code>patch</code> となっています)。</p><p><code>RequestObject</code> の <code>status</code> の情報が、kubelet から報告された Pod の状態になります。<code>status.phase</code> より、Pod が <code>Running</code> ステータスになったことがわかります。また、Pod に割り当てられた IP アドレスの情報も確認できます。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p>create リクエストでは、作成するオブジェクトがまだ存在しないため、<code>RequestURI</code> にはオブジェクト名が含まれません。たとえば、Pod の作成では <code>/api/v1/namespaces/default/pods</code> に対して create リクエストが送信され、Pod 名などの情報は <code>RequestObject</code> に含まれています。</p><p>　</p><p>オブジェクトが作成された後は、オブジェクト名を含む <code>RequestURI</code> で操作されます。たとえば、特定の Pod の削除操作では、対象となる Pod を表す <code>/api/v1/namespaces/default/pods/azure-vote-back-59d587dbb7-pjkxr</code> に対して delete リクエストが送信されます。</p><p>　</p><p>クエリの作りこみをする際には、上述のクエリ例 (<code>where audit contains &quot;azure-vote&quot;</code>) のように、監査ログ全体を絞り込みの条件にして、必要な情報がどのフィールドに存在するかを確認するとよいです。ReplicaSet によって作成された Pod のように、名前にランダムな文字列が含まれる場合もログの特定がしやすくなります。</p></div><h3 id="シナリオ-2-Pod-のステータスとノードへのスケジューリング履歴を確認"><a href="#シナリオ-2-Pod-のステータスとノードへのスケジューリング履歴を確認" class="headerlink" title="シナリオ 2: Pod のステータスとノードへのスケジューリング履歴を確認"></a>シナリオ 2: Pod のステータスとノードへのスケジューリング履歴を確認</h3><p>新しく作成された Pod が <code>Pending</code> ステータスとなり、起動しない場合があります。</p><blockquote><p>コンピュート リソースの不足によって発生する Pod の Pending ステータスについては、こちらのブログ記事もご参照ください。<br>　<br><strong>Japan Azure IaaS Core Support Blog - AKSのメモリ関連トラブルシューティング</strong><br><a href="https://jpaztech.github.io/blog/containers/aks-memory-troubleshoot/">https://jpaztech.github.io/blog/containers/aks-memory-troubleshoot/</a></p></blockquote><p>次の例では、Pod が要求する CPU リソースが、現在クラスターに存在する空きノードで提供できないために、Pod が <code>Pending</code> ステータスとなっています。<br>また、<a href="https://learn.microsoft.com/ja-jp/azure/aks/cluster-autoscaler">クラスター オートスケーラー</a>が <code>Pending</code> ステータスの Pod が存在することを検知し、ノードプールのスケール アップを実行したイベントが確認できます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -l app=azure-vote-front</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">azure-vote-front-7655fcc46d-jm5sh   0/1     Pending   0          2s</span><br><span class="line">azure-vote-front-7655fcc46d-wtfph   1/1     Running   0          31s</span><br><span class="line">azure-vote-front-7655fcc46d-zqvbc   0/1     Pending   0          2s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod azure-vote-front-7655fcc46d-jm5sh</span></span><br><span class="line">  ...</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age   From                Message</span><br><span class="line">  ----     ------            ----  ----                -------</span><br><span class="line">  Warning  FailedScheduling  35s   default-scheduler   0/2 nodes are available: 2 Insufficient cpu.</span><br><span class="line">  Normal   TriggeredScaleUp  28s   cluster-autoscaler  pod triggered scale-up: [&#123;aks-nodepool2-20356098-vmss 2-&gt;4 (max: 5)&#125;]</span><br></pre></td></tr></table></figure><p>このときの Pod のステータスの変化と、ノードの追加のイベントを、監査ログから確認してみましょう。</p><p><code>RequestURI</code> に対象の Pod 名を含むログを検索します。ステータス情報が更新されたイベントを抽出するために、<code>Method</code> が get 以外のログを取得します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AzureDiagnostics </span><br><span class="line">| where Category == &quot;kube-audit&quot;</span><br><span class="line">| extend audit = parse_json(log_s)</span><br><span class="line">| extend Method = audit.verb</span><br><span class="line">| extend RequestURI = audit.requestURI</span><br><span class="line">| extend RequestObject = audit.requestObject</span><br><span class="line">| extend ResponseStatusCode = audit.responseStatus.code</span><br><span class="line">| extend UserAgent = audit.userAgent</span><br><span class="line">| where Method != &quot;get&quot;</span><br><span class="line">| where RequestURI contains &quot;/api/v1/namespaces/default/pods/azure-vote-front-7655fcc46d-jm5sh&quot;</span><br><span class="line">| project TimeGenerated, RequestObject, Method, ResponseStatusCode, RequestURI, UserAgent</span><br><span class="line">| order by TimeGenerated asc</span><br></pre></td></tr></table></figure><p>ログを検索した結果、kube-scheduler によって Pod のステータス情報が更新されたログが見つかりました (URI 末尾が <code>/status</code>) 。<br><code>RequestObject.status.conditions[0]</code> に Pod の状態を表す情報が記録されています。<code>Unschedulable</code> のメッセージが確認でき、<code>message</code> から CPU リソースの不足が理由であることがわかります。このメッセージは <code>kubectl describe pod</code> コマンドで確認できるものと同様の内容です。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit10.png" alt="CPU リソースの不足により Pod がスケジューリングされていない状態のログ"></p><p>そのあとの時間に、Pod がノードに割り当てられたログが確認できました (URI 末尾が <code>/binding</code>) 。<code>ResponseObject.target</code> から、Pod のデプロイ先がノード <code>aks-nodepool2-20356098-vmss000005</code> になったことがわかります。クラスター オートスケーラーによって新しい空きノードが追加され、Pod がデプロイできるようになりました。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit11.png" alt="新規に追加されたノードへ Pod がスケジューリングされた際のログ"></p><p>クラスターにノードが追加された際のログをみてみましょう。<code>kubectl get nodes</code> コマンドで取得できるノードの情報は、Node オブジェクトとして管理されています。<code>/api/v1/nodes</code> に送信された create リクエストのログを検索します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AzureDiagnostics </span><br><span class="line">| where Category == &quot;kube-audit&quot;</span><br><span class="line">| extend audit = parse_json(log_s)</span><br><span class="line">| extend Method = audit.verb</span><br><span class="line">| extend RequestURI = audit.requestURI</span><br><span class="line">| extend RequestObject = audit.requestObject</span><br><span class="line">| extend ResponseStatusCode = audit.responseStatus.code</span><br><span class="line">| extend UserAgent = audit.userAgent</span><br><span class="line">| extend User = audit.user.username</span><br><span class="line">| where Method == &quot;create&quot;</span><br><span class="line">| where RequestURI contains &quot;/api/v1/nodes&quot;</span><br><span class="line">| project TimeGenerated, RequestObject, Method, ResponseStatusCode, RequestURI, User, UserAgent</span><br><span class="line">| order by TimeGenerated asc</span><br></pre></td></tr></table></figure><p>Node オブジェクトの作成ログが取得できました。<code>User</code> および <code>UserAgent</code> から、<code>aks-nodepool2-20356098-vmss000005</code> ノードの kubelet からリクエストが送信されたことがわかります。<br>新しいノード (VM) が作成され、kubelet が動作を開始すると、API サーバーにノードの情報が登録されます。<code>ResponseObject</code> の <code>spec</code> や <code>status</code> から、ノードの情報やステータスが取得できます。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit12.png" alt="新規 Node が作成された際のログ"></p><div class="alert is-success"><p class="alert-title">ヒント</p><p>クラスター オートスケーラーのログは、監査ログと同様に AKS クラスターの診断設定で <strong>Kubernetes Cluster Autoscaler (cluster-autoscaler)</strong> を出力することで、お客様にてご確認いただけます。</p><p>オートスケールによってノードが意図した通りに追加・削除されなかった際に、クラスター オートスケーラーがどのような判断をしたのかや、VMSS インスタンスの操作リクエストが失敗していないかについて、ログから確認できます。</p></div><h3 id="シナリオ-3-Node-のステータス履歴を確認"><a href="#シナリオ-3-Node-のステータス履歴を確認" class="headerlink" title="シナリオ 3: Node のステータス履歴を確認"></a>シナリオ 3: Node のステータス履歴を確認</h3><p>ノードが新規に作成されると、はじめは <code>NotReady</code> ステータスの状態でクラスターに登録されます。その後 Pod を起動する準備が完了すると <code>Ready</code> ステータスへ変化します。<br>上記例 2 のシナリオで新しいノードが作成された際のログから、ノードのステータス情報が変化した様子を確認してみましょう。</p><p><code>RequestURI</code> に文字列 <code>&quot;/api/v1/nodes&quot;</code> を含み、かつ <code>&quot;/status&quot;</code> で終わるという条件をクエリに追加します。<code>Method</code> には patch を指定しています。</p><p>ノードのステータス情報は <code>ResponseObject.status.conditions</code> の配列に含まれています。扱いやすいように <a href="https://learn.microsoft.com/ja-jp/azure/data-explorer/kusto/query/mvexpandoperator">mv-expand 演算子</a>で配列の値を複数のレコードに展開します。ノードが Ready であるかどうかを表す情報は、<code>conditions.type</code> が <code>Ready</code> のものが該当します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AzureDiagnostics </span><br><span class="line">| where Category == &quot;kube-audit&quot;</span><br><span class="line">| extend audit = parse_json(log_s)</span><br><span class="line">| extend Method = audit.verb</span><br><span class="line">| extend RequestURI = audit.requestURI</span><br><span class="line">| extend ResponseObject = audit.responseObject</span><br><span class="line">| extend UserAgent = audit.userAgent</span><br><span class="line">| where RequestURI contains &quot;/api/v1/nodes&quot; and RequestURI endswith &quot;/status&quot;</span><br><span class="line">| where Method == &quot;patch&quot;</span><br><span class="line">| mv-expand conditions = ResponseObject.status.conditions   // conditions 配列の値を複数のレコードに展開</span><br><span class="line">| where conditions.type == &quot;Ready&quot;                          // type が &quot;Ready&quot; のログを取得</span><br><span class="line">| project TimeGenerated, conditions.type, conditions.status, conditions.reason, conditions.message, RequestURI, UserAgent</span><br><span class="line">| order by TimeGenerated asc</span><br></pre></td></tr></table></figure><p>クエリを実行すると、次の例のようにログが取得できます。<br>少々わかりにくいですが、<code>conditions_status</code> が <code>False</code> となっている場合は、ノードが <code>Ready</code> <strong>ではない</strong> ことを示しています (<code>NotReady</code> ステータス) 。</p><p>そのあとの時間に <code>conditions_status</code> が <code>True</code> へと変化しています (ノードが <code>Ready</code> ステータスになった)。また、<code>kubelet is posting ready status.</code> のメッセージから、kubelet から API サーバーにノードが正常であるという情報が報告されたことがわかります。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit13.png" alt="ノードのステータスが更新された際のログ"></p><div class="alert is-success"><p class="alert-title">ヒント</p><p><a href="https://learn.microsoft.com/ja-jp/azure/azure-monitor/containers/container-insights-overview">Container Insights</a> を利用にすることで、Azure Monitor で<a href="https://learn.microsoft.com/ja-jp/azure/azure-monitor/containers/container-insights-livedata-metrics#node-count">ノードのステータス情報をメトリックとして取得</a>できます。</p><p>監査ログではクラスターのさまざまな情報が取得可能ですが、Pod や Node のステータス変化をモニタリングする目的では、クエリの作成やログ データの管理が不要なため、Container Insights で用意されたメトリックを利用することをおすすめします。メトリックから、ステータス変化が発生した事実・発生日時を把握し、具体的な理由や関連するクラスター上のイベントを調査する目的で、監査ログを併用すると良いでしょう。</p></div><h3 id="シナリオ-4-Pod-再起動のなぞを追え！"><a href="#シナリオ-4-Pod-再起動のなぞを追え！" class="headerlink" title="シナリオ 4: Pod 再起動のなぞを追え！"></a>シナリオ 4: Pod 再起動のなぞを追え！</h3><blockquote><p><strong>[Contoso 社のストーリー]</strong><br><a href="https://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%B3%E3%83%88%E3%82%BD">Contoso 社</a>では先月、AKS を使って期待の新サービスをリリースしました。年明けにはイベント開催も控えており、2022年も終わりをむかえるこの12月も、開発は鋭意進行中です。今のところ目立った問題は起きておらず、安定して稼働をしているようです。今日の AKS の調子はどうかな？<br>　<br>ところが今日、開発のエンジニアより「最近 Pod が突然再起動するようになった」との報告を受けました。リリース作業などのクラスター操作はしていないのにもかかわらず、Pod が再起動 (再作成) されるとのことです。事象は平日の夜に起こることが多く、再作成された Pod の情報から、直近では <code>2022/12/21 21:47:39 (JST)</code> 頃に起きたようです。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod azure-vote-front-7655fcc46d-zp9v7</span></span><br><span class="line">  ...</span><br><span class="line">Start Time:       Wed, 21 Dec 2022 21:47:39 +0900</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>同じノードの Pod が一斉に再起動するため、開発のエンジニアはノードの調子が悪いのではないかと心配しています。事象は開発環境で発生したため、現時点でサービス影響は出ていないですが、今後の開発やサービス提供のために原因を突き止めたいとのことでした。<br>　<br>さてどうしましょう？ こんなこともあろうかと、監査ログの出力を有効にしていたのでした！</p></blockquote><p>Contoso 社では開発に kubectl と <a href="https://helm.sh/ja/">Helm</a> を使っています。事象の発生時間帯を調べると、これらのツールによる Pod 操作は見つからず、たしかにクラスター利用者の操作は無いようでした。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| where TimeGenerated between(datetime(2022/12/21 12:00:00) .. 1h)  // 21:00 - 22:00 (JST) のログを検索。クエリ上では UTC 表記</span><br><span class="line">| where RequestURI contains &quot;/api/v1/namespaces/default/pods&quot;       // default ネームスペースの Pod 操作に絞り込み</span><br><span class="line">| where Method !in (&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;)                         // 参照系リクエストは除く</span><br><span class="line">| where UserAgent contains &quot;kubectl&quot; or UserAgent contains &quot;helm&quot;   // kubectl もしくは helm による操作に絞り込み</span><br></pre></td></tr></table></figure><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit14.png" alt="kubectl や Helm による操作は見つからない"></p><p>Pod の delete リクエストのログを検索します。すると、事象の時間帯に複数の Pod が削除されていることがわかりました。<br>Pod が存在していたノードは <code>ResponseObject.spec.nodeName</code> から確認できます。ノード名がすべて <code>aks-nodepool2-20356098-vmss000001</code> となっており、同じノードの Pod が再起動するという開発エンジニアの証言とも一致します。<br><code>UserAgent</code> が kubelet と kube-controller-manager となっていることから、何らかの理由により Kubernetes 側から Pod の削除がリクエストされたと推察されます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| where TimeGenerated between(datetime(2022/12/21 12:00:00) .. 1h)</span><br><span class="line">| where RequestURI contains &quot;pods&quot;</span><br><span class="line">| where Method == &quot;delete&quot;</span><br><span class="line">| project TimeGenerated, Method, ResponseStatusCode, RequestURI, UserAgent, ResponseObject.spec.nodeName</span><br></pre></td></tr></table></figure><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit15.png" alt="ノード aks-nodepool2-20356098-vmss000001 の Pod が delete されている"></p><p>ノード <code>aks-nodepool2-20356098-vmss000001</code> に何が起きたのか手がかりを探します。このノードに関するリクエストを調べると、ノードに対して <code>unschedulable</code>フラグを設定・解除しているリクエストが見つかりました。<code>UserAgent</code> は <code>kured/v0.0.0</code> になっています。<code>unschedulable</code> は対象のノードへの Pod のスケジューリングを無効化する際に利用される設定値です (<code>kubectl cordon / uncordon</code> コマンドの操作に該当します)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| where TimeGenerated between(datetime(2022/12/21 12:00:00) .. 1h)</span><br><span class="line">| where RequestURI == &quot;/api/v1/nodes/aks-nodepool2-20356098-vmss000001&quot;</span><br><span class="line">| where Method !in (&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;)</span><br><span class="line">| where RequestObject != &quot;&#123;&#125;&quot; and RequestObject != &quot;skipped-too-big-size-object&quot;  // RequestObject が空、もしくは省略された場合 (後述) を除外</span><br></pre></td></tr></table></figure><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit16.png" alt="kured によってノードの unschedulable フラグが設定・解除されている"></p><p><code>UserAgent</code> に <code>kured/v0.0.0</code> を含むログを検索してみます。すると、今回削除された Pod に対して退避のリクエストを送っていることがわかりました (URI 末尾が <code>/evictions</code>) 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| where TimeGenerated between(datetime(2022/12/21 12:00:00) .. 1h)</span><br><span class="line">| where UserAgent contains &quot;kured/v0.0.0&quot;</span><br><span class="line">| where Method !in (&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;)</span><br></pre></td></tr></table></figure><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit17.png" alt="Kured によって Pod の eviction がリクエストされている"></p><p><a href="https://github.com/kubereboot/kured">Kured</a> はオープンソースのツールです。Linux OS のパッケージ アップデートの状態を確認し、アップデートの反映のために OS の再起動が必要となった場合に、自動的に OS を再起動します。</p><blockquote><p><strong>kured を使用した Linux ノードの再起動の処理 - Azure Kubernetes Service - Microsoft Learn</strong><br><a href="https://learn.microsoft.com/ja-JP/azure/aks/node-updates-kured">https://learn.microsoft.com/ja-JP/azure/aks/node-updates-kured</a></p></blockquote><p>Kured はノードを再起動する前に、対象ノードへの Pod スケジューリングを停止し、稼働中の Pod を別のノードへ退避させます (<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#drain">ノードのドレイン</a>)。今回発生した事象は、Kured によるノードの自動再起動が実施され、Pod の停止と別ノードでの再作成が発生したためであると判断できそうです。<br>(正確な判断には、Kured 自体が出力した動作ログをあわせて確認するのがよいでしょう)</p><p>Kured はいつクラスターにインストールされたのでしょうか？ 直近 1 週間でログを検索すると、関連するとみられるリソースが <code>kured</code> ネームスペースに作成されていることがわかりました。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| where TimeGenerated &gt;= ago(7d)</span><br><span class="line">| where audit contains &quot;kured&quot;</span><br><span class="line">| where Method !in (&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;)</span><br></pre></td></tr></table></figure><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit18.png" alt="Kured 関連リソースの作成リクエスト"></p><p>Kured は DaemonSet を利用して各ノードへ配置されます。作成された DaemonSet の内容を確認してみます。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit19.png" alt="DaemonSet の作成リクエスト"></p><p>コンテナー内で実行される <code>kured</code> コマンドにいくつかのオプションが渡されています (<code>spec.template.spec.containers[0].args</code>)。<code>--start-time=9pm</code> と<a href="https://kured.dev/docs/configuration/#setting-a-schedule">時間が指定</a>されており、この時間以降でノードの再起動が開始される設定になっていました。Pod 再起動の事象が、夜の時間帯に発生するという証言の裏付けが取れました。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;DaemonSet&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;apiVersion&quot;</span>: <span class="string">&quot;apps/v1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;my-release-kured&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;namespace&quot;</span>: <span class="string">&quot;kured&quot;</span>,</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;spec&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;template&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;spec&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;containers&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;kured&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;image&quot;</span>: <span class="string">&quot;ghcr.io/kubereboot/kured:1.12.0&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: [</span><br><span class="line">              <span class="string">&quot;/usr/bin/kured&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">              <span class="string">&quot;--ds-name=my-release-kured&quot;</span>,</span><br><span class="line">              <span class="string">&quot;--ds-namespace=kured&quot;</span>,</span><br><span class="line">              <span class="string">&quot;--reboot-command=/bin/systemctl reboot&quot;</span>,</span><br><span class="line">              <span class="string">&quot;--start-time=9pm&quot;</span>,         <span class="comment">// 夜9時以降にノード再起動を開始 (タイムウィンドウの設定)</span></span><br><span class="line">              <span class="string">&quot;--time-zone=Asia/Tokyo&quot;</span>,   <span class="comment">// タイムゾーン</span></span><br><span class="line">              <span class="string">&quot;--log-format=text&quot;</span></span><br><span class="line">            ],</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>[Contoso 社のストーリー - 後日談]</strong><br>後日、チームメンバーにヒアリングをしたところ、クラスター運用の効率化のために、<a href="https://learn.microsoft.com/ja-JP/azure/aks/node-updates-kured">AKS ドキュメントで紹介されていた Kured</a> の検証を行っていたことがわかりました。Pod 再起動の理由が解明でき、ノードの不調ではないことがわかったことで、開発のエンジニアも安心したようでした。<br>その後、Contoso 社ではクラスターの運用方法について検討が行われ、AKS のマネージド機能である<a href="https://learn.microsoft.com/ja-jp/azure/aks/auto-upgrade-cluster">自動アップグレード</a>や、<a href="https://learn.microsoft.com/ja-jp/azure/aks/planned-maintenance">計画メンテナンス機能</a> についても試してみることになりました。</p></blockquote><div class="alert is-success"><p class="alert-title">ヒント</p><p>ノードプールに VMSS を利用しているクラスターでは、ノードを最新状態にするために、<a href="https://learn.microsoft.com/ja-JP/azure/aks/node-image-upgrade">ノードイメージのアップグレード</a>が利用可能です。</p><p>スケール操作によって新規追加されたノードは、使用されているノードイメージをもとにインスタンスが起動します。そのため、古いバージョンのノードイメージが使用されている場合、日次で実行されるパッケージ アップデートまでの間は、ノードが最新状態ではない可能性がある点に留意しましょう。</p><p>VMSS を利用しているクラスターでは、定期的にノードイメージのアップグレード作業を実施する、もしくは自動アップグレード機能を利用することをおすすめします。</p><p>以前の AKS の既定である、ノードに可用性セットを使用するクラスターでは、ノードイメージが利用できないため、運用の自動化と OS を最新状態へ維持するために、Kured の利用が手段の 1 つとして挙げられます。</p></div><h3 id="注意点-RequestObject-ResponseObject-のサイズ制限"><a href="#注意点-RequestObject-ResponseObject-のサイズ制限" class="headerlink" title="注意点: RequestObject / ResponseObject のサイズ制限"></a>注意点: RequestObject / ResponseObject のサイズ制限</h3><p><code>RequestObject</code> および <code>ResponseObject</code> カラムは、値が Log Analytics カラムのサイズ上限に達している場合に記録されません。</p><blockquote><p><strong>Azure/AKS - Release 2022-08-14</strong><br>Remove responseObject from kube-audit logs when its size is reaching log analytics column size limit (32K) and customer enables kube-audit/kube-audit-admin diagnostics.<br><a href="https://github.com/Azure/AKS/releases/tag/2022-08-14">https://github.com/Azure/AKS/releases/tag/2022-08-14</a></p></blockquote><p>サイズ上限に達した場合は <code>&quot;skipped-too-big-size-object&quot;</code> というメッセージに置き換えられます。監査ログによる調査やクエリの作成時には、<code>RequestObject</code> と <code>ResponseObject</code> の情報が取得できない場合があることに注意しましょう。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit20.png" alt="サイズ上限に達したログの例"></p><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>本記事では、Kubernetes の監査ログの紹介と、AKS・Azure Monitor で実際にログ情報を利用する様子を紹介しました。監査ログを活用することで、過去にクラスターで発生した操作やオブジェクトの変更履歴を調べることができます。我々サポート エンジニアも AKS クラスターの調査をする際に、Kusto のクエリを利用して Kubernetes や AKS 基盤のさまざまなログを調査しています。</p><p>監査ログを活用するために、Request / Response Object の構造や、ある操作をしたときに何の API リクエストが送信されるのかについて把握していると役立ちます。Kubernetes API のリファレンスが参考になります。</p><blockquote><p><strong>Kubernetes Documentation / Reference / Kubernetes API</strong><br><a href="https://kubernetes.io/docs/reference/kubernetes-api/">https://kubernetes.io/docs/reference/kubernetes-api/</a></p></blockquote><p>また、kubectl コマンドのデバッグ出力 (<code>kubectl --v=8</code>) を有効にすると、API サーバーへのリクエスト内容が確認できるため、ログと照らし合わせて動作を確認するのに便利です。ログ出力を有効にして、クラスターを操作しながら実際にどのようなログが出力されるか試してみるとわかりやすいです。監査ログをみることで、トラブルシューティングだけではなく、Kubernetes クラスターがどのように動作をしているのか、理解をより深めることができるでしょう。</p><p>今回紹介しました監査ログが、AKS をよりご活用いただくうえでのご参考になりましたら幸いです。また、AKS のご利用において、お困りの点やご不明点がありました際は、いつでも Azure サポートまでお気兼ねなくご相談ください。</p><h2 id="参考リンク"><a href="#参考リンク" class="headerlink" title="参考リンク"></a>参考リンク</h2><ul><li>Kubernetes に Audit log を求めるのは間違っているだろうか？<ul><li>@makocchi さんによる CloudNative Days 2019 / OpenStack Days 2019 (コンテナー / クラウド ネイティブに関する国内カンファレンス) の発表資料</li><li><a href="https://speakerdeck.com/makocchi/cndt2019-kubernetes-audit-log-c4d4c5f6-6058-40f9-a5fc-abbb36073a19">https://speakerdeck.com/makocchi/cndt2019-kubernetes-audit-log-c4d4c5f6-6058-40f9-a5fc-abbb36073a19</a></li></ul></li></ul><hr><p>最後まで読んでいただきありがとうございました！<br><a href="https://qiita.com/advent-calendar/2022/microsoft-azure-tech">Microsoft Azure Tech Advent Calendar 2022</a> は明日が最終日となります。是非ご覧くださいー！</p><p>本年は多くのお客様にお世話になりました。ありがとうございました。<br>来年もみなさまにとって素晴らしい年でありますように、心よりお祈り申し上げます。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;この記事は &lt;a href=&quot;https://qiita.com/advent-calendar/2022/microsoft-azure-tech&quot;&gt;Microsoft Azure Tech Advent Calendar 2022&lt;/a&gt; の 24 日目の記事になります🎅&lt;/p&gt;
&lt;p&gt;こんにちは。Azure テクニカル サポートチームの桐井です。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://learn.microsoft.com/ja-jp/azure/aks/intro-kubernetes&quot;&gt;Azure Kubernetes Service (AKS)&lt;/a&gt; のクラスターを利用しているときに、アプリケーションがデプロイされたタイミングや、ノードのステータスがいつどのような理由で変わったのかなど、過去にクラスターで起こったイベントの履歴を確認したい場合があります。Kubernetes の監査ログを活用すると、これらのイベントをログから確認できるようになります。&lt;/p&gt;
&lt;p&gt;本記事では、Kubernetes の監査ログの紹介と、AKS において監査ログ利用する方法を、実例を交えて解説します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Containers" scheme="https://jpaztech.github.io/blog/tags/Containers/"/>
    
    <category term="Azure Kubernetes Service (AKS)" scheme="https://jpaztech.github.io/blog/tags/Azure-Kubernetes-Service-AKS/"/>
    
  </entry>
  
  <entry>
    <title>AKS で利用可能なオートスケールについて</title>
    <link href="https://jpaztech.github.io/blog/containers/aks-autoscaling/"/>
    <id>https://jpaztech.github.io/blog/containers/aks-autoscaling/</id>
    <published>2022-12-24T03:00:00.000Z</published>
    <updated>2023-01-10T02:14:50.316Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは！ Azure テクニカル サポート チームの川畑です。</p><p>Kubernetes を利用するにあたり、負荷に応じてワークロードを動的に増減させるオートスケーリングの構成を取ることがあります。</p><p>この記事では、 Azure Kubernetes Service (AKS) を利用している環境を想定し、Pod およびノードのオートスケーリングの設定と動作についてご紹介します。</p><span id="more"></span><hr><h2 id="スケーリングとは？水平オートスケーラー-HPA"><a href="#スケーリングとは？水平オートスケーラー-HPA" class="headerlink" title="スケーリングとは？水平オートスケーラー (HPA)"></a>スケーリングとは？水平オートスケーラー (HPA)</h2><p>スケーリングには、スケールアップ / スケールダウンとスケールアウト / スケール インの 2 種類があります。</p><p>スケールアップは、垂直スケールとも呼ばれ、1 台あたりのコンピュート リソースを増やすことでシステムの性能を上げる手段となります。<br>AKS では、AKS ノードとして利用している Azure 仮想マシンのサイズ (vCPU 数) を増やす、Pod に割り当てるリソース量を増やすなど、ノードや Podのコンピュート リソースを増やす方法が挙げられます。</p><p>次に、スケールアウトは、水平スケールとも呼ばれ、コンピュート リソースは変えず、ノードの数や Pod のレプリカ数を増やすことでシステムの性能を上げる手段となります。</p><p>これらのスケーリングの操作は、クラスターの利用者によって手動で実施される場合と、オートスケールの機能によって自動で実施される場合があります。<br>表でまとめると次のような形となります。</p><table><thead><tr><th></th><th>自動/手動</th><th>水平/垂直</th><th>Pod/ノード</th></tr></thead><tbody><tr><td><a href="https://learn.microsoft.com/ja-jp/azure/aks/concepts-scale#horizontal-pod-autoscaler">水平オートスケーラー (HPA)</a></td><td>自動</td><td>水平</td><td>Pod</td></tr><tr><td><a href="https://learn.microsoft.com/ja-jp/azure/aks/cluster-autoscaler">クラスター オートスケーラー</a></td><td>自動</td><td>水平</td><td>ノード</td></tr><tr><td><a href="https://learn.microsoft.com/ja-JP/azure/aks/keda-about">KEDA</a> *1</td><td>自動</td><td>水平</td><td>Pod</td></tr><tr><td><a href="https://learn.microsoft.com/ja-jp/azure/aks/vertical-pod-autoscaler">垂直オートスケーラー (VPA)</a> *1</td><td>自動</td><td>垂直</td><td>Pod</td></tr><tr><td>レプリカ数の定義変更</td><td>手動</td><td>水平</td><td>Pod</td></tr><tr><td><a href="https://learn.microsoft.com/ja-jp/azure/aks/scale-cluster?tabs=azure-cli">Azure CLI (az aks acale) / Azure Portal</a></td><td>手動</td><td>水平</td><td>ノード</td></tr><tr><td><a href="https://learn.microsoft.com/ja-jp/azure/aks/resize-node-pool?tabs=azure-cli">ノード プールのサイズ変更</a> *2</td><td>手動</td><td>垂直</td><td>ノード</td></tr></tbody></table><p>*1 2022.12.24 時点ではプレビューの機能です。<br>*2 ドキュメントのタイトルは「変更」となっていますが、新しいサイズでノードプールを作成・削除する手順となります。</p><p>今回はこれらの方法のうち、自動でスケーリング可能な水平オートスケーラー (HPA) とクラスター オートスケーラーについて紹介します。</p><h2 id="Pod-のオートスケーリング-HPA"><a href="#Pod-のオートスケーリング-HPA" class="headerlink" title="Pod のオートスケーリング (HPA)"></a>Pod のオートスケーリング (HPA)</h2><p>AKS では、Pod のレプリカ数を負荷に応じてスケーリングする Pod の水平オートスケーラー (HPA) が使用できます。<br>HPA は、Kubernetes の標準 API リソースであり、AKS 固有の機能ではありません。<br>そのため、HPA の内容に関しましては、下記 Kubernetes 公式ドキュメントの内容に準拠します。</p><blockquote><p>ご参考情報：Horizontal Pod Autoscalerウォークスルー | Kubernetes<br><a href="https://kubernetes.io/ja/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/">https://kubernetes.io/ja/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/</a></p></blockquote><p>HPA では、ノード上のメトリクス情報を kubelet を経由して Kubernetes クラスター内に存在するメトリクス サーバーに収集します。<br>なお、このメトリクス サーバーは現時点でサポートされている AKS クラスターでは標準でデプロイされております。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -n kube-system -l k8s-app=metrics-server</span></span><br><span class="line">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">metrics-server-5f87fccc7d-724vf   2/2     Running   0          2d11h</span><br><span class="line">metrics-server-5f87fccc7d-bl2d4   2/2     Running   0          2d11h</span><br></pre></td></tr></table></figure><p>メトリクス サーバーは収集された情報より、Pod が使用している CPU やメモリ等のメトリクス情報に基づき Deployment、ReplicaSet または StatefulSet といったレプリケーション コントローラー内のPodのレプリカ数をスケーリングします。</p><p>これによって、負荷に応じて Pod のレプリカ数が増減します。</p><p>それでは、実際に AKS クラスターを利用して HPA の設定をします。</p><h3 id="HPA-の挙動を確認してみる"><a href="#HPA-の挙動を確認してみる" class="headerlink" title="HPA の挙動を確認してみる"></a>HPA の挙動を確認してみる</h3><p>ここでは、AKS のチュートリアルで利用されているサンプル アプリケーション (azure-vote) を用いて確認します。<br>サンプル アプリケーションをローカル端末にクローンします。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/Azure-Samples/azure-voting-app-redis.git</span></span><br></pre></td></tr></table></figure><p>上記コマンドによってクローンされたマニフェスト ファイルを確認し、コンテナーにリソース要求が設定されていることを確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> less ./azure-voting-app-redis/azure-vote-all-in-one-redis.yaml</span></span><br></pre></td></tr></table></figure><p>azure-vote-front コンテナーでは、次のようにリソース要求が設定されていることが確認できます。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">azure-vote-front</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">mcr.microsoft.com/azuredocs/azure-vote-front:v1</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">250m</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">500m</span></span><br></pre></td></tr></table></figure><p>上記リソース要求を確認すると、コンテナーをデプロイするために必要なリソースは、250 ミリ CPU であり、制限は 500 ミリ CPU となっていることが確認できました。<br>HPA では、対象のレプリケーション コントローラー内の Pod に設定された、リソース要求に対する使用率の平均を計算します。</p><p>それでは、当該 Pod をデプロイします。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f ./azure-voting-app-redis/azure-vote-all-in-one-redis.yaml</span></span><br></pre></td></tr></table></figure><p>デプロイされた Pod を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">azure-vote-back-5fb9656dff-6ln9w    1/1     Running   0          47s</span><br><span class="line">azure-vote-front-7589b695dd-wb7mq   1/1     Running   0          47s</span><br></pre></td></tr></table></figure><p>azure-vote-front の Pod が作成されていることを確認できました。</p><p>それでは、ここから HPA の設定をします。</p><p>HPA の設定は、HorizontalPodAutoscaler リソースを用いて定義することが可能となり、kubectl autoscale コマンドもしくは、マニフェスト ファイルを用いて作成することが可能となります。</p><p>今回の検証では、Deplyoment “azure-vote-front” 内の全 Pod の平均 CPU 使用率が 50% を目標に、最小 3 台、最大 10 台まで Pod のレプリカ数を増減させるように設定します。</p><p>この設定を kubectl autoscale コマンドにて実施する場合は、下記コマンドとなります。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl autoscale deployment azure-vote-front --cpu-percent=50 --min=3 --max=10</span></span><br></pre></td></tr></table></figure><p>この HPA によって Deplyoment “azure-vote-front” 内の Pod のレプリカ数は最小 3 台となるため、先ほど確認した Pod のレプリカ数は 1 台でしたが、3 台に増えていることが確認できます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -l app=azure-vote-front</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">azure-vote-front-7589b695dd-d7psh   1/1     Running   0          98s</span><br><span class="line">azure-vote-front-7589b695dd-km4hq   1/1     Running   0          98s</span><br><span class="line">azure-vote-front-7589b695dd-wb7mq   1/1     Running   0          11m</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get hpa</span></span><br><span class="line">NAME               REFERENCE                     TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">azure-vote-front   Deployment/azure-vote-front   2%/50%    3         10        3          110s</span><br></pre></td></tr></table></figure><p>想定どおり、Pod のレプリカ数が HPA の設定にしたがって Pod のレプリカ数が増えたことが確認できました。</p><p>次に、Pod に負荷をかけることで、HPA によって Pod のレプリカ数が増えることを確認します。<br>まずは、事前に現在の Pod の CPU 負荷状況を kubectl top pods コマンドを用いて確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl top pods -l app=azure-vote-front</span></span><br><span class="line">NAME                                CPU(cores)   MEMORY(bytes)</span><br><span class="line">azure-vote-front-7589b695dd-d7psh   1m           60Mi</span><br><span class="line">azure-vote-front-7589b695dd-km4hq   1m           58Mi</span><br><span class="line">azure-vote-front-7589b695dd-wb7mq   1m           45Mi</span><br></pre></td></tr></table></figure><p>現在の Pod の CPU 使用量が低い状況であることが確認できました。<br>次に、CPU に負荷をかけるために、今回は stress コマンドを用います。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> -it azure-vote-front-7589b695dd-d7psh -- stress -c 1</span></span><br><span class="line">stress: info: [330] dispatching hogs: 1 cpu, 0 io, 0 vm, 0 hdd</span><br></pre></td></tr></table></figure><p>stress コマンドによって、Pod “azure-vote-front-7589b695dd-d7psh” の CPU に負荷をかけ始めました。再度 kubectl top pods コマンドを用いて CPU の負荷状況を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl top pods -l app=azure-vote-front</span></span><br><span class="line">NAME                                CPU(cores)   MEMORY(bytes)</span><br><span class="line">azure-vote-front-7589b695dd-d7psh   312m         65Mi</span><br><span class="line">azure-vote-front-7589b695dd-km4hq   1m           58Mi</span><br><span class="line">azure-vote-front-7589b695dd-wb7mq   1m           45Mi</span><br></pre></td></tr></table></figure><p>先ほど 2 ミリ CPU 程度であったのに対して、312 ミリ CPU 程リソースを消費していることが確認できました。<br>ここで HPA の状況ならびに Pod の稼働状況を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get hpa</span></span><br><span class="line">NAME               REFERENCE                     TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">azure-vote-front   Deployment/azure-vote-front   67%/50%   3         10        4          30m</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -l app=azure-vote-front</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">azure-vote-front-7589b695dd-4q79q   1/1     Running   0          101s</span><br><span class="line">azure-vote-front-7589b695dd-d7psh   1/1     Running   0          30m</span><br><span class="line">azure-vote-front-7589b695dd-km4hq   1/1     Running   0          30m</span><br><span class="line">azure-vote-front-7589b695dd-wb7mq   1/1     Running   0          39m</span><br></pre></td></tr></table></figure><p>stress コマンドを用いて CPU の負荷をかけたことによって、Pod のレプリカ数が 3 から 4 に増えたことが確認できました。<br>最後に stress コマンドを停止し、増えた Pod が自動で削除されることも確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt; - Control + Cキー によってプロセスを終了する</span><br><span class="line">command terminated with exit code 130</span><br></pre></td></tr></table></figure><p>再度 kubectl top pods コマンドを用いて CPU の負荷状況を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl top pods -l app=azure-vote-front</span></span><br><span class="line">NAME                                CPU(cores)   MEMORY(bytes)</span><br><span class="line">azure-vote-front-7589b695dd-4q79q   1m           39Mi</span><br><span class="line">azure-vote-front-7589b695dd-d7psh   1m           65Mi</span><br><span class="line">azure-vote-front-7589b695dd-km4hq   1m           58Mi</span><br><span class="line">azure-vote-front-7589b695dd-wb7mq   1m           45Mi</span><br></pre></td></tr></table></figure><p>Pod “azure-vote-front-7589b695dd-d7psh” の CPU 使用量が減少したことが確認できました。<br>その後、しばらくした後に、次のように Pod のレプリカ数が最小の 3 に戻ることが確認できます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get hpa</span></span><br><span class="line">NAME               REFERENCE                     TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">azure-vote-front   Deployment/azure-vote-front   0%/50%    3         10        4          38m</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get hpa</span></span><br><span class="line">NAME               REFERENCE                     TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">azure-vote-front   Deployment/azure-vote-front   0%/50%    3         10        3          38m</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">azure-vote-front-7589b695dd-d7psh   1/1     Running   0          39m</span><br><span class="line">azure-vote-front-7589b695dd-km4hq   1/1     Running   0          39m</span><br><span class="line">azure-vote-front-7589b695dd-wb7mq   1/1     Running   0          48m</span><br></pre></td></tr></table></figure><p>このように HPA を利用することで、Pod の負荷状況に応じて Pod のレプリカ数を自動で増減可能なことを確認しました。</p><h2 id="クラスター-オートスケーラーについて"><a href="#クラスター-オートスケーラーについて" class="headerlink" title="クラスター オートスケーラーについて"></a>クラスター オートスケーラーについて</h2><p>AKS では、ノードをオートスケールするための機能として、クラスター オートスケーラーが提供されています。<br>クラスター オートスケーラーを利用することで、新規 Pod がデプロイ可能な空きノードが不足し、Pending (割り当て不可) 状態となった際にノードである Azure 仮想マシンの数を自動で増減することが可能となります。<br>これによって、Pod のデプロイに必要なノード数のみ稼働させることで、コストの最適化などが期待されます。</p><div class="alert is-important"><p class="alert-title">重要</p><p>クラスター オートスケーラーは、CPU やメモリ等のリソースの使用率を監視し自動でスケールする機能ではありません。</p><p>新規 Pod がデプロイ可能な空きノードが不足し、Pending (割り当て不可) 状態となった際に自動でスケールアウトする機能となります。</p></div><div class="alert is-warning"><p class="alert-title">警告</p><p>AKS のクラスター オートスケーラーを利用する場合、VMSS のオートスケール機能を有効にしないでください。</p><p>AKS では、VMSS などの IaaS リソースの API を用いて直接変更することはサポート外となります。</p><p>いずれの機能も有効にした場合は、 VMSS へ直接変更を加えたことにより、AKS クラスターがサポートされない状態になる恐れや、2 つのオートスケ</p><p>ールの処理が競合することで、ノードの増減が想定通りに動作しない可能性がございます。</p><blockquote><p>ご参考情報：エージェント ノードのユーザー カスタマイズ</p><p><a href="https://learn.microsoft.com/ja-jp/azure/aks/support-policies#user-customization-of-agent-nodes">https://learn.microsoft.com/ja-jp/azure/aks/support-policies#user-customization-of-agent-nodes</a></p><p>　</p><p>ご参考情報： AKS クラスターの作成とクラスター オートスケーラーの有効化</p><p><a href="https://learn.microsoft.com/ja-jp/azure/aks/cluster-autoscaler#create-an-aks-cluster-and-enable-the-cluster-autoscaler">https://learn.microsoft.com/ja-jp/azure/aks/cluster-autoscaler#create-an-aks-cluster-and-enable-the-cluster-autoscaler</a></p></div></blockquote><p>そのため、適切にクラスター オートスケーラーを利用するためには、各 Pod に適切なリソース要求を設定することが重要となります。</p><p>それでは、実際に AKS クラスターを利用してクラスター オートスケーラーの挙動を確認します。</p><h3 id="クラスター-オートスケーラーの挙動を確認してみる"><a href="#クラスター-オートスケーラーの挙動を確認してみる" class="headerlink" title="クラスター オートスケーラーの挙動を確認してみる"></a>クラスター オートスケーラーの挙動を確認してみる</h3><p>クラスター オートスケーラーの挙動を確認するにあたり、まずはユーザー ノードプールを追加します。<br>ここでは、ノード数が 1、仮想マシンのサイズが Standard_DS2_v2 (2vCPU, 7GiB) のノード プールを追加します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az aks nodepool add \</span></span><br><span class="line"><span class="bash">    --resource-group &lt;リソースグループ名&gt; \</span></span><br><span class="line"><span class="bash">    --cluster-name &lt;クラスター名&gt; \</span></span><br><span class="line"><span class="bash">    --name usernp1 \</span></span><br><span class="line"><span class="bash">    --node-count 1 \</span></span><br><span class="line"><span class="bash">    --mode User \</span></span><br><span class="line"><span class="bash">    --node-vm-size Standard_ DS2_v2 \</span></span><br><span class="line"><span class="bash">    --labels nodelabel=catest</span></span><br></pre></td></tr></table></figure><p>追加されたノードの情報を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get nodes</span></span><br><span class="line">NAME                                STATUS   ROLES   AGE     VERSION</span><br><span class="line">aks-nodepool1-12285779-vmss000000   Ready    agent   4h14m   v1.24.6</span><br><span class="line">aks-nodepool1-12285779-vmss000001   Ready    agent   4h13m   v1.24.6</span><br><span class="line">aks-nodepool1-12285779-vmss000002   Ready    agent   4h13m   v1.24.6</span><br><span class="line">aks-usernp1-70474131-vmss000000     Ready    agent   3m      v1.24.6</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe node aks-usernp1-70474131-vmss000000</span></span><br><span class="line">&lt;中略&gt;</span><br><span class="line">Allocatable:</span><br><span class="line">  cpu:                1900m</span><br><span class="line">  ephemeral-storage:  119703055367</span><br><span class="line">  hugepages-1Gi:      0</span><br><span class="line">  hugepages-2Mi:      0</span><br><span class="line">  memory:             4670956Ki</span><br><span class="line">  pods:               110</span><br><span class="line">&lt;中略&gt;</span><br></pre></td></tr></table></figure><p>ノードが追加されていることを確認しました。<br>それでは、このノード プールにリソース要求を設定した Pod をデプロイするために、Deployments のマニフェスト ファイルを作成します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat &lt;&lt; <span class="string">EOF &gt;&gt; ca-test-pod.yaml</span></span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        nodelabel: catest</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 2.5Gi</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>上記定義によって、nodelabel キーにcatest を持つノードにのみ nginx Pod が配置されます。これによって、他のノードに Pod がデプロイされることを防げます。<br>それでは、このマニフェスト ファイルに従い、Deployment を作成します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f ca-test-pod.yaml</span></span><br><span class="line">deployment.apps/nginx created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -o wide</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP           NODE                              NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-67d6486785-7rj7r   0/1     Pending   0          18s   &lt;none&gt;       &lt;none&gt;                            &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-67d6486785-hfcmw   1/1     Running   0          18s   10.244.3.5   aks-usernp1-70474131-vmss000000   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p>Pod “nginx-67d6486785-7rj7r” が Pending 状態であることが確認できました。 原因を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod nginx-67d6486785-7rj7r</span></span><br><span class="line"></span><br><span class="line">&lt;中略&gt;</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age    From               Message</span><br><span class="line">  ----     ------            ----   ----               -------</span><br><span class="line">  Warning  FailedScheduling  2m54s  default-scheduler  0/4 nodes are available: 1 Insufficient memory, 3 node(s) didn&#x27;t match Pod&#x27;s node affinity/selector. preemption: 0/4 nodes are available: 1 No preemption victims found for incoming pod, 3 Preemption is not helpful for scheduling.</span><br></pre></td></tr></table></figure><p>このメッセージは、クラスター内の全 4 台のノードのうち、1 ノードはメモリの空き容量が不足しており、他 3 ノードがセレクターを満たさず、Pod をスケジューリング可能なノードが見つからなかったことを示します。</p><p>これによって、ノード プール “usernp1” では、リソースの不足に伴い Pod が Pending となる状況となりました。</p><p>この状態で、ノード プール “usernp1” に対して、クラスター オートスケーラーを有効にします。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az aks nodepool update \</span></span><br><span class="line"><span class="bash">  --resource-group &lt;リソースグループ名&gt; \</span></span><br><span class="line"><span class="bash">  --cluster-name &lt;クラスター名&gt; \</span></span><br><span class="line"><span class="bash">  --name usernp1 \</span></span><br><span class="line"><span class="bash">  --enable-cluster-autoscaler \</span></span><br><span class="line"><span class="bash">  --min-count 1 \</span></span><br><span class="line"><span class="bash">  --max-count 3</span></span><br></pre></td></tr></table></figure><p>クラスター オートスケーラーを有効化したので、ノードが追加されていることを確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get nodes</span></span><br><span class="line">NAME                                STATUS   ROLES   AGE     VERSION</span><br><span class="line">aks-nodepool1-12285779-vmss000000   Ready    agent   4h47m   v1.24.6</span><br><span class="line">aks-nodepool1-12285779-vmss000001   Ready    agent   4h47m   v1.24.6</span><br><span class="line">aks-nodepool1-12285779-vmss000002   Ready    agent   4h46m   v1.24.6</span><br><span class="line">aks-usernp1-70474131-vmss000000     Ready    agent   36m     v1.24.6</span><br><span class="line">aks-usernp1-70474131-vmss000001     Ready    agent   34s     v1.24.6</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -o wide</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP           NODE                              NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-67d6486785-7rj7r   1/1     Running   0          14m   10.244.4.2   aks-usernp1-70474131-vmss000001   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-67d6486785-hfcmw   1/1     Running   0          14m   10.244.3.5   aks-usernp1-70474131-vmss000000   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p>期待どおりノード プール “usernp1” に新規ノード “usernp1-70474131-vmss000001”が作成され、Pod “nginx-67d6486785-7rj7r” がデプロイされていることが確認できました。</p><p>最後に Pod のレプリカ数を 1 に減らし、ノードが自動削除されることを確認します。<br>マニフェスト ファイルを修正し、Pod のレプリカ数を 1 に減らした後に、再度マニフェスト ファイルを適用します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f ca-test-pod.yaml</span></span><br><span class="line">deployment.apps/nginx configured</span><br></pre></td></tr></table></figure><p>これによって、Pod のレプリカ数およびノードが減っていることを確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -o wide</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP           NODE                              NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-67d6486785-hfcmw   1/1     Running   0          19m   10.244.3.5   aks-usernp1-70474131-vmss000000   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get nodes</span></span><br><span class="line">NAME                                STATUS   ROLES   AGE    VERSION</span><br><span class="line">aks-nodepool1-12285779-vmss000000   Ready    agent   5h3m   v1.24.6</span><br><span class="line">aks-nodepool1-12285779-vmss000001   Ready    agent   5h3m   v1.24.6</span><br><span class="line">aks-nodepool1-12285779-vmss000002   Ready    agent   5h3m   v1.24.6</span><br><span class="line">aks-usernp1-70474131-vmss000000     Ready    agent   52m    v1.24.6</span><br></pre></td></tr></table></figure><p>このように クラスター オートスケーラーを利用することで、ノード上のリソース不足が原因で Pending となった Pod が発生した際にノード プール内のノードの数を自動で増え、リソースの使用率が低下した際にノードの数が自動で減ることが確認できました。</p><h3 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h3><p>この記事では、HPA とクラスター オートスケーラーによる Pod とノードのオートスケーリングのしくみについて、サンプル アプリケーションを例にご紹介しました。設定した条件に応じて、自動でスケールアウトされることが確認いただけたかと思います。<br>こういったオートスケールの設定を適切にお使いいただくことで、お客様のワークロードの可用性を高めることができるかと存じますので、ご参考にいただけますと幸いです。</p><p>本稿が皆様のお役に立ちましたら幸いです。</p><p>最後まで読んでいただきありがとうございました！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは！ Azure テクニカル サポート チームの川畑です。&lt;/p&gt;
&lt;p&gt;Kubernetes を利用するにあたり、負荷に応じてワークロードを動的に増減させるオートスケーリングの構成を取ることがあります。&lt;/p&gt;
&lt;p&gt;この記事では、 Azure Kubernetes Service (AKS) を利用している環境を想定し、Pod およびノードのオートスケーリングの設定と動作についてご紹介します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Containers" scheme="https://jpaztech.github.io/blog/tags/Containers/"/>
    
    <category term="Azure Kubernetes Service (AKS)" scheme="https://jpaztech.github.io/blog/tags/Azure-Kubernetes-Service-AKS/"/>
    
  </entry>
  
  <entry>
    <title>Azure Linux エージェント (waagent) に出力されるメッセージについて</title>
    <link href="https://jpaztech.github.io/blog/vm/vmagent-error/"/>
    <id>https://jpaztech.github.io/blog/vm/vmagent-error/</id>
    <published>2022-12-23T03:00:00.000Z</published>
    <updated>2023-01-10T02:14:50.820Z</updated>
    
    <content type="html"><![CDATA[<p>この記事は <a href="https://qiita.com/advent-calendar/2022/microsoft-azure-tech">Microsoft Azure Tech Advent Calendar 2022</a> の 23 日目の記事です。</p><p>こんにちは、Azure テクニカル サポートの木下です。<br>今回は、よくお問い合わせいただきます、Azure Linux エージェント (waagent) に出力されるメッセージについてご紹介いたします。 </p><span id="more"></span> <p>Azure Linux VM の /var/log/messages において、以下のような Error 句を含むメッセージが出力されたため、原因を知りたいというお問い合わせをいただくことがございます。 </p><p>メッセージ例） </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dec 11 06:16:46 testvm python: 2022-12-15T21:16:46.414141Z ERROR MonitorHandler ExtHandler An error occurred <span class="keyword">in</span> the monitor thread main loop; will skip the current iteration. </span><br><span class="line">Dec 11 06:16:46 testvm python: [ProtocolError] Error fetching goal state </span><br><span class="line">Dec 11 06:16:46 testvm python: Inner error: [ResourceGoneError] [HTTP Failed] [410: Gone] The page you requested was removed. </span><br></pre></td></tr></table></figure><h2 id="1-Error-句を含むメッセージの内容について"><a href="#1-Error-句を含むメッセージの内容について" class="headerlink" title="1. Error 句を含むメッセージの内容について"></a>1. Error 句を含むメッセージの内容について</h2><p>Azure Linux エージェントは新しい更新情報などがないかの確認のため、VM と拡張機能の状態を物理ホストへ報告し、定期的に目標状態 (Goal State) の取得を行っております。<br>上記のような Error 句を含むメッセージは、この目標状態の取得に失敗した場合に出力されるエラーならびに関連のメッセージとなります。<br>目標状態の取得は、Azure 基盤内部の専用のエンドポイントとのやり取りで行われておりますが、このエンドポイントについては、稼働率が 100 % とすることは叶わず、拡張機能などの動作に支障がない範囲でメンテナンスが行われております。 </p><p>そのため、これらの Error 句を含むメッセージは、エンドポイントまでの通信経路で何らかの一時的な接続断やエンドポイント側のメンテナンスなどが発生し、目標状態の取得に失敗した際に発生することが想定となります。 </p><p>Azure Linux エージェント (waagent) については、以下公開情報におまとめしておりますので、詳細については、こちらをご参照ください。 </p><blockquote><p>参考） </p><ul><li><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/extensions/agent-linux">Azure Linux エージェントの理解と使用</a> </li></ul></blockquote><h2 id="2-影響の有無について"><a href="#2-影響の有無について" class="headerlink" title="2. 影響の有無について"></a>2. 影響の有無について</h2><p>Azure Linux エージェントの更新情報の確認は、数秒間隔で常に行われております。一時的に失敗していた期間が存在していたとしても、VM の動作へ影響を与えるものではないため、その後成功 (=Error 句を含むメッセージの出力が停止) していれば問題のないものと判断いただくことが可能です。<br>従いまして、このメッセージの出力が一時的なものであれば、基本的にはご放念いただいて問題なく、また、お客様側で何らかの対処をいただく必要はございません。 </p><p>一方で、Azure Linux エージェント自体が何らかの動作不具合となってしまった等が原因で恒常的にエンドポイントとの通信に失敗している場合、Azure 基盤側が「Azure Linux エージェント (waagent) と通信ができない状態」とみなし、エージェントが管理している拡張機能の動作 、例えば、Azure Backup の取得等に失敗してしまうケースがあります。この場合は、是正を行う必要がある状態となります。 </p><p>まずは、Error 句を含むメッセージが出力された VM のエージェントの状態が Ready なのか、Not Ready となってしまっているのかを Azure ポータル や Azure PowerShell / Azure CLI のコマンドの実行結果よりご確認ください。 </p><h2 id="3-エージェントの状態の確認方法について"><a href="#3-エージェントの状態の確認方法について" class="headerlink" title="3. エージェントの状態の確認方法について"></a>3. エージェントの状態の確認方法について</h2><h3 id="▼Azure-ポータルの場合"><a href="#▼Azure-ポータルの場合" class="headerlink" title="▼Azure ポータルの場合"></a>▼Azure ポータルの場合</h3><p><img src="/blog/vm/vmagent-error/vmagent-error01.png"> </p><h3 id="▼Azure-PowerShell-の場合"><a href="#▼Azure-PowerShell-の場合" class="headerlink" title="▼Azure PowerShell の場合"></a>▼Azure PowerShell の場合</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PS &gt; <span class="variable">$vm</span> = Get-AzVm -ResourceGroupName &lt;RGName&gt; -Name &lt;VMName&gt; -Status </span><br><span class="line"></span><br><span class="line"><span class="comment"># エージェントの状態表示 (DisplayStatus が Ready であるかを確認) </span></span><br><span class="line">PS &gt; <span class="variable">$vm</span>.VMAgent.Statuses[0] </span><br><span class="line"></span><br><span class="line">Code          : ProvisioningState/succeeded </span><br><span class="line">Level         : Info </span><br><span class="line">DisplayStatus : Ready </span><br><span class="line">Message       : GuestAgent is running and processing the extensions. </span><br><span class="line">Time          : 11/28/2022 3:53:17 AM </span><br></pre></td></tr></table></figure><h3 id="▼Azure-CLI-の場合"><a href="#▼Azure-CLI-の場合" class="headerlink" title="▼Azure CLI の場合"></a>▼Azure CLI の場合</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># VM の状態情報を取得し、エージェントの状態を抽出して表示 (displayStatus が Ready であるかを確認) </span></span><br><span class="line">az vm get-instance-view -g &lt;RGName&gt; -n &lt;VMName&gt; --query <span class="string">&#x27;&#123;AgentStatus:instanceView.vmAgent.statuses&#125;&#x27;</span> </span><br><span class="line">&#123; </span><br><span class="line">  <span class="string">&quot;AgentStatus&quot;</span>: [ </span><br><span class="line">    &#123; </span><br><span class="line">      <span class="string">&quot;code&quot;</span>: <span class="string">&quot;ProvisioningState/succeeded&quot;</span>, </span><br><span class="line">      <span class="string">&quot;displayStatus&quot;</span>: <span class="string">&quot;Ready&quot;</span>, </span><br><span class="line">      <span class="string">&quot;level&quot;</span>: <span class="string">&quot;Info&quot;</span>, </span><br><span class="line">      <span class="string">&quot;message&quot;</span>: <span class="string">&quot;GuestAgent is running and processing the extensions.&quot;</span>, </span><br><span class="line">      <span class="string">&quot;time&quot;</span>: <span class="string">&quot;2022-11-28T03:56:17.923000+00:00&quot;</span> </span><br><span class="line">    &#125; </span><br><span class="line">  ] </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Not Readyの状態が継続して発生している場合の想定されるシナリオと対処策をおまとめしたブログ記事もございますので、想定されるシナリオに該当するかの切り分け方法としてご参照くださいませ。 </p><blockquote><p>参考） </p><ul><li><a href="https://jpaztech.github.io/blog/vm/vmagent-notready/">「仮想マシン エージェントの状態が準備できていません」について</a> </li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;この記事は &lt;a href=&quot;https://qiita.com/advent-calendar/2022/microsoft-azure-tech&quot;&gt;Microsoft Azure Tech Advent Calendar 2022&lt;/a&gt; の 23 日目の記事です。&lt;/p&gt;
&lt;p&gt;こんにちは、Azure テクニカル サポートの木下です。&lt;br&gt;今回は、よくお問い合わせいただきます、Azure Linux エージェント (waagent) に出力されるメッセージについてご紹介いたします。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Linux" scheme="https://jpaztech.github.io/blog/tags/Linux/"/>
    
    <category term="VM Agent" scheme="https://jpaztech.github.io/blog/tags/VM-Agent/"/>
    
  </entry>
  
  <entry>
    <title>Windows VM のビルトイン Administrator アカウントの名前変更について</title>
    <link href="https://jpaztech.github.io/blog/vm/vm-administrator-username-change/"/>
    <id>https://jpaztech.github.io/blog/vm/vm-administrator-username-change/</id>
    <published>2022-12-21T15:00:00.000Z</published>
    <updated>2023-01-10T02:14:50.760Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの洪です。<br>Azure VM (Windows OS) 作成時には、OS 内で “ビルトイン Administrator” として <strong>管理者アカウント</strong> のユーザー名をご指定いただくことになりますが、こちらのユーザー名の変更が可能であるかとのお問い合わせをいただくことがございます。<br>本記事ではそのユーザー名を OS 上から変更する方法および関連の留意事項 についてご案内いたします。</p><span id="more"></span><hr><h2 id="変更対象"><a href="#変更対象" class="headerlink" title="変更対象"></a>変更対象</h2><p>本記事にて案内しております手順は、以下のように作成されたユーザーを後から変更するものとなります。</p><p>■ 確認例 - Azure ポータル画面<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-01.png"><br>※ Azure VM の管理者アカウントのユーザー名として、azureadmin を指定します。</p><p>■ 確認例 - OS 上の画面<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-02.png"><br>※ Windows OS のビルトイン Administrator として azureadmin のユーザーが生成されます。<br>※ こちらのユーザー名の変更に関しまして、以下にご案内いたします。  </p><h2 id="管理者アカウント-ユーザー名を変更する"><a href="#管理者アカウント-ユーザー名を変更する" class="headerlink" title="管理者アカウント ユーザー名を変更する"></a>管理者アカウント ユーザー名を変更する</h2><p>管理者アカウントのユーザー名は従来の Windows の動作のように Windows の [コンピューターの管理] で変更可能でございます。<br>詳細手順に関しましては以下をご確認ください。</p><h2 id="■-手順"><a href="#■-手順" class="headerlink" title="■ 手順"></a>■ 手順</h2><h3 id="1-現在の管理者-ビルドイン-Administrator-のユーザー名を確認します。"><a href="#1-現在の管理者-ビルドイン-Administrator-のユーザー名を確認します。" class="headerlink" title="1. 現在の管理者 (ビルドイン Administrator) のユーザー名を確認します。"></a>1. 現在の管理者 (ビルドイン Administrator) のユーザー名を確認します。</h3><p>1-1. 画面左下側の Windows アイコンを右クリックし、[コンピューターの管理] を開きます。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-03.png"></p><p>1-2. [ローカル ユーザーとグループ] - [ユーザー] を選択し、”Built-in account for administering the computer” にて 該当するユーザー名を確認します。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-04.png"><br>※ この例では、[azureadmin] になります。</p><h3 id="2-管理者のユーザー名を変更します。"><a href="#2-管理者のユーザー名を変更します。" class="headerlink" title="2. 管理者のユーザー名を変更します。"></a>2. 管理者のユーザー名を変更します。</h3><p>2-1. 当該名前を右クリックし、[名前の変更] をクリックします。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-05.png"></p><p>2-2. ご希望のユーザー名を入力し、変更が可能です。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-06.png"><br>※ この例では、[azureadminnew] に変更しました。</p><h2 id="ユーザー名変更の影響および対処について"><a href="#ユーザー名変更の影響および対処について" class="headerlink" title="ユーザー名変更の影響および対処について"></a>ユーザー名変更の影響および対処について</h2><p>Windows OS のユーザーにつきましては、[C:\ユーザー] 配下にユーザー名でフォルダーが作成されますが、上記の手順で管理者のユーザー名をご変更いただいた際に、フォルダーの名前が自動で変更される動作はございません。<br>フォルダ名とログオン ユーザー名が異なっていても通常は問題ないためご放念いただく形となりますが、もしアプリケーションが動作しないなどやむを得ない理由があれば以下の手順で変更することは可能です。<br>フォルダー名を新しいユーザー名に変更する場合には、手動にてレジストリをご変更いただく必要がございます。<br>具体的な手順を下記にご案内いたします。</p><blockquote><p>[!CAUTION]<br>レジストリを誤って変更すると、深刻な問題が発生することがございます。<br>レジストリを編集する際には十分に注意してください。<br>万一に備えて、編集の前にはレジストリのバックアップまたは仮想マシンのバックアップ (Azure Backup やディ&gt; スクのスナップショット) をご取得いただきますようお願いします。<br>レジストリのバックアップおよび復元方法の詳細を参照するには、以下のサポート技術情報をご確認ください。<br>ご参考) <a href="https://support.microsoft.com/ja-jp/help/322756/">Windows でレジストリをバックアップおよび復元する方法</a></p></blockquote><h2 id="■-手順-1"><a href="#■-手順-1" class="headerlink" title="■ 手順"></a>■ 手順</h2><p>※ 仮想マシン作成時に指定した管理者のユーザー名 azureadmin を azureadminnew に変更する場合を例にご説明いたします。</p><h3 id="1-新しいローカル管理者アカウント-例-tempaccount-を作成します。"><a href="#1-新しいローカル管理者アカウント-例-tempaccount-を作成します。" class="headerlink" title="1. 新しいローカル管理者アカウント (例 tempaccount) を作成します。"></a>1. 新しいローカル管理者アカウント (例 tempaccount) を作成します。</h3><p>1-1. Windows で、[コントロール パネル] を検索し、開きます。</p><p>1-2. [ユーザー アカウント] &gt; [ユーザー アカウント] &gt; [別のアカウントの管理] を選択し、[ユーザー アカウントの追加] から新しいアカウントを作成します。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-07.png"><br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-08.png"><br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-09.png"></p><p>1-3. 新しいローカル アカウントをクリックし、[アカウントの種類の変更] をクリックします。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-10.png"></p><p>1-4. [管理者] を選択し、[アカウントの種類の変更]をクリックします。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-11.png"></p><p>1-5. 新しいローカルアカウントが、[ローカル アカウント Administrator] に表示されることを確認します。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-12.png"></p><p>1-6. VMを再起動します。</p><h3 id="2-Windows-ユーザー-フォルダーの名前を変更します。"><a href="#2-Windows-ユーザー-フォルダーの名前を変更します。" class="headerlink" title="2. Windows ユーザー フォルダーの名前を変更します。"></a>2. Windows ユーザー フォルダーの名前を変更します。</h3><p>2-1. 対象仮想マシンに、新しいローカル アカウント (例 tempaccount) にてログインします。(コマンド プロンプトの whoami から確認可能です。)<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-13.png"></p><p>2-2. エクスプローラーを開き、C:\ユーザー から仮想マシン作成時に指定した管理者のユーザー フォルダーを右クリックし、[名前の変更] をクリックします。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-14.png"></p><p>2-3. フォルダー名を変更したユーザー名(例. C:\Users\azureadminnew) に変更します。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-15.png"></p><h3 id="3-ユーザーの-SID-を確認します。"><a href="#3-ユーザーの-SID-を確認します。" class="headerlink" title="3. ユーザーの SID を確認します。"></a>3. ユーザーの SID を確認します。</h3><p>3-1. コマンド プロンプトを開き、以下のコマンドを実行します。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WMIC useraccount get name,sid</span><br></pre></td></tr></table></figure><p>3-2. 出力結果から、仮想マシン作成時に指定したユーザー名の SID を確認します。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-16.png"></p><h3 id="4-レジストリ-エディターを使用して名前を変更したフォルダーをマップします。"><a href="#4-レジストリ-エディターを使用して名前を変更したフォルダーをマップします。" class="headerlink" title="4. レジストリ エディターを使用して名前を変更したフォルダーをマップします。"></a>4. レジストリ エディターを使用して名前を変更したフォルダーをマップします。</h3><p>4-1. キーボードの Windows キーと R キーを同時に押し、[ファイル名を指定して実行] を開きます。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-17.png"></p><p>4-2. 「regedit」 を入力し、[OK] を押下します。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-18.png"></p><p>4-3. [レジストリ エディター] にて、下記のパスに移動します。</p><blockquote><p>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList</p></blockquote><p><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-19.png"></p><p>4-4. [ProfileList] 配下から、手順 3 で確認した SID を選択します。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-20.png"></p><p>4-5. [ProfileImagePath] をダブル クリックします。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-21.png"></p><p>4-6. [値のデータ] へ [C:\Users&lt;変更したユーザー名&gt;] (例 C:\Users\azureadminnew) を入力し、[OK] をクリックします。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-22.png"><br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-23.png"></p><p>4-7. 当該仮想マシンを再起動します。</p><h3 id="5-新しいローカル管理者アカウントを無効にします。"><a href="#5-新しいローカル管理者アカウントを無効にします。" class="headerlink" title="5. 新しいローカル管理者アカウントを無効にします。"></a>5. 新しいローカル管理者アカウントを無効にします。</h3><p>5-1. 対象仮想マシンに、変更後の管理者アカウント(例 azureadminnew) にてログインします。</p><p>5-2. 管理者権限にてコマンドプロンプトを開きます。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-24.png"></p><p>5-3. 以下のコマンドを入力すると、新しいローカル管理者アカウント (例 tempaccount) が無効になります。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> user &lt;新しいローカル管理者アカウント名&gt; /active:no</span><br></pre></td></tr></table></figure><p>※ 本手順では無効の方法を案内しておりますが、今後ご利用されない場合は削除していただいても問題ございません。</p><h2 id="管理者アカウント名の注意事項"><a href="#管理者アカウント名の注意事項" class="headerlink" title="管理者アカウント名の注意事項"></a>管理者アカウント名の注意事項</h2><p>ユーザー名をご指定いただく際の注意事項に関しましては、以下のドキュメントにてご案内しております。<br>詳細内容をご確認いただいた上で、変更する名前をご決定いただけますようお願い申し上げます。</p><blockquote><p>ご参考) <a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/faq#vm----------------------">VM を作成する際のユーザー名の要件は何ですか。</a><br>ユーザー名は最大 20 文字の長さまで指定できますが、末尾を句点 (“.”) にすることはできません。<br>次のユーザー名を指定することはできません。</p></blockquote><p>一方で、VM 作成後にゲスト OS 上の操作でユーザー名を変更した場合には、Azure としての制約が適用されないため、上記の要件以外のユーザー名を指定しても OS の動作は可能です。</p><p>ただし、Azure VM 作成時に登録する管理者アカウントは、Azure Portal からそのパスワードをリセットする機能がございますが、ドキュメントに記載のユーザー名の要件に従っていない場合にはその操作が不可になりますため、その点ご留意いただけますようお願いいたします。</p><h2 id="管理者アカウントの追加"><a href="#管理者アカウントの追加" class="headerlink" title="管理者アカウントの追加"></a>管理者アカウントの追加</h2><p>なお、 VM 構築後にゲスト OS 上の操作にて Administrator ユーザーを追加で作成いただくことも Azure としての制約はなく、ご利用いただける方法となります。</p><p>ただし、ゲスト OS 上で “Administrator” ユーザーを作成いただいた場合に関しましても、Azure Portal にて当該ユーザーのパスワードリセットの操作は叶いませんので、その点についてご留意いただけますようお願いいたします。</p><p>本稿が皆様のお役に立てれば幸いです。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの洪です。&lt;br&gt;Azure VM (Windows OS) 作成時には、OS 内で “ビルトイン Administrator” として &lt;strong&gt;管理者アカウント&lt;/strong&gt; のユーザー名をご指定いただくことになりますが、こちらのユーザー名の変更が可能であるかとのお問い合わせをいただくことがございます。&lt;br&gt;本記事ではそのユーザー名を OS 上から変更する方法および関連の留意事項 についてご案内いたします。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
  </entry>
  
  <entry>
    <title>Azure Windows VM でクラスター サイズが拡張したいボリューム サイズに対応してない場合について</title>
    <link href="https://jpaztech.github.io/blog/vm/extend-data-disk-related-to-a-cluster-size/"/>
    <id>https://jpaztech.github.io/blog/vm/extend-data-disk-related-to-a-cluster-size/</id>
    <published>2022-12-21T05:00:00.000Z</published>
    <updated>2023-01-10T02:14:50.548Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポート チームの新見です。</p><p>Azure Windows VM において、データ ディスクの拡張方法に関してお問い合わせをいただくことがあります。<br>今回はディスク拡張前の Windows NTFS のクラスター サイズ（アロケーション ユニットサイズ）が、ディスク拡張後のボリューム サイズに対応していない際に、ディスクを拡張する方法をご案内させていただきます。</p><span id="more"></span><h2 id="注意事項"><a href="#注意事項" class="headerlink" title="注意事項"></a>注意事項</h2><p>念のため、作業の実施前には、予期せぬご状況に備えてバックアップやスナップショットの取得をご実施いただければと存じます。<br><a href="https://learn.microsoft.com/ja-jp/azure/backup/backup-azure-vms-introduction">公開情報：Azure VM バックアップについて - Azure Backup | Microsoft Docs</a><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/snapshot-copy-managed-disk?tabs=portal">公開情報：仮想ハード ディスクの Azure スナップショットを作成する - Azure Virtual Machines | Microsoft Docs</a></p><p>また、記憶域スペースをご利用をいただいている場合においては、以下の手順をご参照ください。<br><a href="https://jpaztech.github.io/blog/vm/extend-storage-space-on-azure-windows-vm/">公開情報：Azure Windows VM で記憶域スペースを拡張する | Japan Azure IaaS Core Support Blog (jpaztech.github.io)</a></p><h2 id="クラスター-サイズが拡張したいボリューム-サイズに対応している場合"><a href="#クラスター-サイズが拡張したいボリューム-サイズに対応している場合" class="headerlink" title="クラスター サイズが拡張したいボリューム サイズに対応している場合"></a>クラスター サイズが拡張したいボリューム サイズに対応している場合</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>データ ディスクを拡張する際には、クラスター サイズが拡張したいボリューム サイズに対応している場合、Azure Portal 等にてディスクのサイズを拡張いただいた後、ゲスト OS 上の操作にてボリュームを拡張する必要があります。</p><h3 id="手順"><a href="#手順" class="headerlink" title="手順"></a>手順</h3><h4 id="1-仮想マシンを停止し、ディスクのサイズを拡張する"><a href="#1-仮想マシンを停止し、ディスクのサイズを拡張する" class="headerlink" title="1. 仮想マシンを停止し、ディスクのサイズを拡張する"></a>1. 仮想マシンを停止し、ディスクのサイズを拡張する</h4><p><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/expand-os-disk#resize-a-managed-disk-in-the-azure-portal">公開情報：Azure 内の Windows VM に接続されている仮想ハード ディスクを拡張する - Azure Virtual Machines | Microsoft Docs</a><br>参照箇所：Azure portal でマネージド ディスクのサイズを変更する</p><h4 id="2-仮想マシン内からボリュームを拡張する"><a href="#2-仮想マシン内からボリュームを拡張する" class="headerlink" title="2. 仮想マシン内からボリュームを拡張する"></a>2. 仮想マシン内からボリュームを拡張する</h4><p><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/expand-os-disk#using-disk-manager">公開情報：Azure 内の Windows VM に接続されている仮想ハード ディスクを拡張する - Azure Virtual Machines | Microsoft Docs</a><br>参照箇所：ディスク マネージャーの使用</p><p>しかしながら、この手順を実行する際にクラスター サイズが対応していない場合はエラーが発生するため、対処方法を以下の通りお伝えします。</p><h2 id="クラスター-サイズが拡張したいボリューム-サイズに対応していない場合"><a href="#クラスター-サイズが拡張したいボリューム-サイズに対応していない場合" class="headerlink" title="クラスター サイズが拡張したいボリューム サイズに対応していない場合"></a>クラスター サイズが拡張したいボリューム サイズに対応していない場合</h2><h3 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h3><p>そのまま既存のデータ ディスクを拡張することができないため、データ ディスクを新規で作成して仮想マシンに接続し、クラスター サイズが対応しているサイズでボリュームを作成した上で、既存ボリューム上のデータを新規ボリュームにコピーする必要があります。</p><h3 id="解説"><a href="#解説" class="headerlink" title="解説"></a>解説</h3><p>クラスター サイズが拡張したいボリューム サイズに対応している場合の手順で拡張した場合、クラスター サイズは拡張前のデフォルトのサイズのままなので、拡張したいボリュームのサイズに対応していない場合はクラスター サイズを対応させる必要があります。<br>しかし、クラスター サイズを変えてしまうと、ボリュームのフォーマットが実施されデータが消えてしまうため、新規でデータ ディスクを作成することでご対応いただければと存じます。</p><p>P70 で作成したディスクの 16TB のボリュームを、 32TB に拡張したい場合を例として説明します。</p><h4 id="デフォルトのクラスター-サイズと必要なクラスター-サイズ"><a href="#デフォルトのクラスター-サイズと必要なクラスター-サイズ" class="headerlink" title="デフォルトのクラスター サイズと必要なクラスター サイズ"></a>デフォルトのクラスター サイズと必要なクラスター サイズ</h4><p>作成するボリュームのサイズによって、デフォルトのクラスター サイズは以下のように異なります。<br><a href="https://support.microsoft.com/ja-jp/topic/ntfs-fat-%E3%81%8A%E3%82%88%E3%81%B3-exfat-%E3%81%AE%E3%83%87%E3%83%95%E3%82%A9%E3%83%AB%E3%83%88%E3%81%AE%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%BF%E3%83%BC-%E3%82%B5%E3%82%A4%E3%82%BA-9772e6f1-e31a-00d7-e18f-73169155af95">公開情報：NTFS、FAT、および exFAT のデフォルトのクラスター サイズ (microsoft.com)</a></p><table><thead><tr><th align="left">ボリュームのサイズ</th><th align="left">Windows 7、Windows Server 2008 R2、Windows Server 2008、Windows Vista、Windows Server 2003、Windows XP、Windows 2000</th></tr></thead><tbody><tr><td align="left">2TB – 16TB</td><td align="left">4KB</td></tr><tr><td align="left">16TB – 32TB</td><td align="left">8KB</td></tr></tbody></table><p>P70(16TB) でディスクを作成し、16TB でボリュームを作成した場合、デフォルトのクラスター サイズは 4KB になります。<br>クラスター サイズ が 4KB の場合、ボリュームは 16TB までしか対応していません。<br>32TB のボリュームを作成するには、8KB のクラスター サイズが必要になります。</p><p><a href="https://learn.microsoft.com/ja-jp/windows-server/storage/file-server/ntfs-overview#support-for-large-volumes">公開情報：NTFS の概要 | Microsoft Docs</a></p><table><thead><tr><th align="left">クラスター サイズ</th><th align="left">最大ボリュームおよびファイル</th></tr></thead><tbody><tr><td align="left">4KB (既定のサイズ)</td><td align="left">16TB</td></tr><tr><td align="left">8KB</td><td align="left">32TB</td></tr></tbody></table><p>クラスター サイズが拡張したいボリューム サイズに対応している場合の手順で、P70(16TB) のディスクを P80(32TB) に拡張した場合、16TB で作成済のボリュームのクラスター サイズはデフォルトと変わらず 4KB のままです。<br>そのため、この作成済の 16TB ボリュームを 32TB にしたい場合、 8KB のクラスター サイズが必要となるので、クラスター サイズが 4KBのままでは 32TB に拡張することができず、実際実行した場合以下のようにエラーメッセージが表示されます。</p><p><img src="/blog/vm/extend-data-disk-related-to-a-cluster-size/extend-data-disk-related-to-a-cluster-size-01.png">    </p><h4 id="クラスター-サイズの変更はフォーマットが伴う"><a href="#クラスター-サイズの変更はフォーマットが伴う" class="headerlink" title="クラスター サイズの変更はフォーマットが伴う"></a>クラスター サイズの変更はフォーマットが伴う</h4><p>上記の通り、32TB のボリュームを利用するためには、クラスター サイズを 8KB 以上に変更する必要がありますが、クラスター サイズを変更してしまうと、ボリュームのフォーマットが実施されることとなってしまいます。<br>（ P70(16TB) のディスク上でクラスター サイズを 8KB に変更してしまうと、データが消えてしまいます。）</p><h4 id="ディスク内の既存のデータに影響を与えない方法"><a href="#ディスク内の既存のデータに影響を与えない方法" class="headerlink" title="ディスク内の既存のデータに影響を与えない方法"></a>ディスク内の既存のデータに影響を与えない方法</h4><p>P80 のデータ ディスクを新規作成して仮想マシンに接続し、16TB 以上のサイズでボリュームを作成した上で、既存ボリューム上のデータを新規ボリュームにコピーします。<br>16TB ~ 32TB のサイズでボリュームを新規で作成した場合は、デフォルトのクラスター サイズが 8KB となるため、そのままご利用いただくことができます。</p><h3 id="手順-1"><a href="#手順-1" class="headerlink" title="手順"></a>手順</h3><h4 id="1-対応しているサイズのデータ-ディスクを新規作成して、仮想マシンにアタッチする"><a href="#1-対応しているサイズのデータ-ディスクを新規作成して、仮想マシンにアタッチする" class="headerlink" title="1. 対応しているサイズのデータ ディスクを新規作成して、仮想マシンにアタッチする"></a>1. 対応しているサイズのデータ ディスクを新規作成して、仮想マシンにアタッチする</h4><p><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/attach-managed-disk-portal">公開情報：マネージド データ ディスクを Windows VM に接続する - Azure - Azure Virtual Machines | Microsoft Docs</a></p><p>Azure portal にて、対象の VM を選択します。<br>左のメニューから [ディスク] を選択し、[新しいディスクを作成し接続する] を選択します。<br>[保存] を選択したら、新しいデータ ディスクの作成と VM への接続の完了です。</p><p><img src="/blog/vm/extend-data-disk-related-to-a-cluster-size/extend-data-disk-related-to-a-cluster-size-02.png"></p><h4 id="2-新規ボリュームを作成する"><a href="#2-新規ボリュームを作成する" class="headerlink" title="2. 新規ボリュームを作成する"></a>2. 新規ボリュームを作成する</h4><p><a href="https://support.microsoft.com/ja-jp/windows/%E3%83%8F%E3%83%BC%E3%83%89-%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF-%E3%83%91%E3%83%BC%E3%83%86%E3%82%A3%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E4%BD%9C%E6%88%90%E3%81%97%E3%81%A6%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%83%E3%83%88%E3%81%99%E3%82%8B-bbb8e185-1bda-ecd1-3465-c9728f7d7d2e">公開情報：ハード ディスク パーティションを作成してフォーマットする (microsoft.com)</a></p><p>まず、対象の VM に接続します。<br>まず、[スタート]  ボタンを右クリックし、 [コンピューターの管理] を開きます。<br>新規でアタッチしたディスクの上で右クリックし、[新しいボリューム]を選択し、希望のサイズで新規ボリュームを作成します。</p><p><img src="/blog/vm/extend-data-disk-related-to-a-cluster-size/extend-data-disk-related-to-a-cluster-size-03.png"></p><p>しばらくすると、フォーマットが完了し、ボリュームが新規作成されます。</p><p><img src="/blog/vm/extend-data-disk-related-to-a-cluster-size/extend-data-disk-related-to-a-cluster-size-04.png"></p><p>エクスプローラーでもボリュームが作成できたことを確認できます。</p><p><img src="/blog/vm/extend-data-disk-related-to-a-cluster-size/extend-data-disk-related-to-a-cluster-size-05.png"></p><h4 id="3-既存ボリューム上のデータを新規ボリュームにコピーする"><a href="#3-既存ボリューム上のデータを新規ボリュームにコピーする" class="headerlink" title="3. 既存ボリューム上のデータを新規ボリュームにコピーする"></a>3. 既存ボリューム上のデータを新規ボリュームにコピーする</h4><p><a href="https://learn.microsoft.com/ja-jp/windows-server/administration/windows-commands/robocopy">公開情報：robocopy | Microsoft Docs</a></p><p>新規ボリュームに既存のボリュームのデータをコピーします。</p><p>例）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">robocopy F:\ G:\ /copyall</span><br></pre></td></tr></table></figure><h4 id="4-既存ディスクをデタッチする"><a href="#4-既存ディスクをデタッチする" class="headerlink" title="4. 既存ディスクをデタッチする"></a>4. 既存ディスクをデタッチする</h4><p><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/detach-disk#detach-a-data-disk-using-the-portal">公開情報：Windows VM からデータ ディスクを切断する - Azure - Azure Virtual Machines | Microsoft Docs</a></p><p>Azure portal にて、対象の仮想マシンを選択します。<br>左のメニューから [ディスク] を選択し、既存のデータ ディスクの右端にある [X] ボタンを選択します。<br>[保存] を選択したら、既存のデータ ディスクが VM から接続解除されます。<br>※デタッチしたディスクはストレージに残ります。 ディスクが削除されるわけではありません。</p><p><img src="/blog/vm/extend-data-disk-related-to-a-cluster-size/extend-data-disk-related-to-a-cluster-size-06.png"></p><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>Azure Windows VM において、データ ディスク拡張前の Windows NTFS のクラスター サイズが、ディスク拡張後のボリューム サイズに対応していない際は、ディスクを拡張する方法にご留意ください。<br>本記事が、皆様の運用に役立つことを願っています。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポート チームの新見です。&lt;/p&gt;
&lt;p&gt;Azure Windows VM において、データ ディスクの拡張方法に関してお問い合わせをいただくことがあります。&lt;br&gt;今回はディスク拡張前の Windows NTFS のクラスター サイズ（アロケーション ユニットサイズ）が、ディスク拡張後のボリューム サイズに対応していない際に、ディスクを拡張する方法をご案内させていただきます。&lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Data Disk" scheme="https://jpaztech.github.io/blog/tags/Data-Disk/"/>
    
  </entry>
  
  <entry>
    <title>AKSのメモリ関連トラブルシューティング</title>
    <link href="https://jpaztech.github.io/blog/containers/aks-memory-troubleshoot/"/>
    <id>https://jpaztech.github.io/blog/containers/aks-memory-troubleshoot/</id>
    <published>2022-12-21T03:00:00.000Z</published>
    <updated>2023-01-10T02:14:50.348Z</updated>
    
    <content type="html"><![CDATA[<p>この記事は<a href="https://qiita.com/advent-calendar/2022/microsoft-azure-tech">Microsoft Azure Tech Advent Calendar 2022</a>の21日目の記事です。</p><p>Azureテクニカルサポートチームの高田です。</p><p>Azure Kubernetes Service(AKS)の運用に際して、メモリ関連の要因によりワークロードが期待通りに実行されない…という方向けに、下記の典型的な事例と対処方法を紹介させて頂きます。</p><ul><li>事例1: Podが配置・実行されない</li><li>事例2: 実行中のPodが終了され、Failed状態となる(または削除・再作成される)</li><li>事例3: 実行中のPodにてOOMKillが発生する</li></ul><span id="more"></span><h2 id="事例1-Podが配置・実行されない"><a href="#事例1-Podが配置・実行されない" class="headerlink" title="事例1: Podが配置・実行されない"></a>事例1: Podが配置・実行されない</h2><p>これは、新たに作成されたPodのメモリ要求(requests)を満たすノードが存在せず、Podがどのノードにも配置(スケジューリング)されない = 実行が開始されない、というものとなります。</p><p><a href="https://kubernetes.io/ja/docs/concepts/configuration/manage-resources-containers/#my-pods-are-pending-with-event-message-failedscheduling">Kubernetes の公式ドキュメント</a>でも同様の事例が紹介されておりますが、簡単に解説します。</p><p>PodがRunning状態とならず、<code>kubectl describe pod</code>コマンドにてStatusがPendingとなっており、Eventsが下記のような表示となっていた場合に、このケースに該当します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod &lt;pod名&gt;</span></span><br><span class="line">(略)</span><br><span class="line">Status:       Pending</span><br><span class="line">(略)</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age   From               Message</span><br><span class="line">  ----     ------            ----  ----               -------</span><br><span class="line">  Warning  FailedScheduling  7s    default-scheduler  0/3 nodes are available: 3 Insufficient memory.</span><br></pre></td></tr></table></figure><p>メモリ要求を満たすノードが存在しない、ということは、言い換えると、このPodをどのノードに配置しても、そのノード上のPodのメモリ要求の合計がそのノードの割当可能な(allocatable)メモリ量を超えてしまう、という意味となります。</p><p>実際には、メモリ「のみ」に関しては条件を満たすノードがあるものの、その他の条件(例:Pod のマニフェストにて指定されている配置条件、CPU等他リソースの状況、ノードのTaint等)により、それらを同時に満たすノードが存在しない、というケースもあります。</p><p>Podのメモリ要求値、各ノードのメモリ割り当て状況は、各々<code>kubectl describe pods</code> <code>kubectl describe nodes</code>コマンドで確認できます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod &lt;pod名&gt;</span></span><br><span class="line">(略)</span><br><span class="line">Containers:</span><br><span class="line">  podcontainer:</span><br><span class="line">    Image:      podimage</span><br><span class="line">    Port:       &lt;none&gt;</span><br><span class="line">    Host Port:  &lt;none&gt;</span><br><span class="line">    Requests:</span><br><span class="line">      memory:     2Gi                    &lt;- 2GiBのメモリを要求</span><br><span class="line">    Environment:  &lt;none&gt;</span><br></pre></td></tr></table></figure><p>この例では、Pod内のコンテナーに設定されているメモリ要求値が2Giになっています。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe node &lt;node名&gt;</span></span><br><span class="line">(略)</span><br><span class="line">Capacity:</span><br><span class="line">  cpu:                2</span><br><span class="line">  ephemeral-storage:  129886128Ki</span><br><span class="line">  hugepages-1Gi:      0</span><br><span class="line">  hugepages-2Mi:      0</span><br><span class="line">  memory:             4025844Ki          &lt;-ノードの全メモリは4,025,844KiB</span><br><span class="line">  pods:               30</span><br><span class="line">Allocatable:</span><br><span class="line">  cpu:                1900m</span><br><span class="line">  ephemeral-storage:  119703055367</span><br><span class="line">  hugepages-1Gi:      0</span><br><span class="line">  hugepages-2Mi:      0</span><br><span class="line">  memory:             2209268Ki          &lt;-Podに割当可能なメモリは2,209,268KiB</span><br><span class="line">  pods:               30</span><br><span class="line">(略)</span><br><span class="line">Allocated resources:</span><br><span class="line">  (Total limits may be over 100 percent, i.e., overcommitted.)</span><br><span class="line">  Resource           Requests     Limits</span><br><span class="line">  --------           --------     ------</span><br><span class="line">  cpu                430m (22%)   4500m (236%)</span><br><span class="line">  memory             310Mi (14%)  3286Mi (152%)    &lt;- 310MiB (Allocatable の14%) が割当済み</span><br><span class="line">  ephemeral-storage  0 (0%)       0 (0%)</span><br><span class="line">  hugepages-1Gi      0 (0%)       0 (0%)</span><br><span class="line">  hugepages-2Mi      0 (0%)       0 (0%)</span><br><span class="line">Events:              &lt;none&gt;</span><br></pre></td></tr></table></figure><p>ノードに残されている割当可能なメモリ2209268Ki - 310Mi よりもPodの要求値 (2Gi) が大きいため、このノードには配置できない、ということがわかります。</p><p>ここでご注意頂きたい点として、配置時に関しては、ノード上で実際に使用されているメモリ量、Pod/コンテナーが実際に使用しているメモリ量は直接関係なく、あくまでもPod/コンテナーが(マニフェスト内の指定にて)<strong>要求する</strong>メモリ量、ノード上のそれらの<strong>要求</strong>の合計により判定される、というものがあります。<br>ノード上の既存のPod/コンテナーが実際にはほとんどメモリを使用していない場合でも、それらの<strong>要求</strong>値が高い場合には、配置時の観点ではそのノードは「メモリに余裕がない」扱いとなります。<br>この問題のトラブルシューティングの際には、(後述するワーキングセットメモリの監視など)実際のメモリ使用量ではなく、<strong>要求</strong>量を確認しましょう。</p><h3 id="対処方法"><a href="#対処方法" class="headerlink" title="対処方法"></a>対処方法</h3><p>これを解消するには、メモリ割り当てに余裕のあるノードを確保するか、あるいは、Podのメモリ要求を既存のノードで賄える程度まで小さくする必要があります。</p><p>前者に関しては、不要なPodの削除による割り当ての開放、または、<a href="https://learn.microsoft.com/ja-jp/azure/aks/use-multiple-node-pools#scale-a-node-pool-manually">ノードプールのスケーリング</a>、<a href="https://learn.microsoft.com/ja-jp/azure/aks/use-multiple-node-pools#add-a-node-pool">ノードプールの追加</a>、<a href="https://learn.microsoft.com/ja-jp/azure/aks/resize-node-pool">ノードのVMサイズの変更</a>、等によるノードの増強、といった方法があります。</p><p>後者に関しては、Pod のメモリ要求の値、すなわち、Podのマニフェストの<code>spec.containers[].resources.requests.memory</code>の値を減らすこととなります。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="string">(略)</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">podimage</span></span><br><span class="line"><span class="string">(略)</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">2Gi</span> <span class="comment"># &lt;- これを減らす</span></span><br></pre></td></tr></table></figure><p>ただし、Podが実際に使用するメモリ量を考慮せずにこの値を減らした場合、後述するOOMKillやEvictが発生するリスクが生じますのでご注意下さい。</p><h3 id="補足-詰め込みの是非"><a href="#補足-詰め込みの是非" class="headerlink" title="補足:詰め込みの是非"></a>補足:詰め込みの是非</h3><p>Podのメモリ要求に対して必要最小限のノードにてAKSクラスターを運用したい、という方も多いかと思います。<br>しかしながら、平常時にて未割当のメモリが少ない場合、Deployment の更新によるローリングアップデートの際等に、メモリが割当不能になるリスクがあります。</p><p>AKSでは、ユーザのPodの他に、CoreDNS等のシステムPodが配置され、動作しています。<br>これらは随時アップデートが行われることがあります。<br>また、AKSに関するアドオンの有効化等により、システムPodが追加で配置されることもあります。<br>このとき、既に各ノードのメモリのほぼ全てが割り当てられていた場合、システムPodの配置失敗や、システムPodの配置のために既存Podが<a href="https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/#preemption">Preemption</a>の対象となることがあり得ます。<br>このような事態を避けるため、少なくとも<a href="https://learn.microsoft.com/ja-jp/azure/aks/use-system-pools?tabs=azure-cli">システムノードプール</a>内のノードに関してはある程度の余裕を確保することをご検討下さい。</p><p>ちなみに、配置の際にはCPUとメモリの扱いに本質的な違いはないので、上記の考え方はCPUに関してもそのまま適用可能です。</p><h2 id="事例2-実行中のPodが終了され、Failed状態となる-または削除・再作成される"><a href="#事例2-実行中のPodが終了され、Failed状態となる-または削除・再作成される" class="headerlink" title="事例2: 実行中のPodが終了され、Failed状態となる(または削除・再作成される)"></a>事例2: 実行中のPodが終了され、Failed状態となる(または削除・再作成される)</h2><p>これは、実行中のPodがノードのメモリ不足によりEvict(退去)の対象となった場合に発生します。<br><code>kubectl describe pod</code>コマンドの結果にて下記のような記録があった場合にこのケースに該当します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod &lt;pod名&gt;</span></span><br><span class="line">(略)</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason               Age   From     Message</span><br><span class="line">  ----     ------               ----  ----     -------</span><br><span class="line">(略)</span><br><span class="line">  Warning  Evicted              110s  kubelet  The node was low on resource: memory. Container &lt;container名&gt; was using 3256Ki, which exceeds its request of 2048Ki.</span><br><span class="line">  Normal   Killing              110s  kubelet  Stopping container &lt;container名&gt;</span><br></pre></td></tr></table></figure><p>Podのマニフェストに記載するメモリ要求(<code>spec.containers[].requests.memory</code>)はあくまでも「予算」のようなものであり、Podはこの値を超えてメモリを確保・使用できます。<br>このため、要求の合計がノードの割当可能なメモリ量の範囲に収まるようにPodが配置されていても、それらのPod(の一部)が要求値を超えてメモリを確保・使用した場合には、ノードにてメモリ不足が発生します。<br>このとき、要求を超えてメモリを使用しているPodの中から、Podに設定されている優先等を考慮して選択されたものが<a href="https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/">evict</a>(退去)されます。<br>(メモリ使用量が急激に増加した場合など、Evictが発生せずに後述するOOMKillが発生する場合もあります)</p><h3 id="対処方法-1"><a href="#対処方法-1" class="headerlink" title="対処方法"></a>対処方法</h3><p>メモリ不足によるEvictを防ぐには、ノード上でメモリ不足が発生しないようにする必要があります。<br>必ずしもPod・コンテナーが使用するメモリの最大値を要求に記載する必要はありませんが、Pod・コンテナーのメモリ使用量が定常的に要求値を超える場合は、そのようなPodの要求値(Podマニフェスト中の<code>pod.spec.containers[].resources.requests.memory</code>の値)をより大きなものに変更することで、対象のPodがよりメモリ割当に余裕のあるノードに配置されることとなり、ノード上でのメモリ不足が発生しにくくなります。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">(略)</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: podimage</span><br><span class="line">(略)</span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        memory: 1Gi # &lt;- これを増やす</span><br></pre></td></tr></table></figure><p>なお、この変更によりPodの配置が行えなくなる可能性もありますので、必要に応じて「Podが配置・実行されない」のトラブルシューティングも実施しましょう。</p><h3 id="補足-コンテナー分析情報"><a href="#補足-コンテナー分析情報" class="headerlink" title="補足:コンテナー分析情報"></a>補足:コンテナー分析情報</h3><p>実際のノードやPod・コンテナーのメモリ消費量は、<a href="https://learn.microsoft.com/ja-jp/azure/azure-monitor/containers/container-insights-enable-aks?tabs=azure-cli">コンテナー分析情報</a>を有効にすることで監視できます。</p><p>コンテナー分析情報は、AzureポータルのAKSクラスターの画面中、「監視」内「分析情報」のタブから利用できます。<br>コンテナー分析情報ではRSS(プロセスが直接明示的に使用しているメモリ領域の大きさ)とワーキングセット(RSS以外の、ファイルキャッシュ等の間接的なメモリ消費を含んだ値)を確認できますが、Evictや後述するOOMKillはワーキングセットに基づいて行われますため、メモリ不足発生の有無の観点ではワーキングセットを確認するようにしましょう。</p><p><img src="/blog/containers/aks-memory-troubleshoot/aks-memory-troubleshoot01.png" alt="ノードのワーキングセット"><br><img src="/blog/containers/aks-memory-troubleshoot/aks-memory-troubleshoot02.png" alt="Pod/コンテナーのワーキングセット"></p><h2 id="事例3-実行中のPodにてOOMKillが発生する"><a href="#事例3-実行中のPodにてOOMKillが発生する" class="headerlink" title="事例3: 実行中のPodにてOOMKillが発生する"></a>事例3: 実行中のPodにてOOMKillが発生する</h2><p>OOM(Out Of Memory)Kill は、ノードに配置され実行中のPodによるメモリ使用量が「制限値」を超過した(正確には、超過してメモリを使用しようとした)ときに発生します。</p><p><code>kubectl describe pod</code>コマンドにて、 Last State 等のReasonに”OOMKilled”と書かれている場合が該当します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe pod &lt;pod名&gt;</span><br><span class="line">(略)</span><br><span class="line">Containers:</span><br><span class="line">(略)</span><br><span class="line">    Last State:     Terminated</span><br><span class="line">      Reason:       OOMKilled</span><br><span class="line">      Exit Code:    1</span><br><span class="line">      Started:      Fri, 16 Dec 2022 09:57:41 +0000</span><br><span class="line">      Finished:     Fri, 16 Dec 2022 09:57:44 +0000</span><br><span class="line">    Ready:          False</span><br><span class="line">    Restart Count:  1</span><br></pre></td></tr></table></figure><p>制限値には、Pod/コンテナーレベルのものと、ノードレベルのものがあります。<br>(ノード上でのPod合計のメモリ使用量増加する=ノードがメモリ不足となる場合は前項で解説したEvictも発生し得ますが、メモリ増加ペース等によりEvictが発生せずいきなりOOMKillとなる場合もあります)<br>ノード全体のメモリ使用量等から、どちらの制限値に抵触したか判断可能な場合が多いですが、後述の、OOMKillの詳細情報にて判断することも可能です。</p><h3 id="Pod-コンテナーレベルのOOMKillの原因と対処方法"><a href="#Pod-コンテナーレベルのOOMKillの原因と対処方法" class="headerlink" title="Pod/コンテナーレベルのOOMKillの原因と対処方法"></a>Pod/コンテナーレベルのOOMKillの原因と対処方法</h3><p>Pod/コンテナーレベルのOOMKillは、Podのマニフェスト中、<code>spec.containers[].resources.limits.memory</code>にてメモリ制限値が指定されていた場合に、Pod/コンテナーのメモリ使用量がこれに抵触することで発生します。</p><p>したがって、Pod/コンテナーレベルのOOMKillが発生した場合、その原因はPod/コンテナーのメモリ使用量に問題がある(=Pod/コンテナー内アプリケーションの何らかの異常等により、メモリ使用量が想定を超えて増大している)か、メモリ制限値に問題がある(=Pod/コンテナー内のワークロードの使用するメモリ量を低く見積もり過ぎている)か、のどちらかとなります。</p><p>ワークロードの種類によっては判断が難しい場合もありますが、もしメモリ制限値が厳しすぎた可能性があると考える場合は、limitsの値を増やしましょう。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">(略)</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: podimage</span><br><span class="line">(略)</span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        memory: 500Mi</span><br><span class="line">      limits:</span><br><span class="line">        memory: 1Gi  # &lt;- これを増やす</span><br></pre></td></tr></table></figure><p>なお、Pod/コンテナーのメモリ使用量はワーキングセット(RSS以外のファイルキャッシュ等も<br>含んだ値)に関して評価されます。<br>psコマンド等で確認できるプロセスのメモリ使用量(RSS)の合計よりも大きな値となりますので、コンテナー分析情報等にてワーキングセットの値も確認しましょう。</p><h3 id="ノードレベルのOOMKillの原因と対処方法"><a href="#ノードレベルのOOMKillの原因と対処方法" class="headerlink" title="ノードレベルのOOMKillの原因と対処方法"></a>ノードレベルのOOMKillの原因と対処方法</h3><p>ノードレベルにて、「割当可能なメモリ量」の値 + evictionのための猶予値が制限値として設定されているため、これに抵触した場合に(たとえPod/コンテナーレベルの制限値に抵触しなくても)OOMKillが発生します。</p><p>この場合、原因はメモリ不足によるEvictと同様のため、対処方法も同様に各Podのメモリ要求の見直しと、必要に応じたノードの増強等となります。</p><h3 id="補足-OOMKillの詳細情報"><a href="#補足-OOMKillの詳細情報" class="headerlink" title="補足: OOMKillの詳細情報"></a>補足: OOMKillの詳細情報</h3><p>OOMKillはLinux Kernelのメモリ関連機能である<a href="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v1/memcg_test.html">memcg</a>により駆動されるため、発生時のカーネルメッセージを参照することでさまざまな情報が得られます。<br>例えば、下記メッセージ中のoom_memcgにはOOMKillの原因となった制限値が設定されていたmemcg(memory cgroup、プロセスの集合)が記載されているため、これが下記のように<code>/kubepods</code>となっていた場合はノードレベルのOOMKill、 <code>/kubepods/....</code>と続いていた場合はPod/コンテナーレベルのOOMKillとなります。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dec 16 09:37:31 aks-nodepool1-32235639-vmss000002 kernel: [376723.579928] oom-kill:constraint=CONSTRAINT_MEMCG,nodemask=(null),cpuset=d9a4f01c5cfe15ee88972f51557b3395ea6f8d0f31a93d7ef19c64459085a156,mems_allowed=0,oom_memcg=/kubepods,task_memcg=/kubepods/besteffort/pod325d3265-721f-4032-a97b-b3caa6e51859/d9a4f01c5cfe15ee88972f51557b3395ea6f8d0f31a93d7ef19c64459085a156,task=stress,pid=2268420,uid=0</span><br></pre></td></tr></table></figure><p>この他、メッセージにはOOMKillが発生したときのメモリ使用状況等も含まれており、これがメモリ使用内訳の調査等にも役に立つことがあります。<br>カーネルメッセージは、ノードの<code>/var/log/syslog</code>等に記録されるため、 <a href="https://learn.microsoft.com/ja-jp/azure/aks/node-access">ノードにログイン</a>した後に <code>/host/var/log/syslog</code>等を参照することで確認できます。</p><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>AKSはワークロードの配置や実行、問題発生時の復旧を自動的に行ってくれる一方、与える情報や設定が不十分であったり、実態と乖離した場合には予期しない動作となることもあります。<br>今回ご紹介した事例が、皆様のAKSの運用に役立つことを願っています。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;この記事は&lt;a href=&quot;https://qiita.com/advent-calendar/2022/microsoft-azure-tech&quot;&gt;Microsoft Azure Tech Advent Calendar 2022&lt;/a&gt;の21日目の記事です。&lt;/p&gt;
&lt;p&gt;Azureテクニカルサポートチームの高田です。&lt;/p&gt;
&lt;p&gt;Azure Kubernetes Service(AKS)の運用に際して、メモリ関連の要因によりワークロードが期待通りに実行されない…という方向けに、下記の典型的な事例と対処方法を紹介させて頂きます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事例1: Podが配置・実行されない&lt;/li&gt;
&lt;li&gt;事例2: 実行中のPodが終了され、Failed状態となる(または削除・再作成される)&lt;/li&gt;
&lt;li&gt;事例3: 実行中のPodにてOOMKillが発生する&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Containers" scheme="https://jpaztech.github.io/blog/tags/Containers/"/>
    
    <category term="Azure Kubernetes Service (AKS)" scheme="https://jpaztech.github.io/blog/tags/Azure-Kubernetes-Service-AKS/"/>
    
  </entry>
  
  <entry>
    <title>Microsoft Azure の歴史</title>
    <link href="https://jpaztech.github.io/blog/other/azure_history_and_career_in_support/"/>
    <id>https://jpaztech.github.io/blog/other/azure_history_and_career_in_support/</id>
    <published>2022-12-14T03:00:00.000Z</published>
    <updated>2023-01-10T02:14:50.396Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure サポータビリティチームの平原です。現在、私はグローバルエスカレーションチームに所属しており、世界の各国からのエスカレーションや、サポートプロセス改善、製品改善について仕事していますが、2010 年の Azure リリース当初から一貫してビジネスに関わってきました。</p><p>今回は通常の技術ブログとは毛色が異なる内容となりますが、2022 年 12 月の Advent Calender 用に、 Microsoft Azure の歴史 (主にコンピュートとネットワークのコアサービス観点)、私の仕事やキャリアの話を絡めてお話しできたらな、と思います。私の所属がサポートですので、恐縮ながらその観点での記述が多くなってしまいますが、少しでもクラウドコンピューティングに関わる方々の参考になれば幸いです。また Microsoft もしくは外資系でサポートエンジニアを考えられている方は、どういう仕事をするのかも、参考になるのではと思います。</p><h2 id="黎明期-2008-–-2012"><a href="#黎明期-2008-–-2012" class="headerlink" title="黎明期 (2008 – 2012)"></a>黎明期 (2008 – 2012)</h2><p>現在 Microsoft Azure と呼ばれているもののコアとなるサービスは、2008 年の PDC (Professional Developer Conference) にて初めて公に発表されました。コードネームは Reddog 、私もおぼろげながらの当時の印象は、インターネット上にある Windows OS/Server という印象でした。当時私はデベロッパーサポートにおり、C/C++/C# のコンパイラーやライブラリ、.NET Framework や Visual Studio、開発アドバイスの技術者支援をしておりました。サポートエンジニアというポジションで、主にお客様からの .NET や Visual Studio を使った際の開発時の質問やアドバイスをする仕事でした。今のサポートエンジニアも製品は違えど、基本的にはお客様からの質問を電話・メールでお受けして、対応するというものです。その当時の私が、まさか自分が Azure を担当することになるとは全く思っていませんでした。</p><p>2009 年の暮れごろでしょうか、当時の私のマネージャーから打診があり、新サービスのサポートをしてみないかとのことでした。それが Azure であり、当時言われたこととして覚えているのは、「全く新しいものなので、もしかしたら今のチームには戻れないかもしれない」、という話でした。当時の印象では、「インターネット上の Windows OS/Server」という認識しかなかったものの、内容自体は面白そうでしたので、二つ返事で引き受けました。その後、まさか本当に元の担当に戻らずに、それから 10 年以上も Azure のビジネスに関わる仕事をすることになるとは、その時は、全く考えていませんでした。その後、すぐに米国での出張が手配されトレーニングが開始され、Beta エンジニアとしてまず 1 人から Beta サポートを開始したのでした。</p><p>2010 年秋ごろになり、Azure が Beta から正式リリースされました。当初「Windows Azure」という製品名でリリースされ、主に 4 つのサービスからスタートしました。これらは、Cloud Service (当時の名前では Hosted Service )、SQL Azure、Storage Service、AppFabric (Service Bus、Access Control Service; ACS など)です。すべて、PaaS のサービスであり、当初の利用方法はユーザーに Visual Studio を利用して、.NET ベース テクノロジーで配置パッケージを作成してもらい、それを Azure 上にアップデート・配置して使ってもらう、という形でリリースされました。今から考えると、当時の PaaS サービスは少し時代を先取りしすぎており、またアプリケーションの乗り換え (マイグレーション) のハードルがかなり高かったのだと思います。</p><p>Microsoft では、この期間、上記サービスをベースに様々な面から継続的な機能拡張をしており、トラブルシュート用に RDP 機能を追加したり、OS の初期構成できるようになったり、VM Role (ユーザーが自身でイメージを作成してそれをイメージとして利用) が Beta として利用できるようになったりとしましたが、依然IaaS の要望は根強かったように感じます。</p><blockquote><p>補足：Cloud Service 上に展開できたVM Roleは、IaaS製品とは違い事前に作成したイメージから仮想マシンが作成されますが、仮想マシン内部に恒久的なデータを保存できません (non-persistent)。恒久的なデータは別途ストレージサービス等に保存する必要があります。 </p></blockquote><p>サポートチームの観点で言うと、当時はまだチームの規模も小さいものでした。営業チームやマーケティングチームとも案件関連で頻繁にやり取りしており、パートナー支援・営業支援、他企業とアライアンスなどもあり、それらも含め様々やり取りが多かったです。その当時かかわったお客様・社内の皆さんには大変お世話になりました。また、ご利用いただくお客様はほぼ固定化されており、お客様とも仲良くなったりして対応を進めていましたが、新規のお客様はなかなかに開発コンセプトを受け入れていただくのは難しそうでした。オンプレミスのサービスを移行するとなると、イメージとして一番しやすいのは、IaaS 製品をイメージするようで、「OS を自分で構成したい」、というお客様が多い印象でした。PaaS 環境は基本的に、OS はサービスプロバイダー (Azure の場合は Microsoft) が管理しており、ユーザー側でカスタマイズするというのは当初は NG でした (後ほど機能拡張で構成する方法がリリースされます)。PaaS のようにパッケージと構成ファイルを作ってデプロイする、というのは、かなりのパラダイムシフトが必要なようでした。しばらくして 2012 年ごろには、自ら進んで名乗りを上げてくれた意欲のある同僚や、興味を持ってサポートチームに新しく入社した方、マネージャーとで比較的小さなサイズでサポートチームは運営されていました。</p><p>余談ですが、2010 年は「日本のクラウド元年」と呼ばれています。各所でクラウド関連のイベントや社内マーケティングイベントなどがあり、私も何度か参加したりはしましたが、まだ当時は一部のアーリーアダプターで使われている状況であり、世の中広く使われているとはいいがたい状況でした。当時、「クラウドコンピューティング」に関するトレーニングにも参加してみたのですが、既存のホスティングサーバービジネスを焦点においた話題が多く、あまり概念として社会で固定化されていなかったのではと思います。文字や定義という意味では、Eric Schmidt が 2006 年に言及した Cloud Computing という概念 (*1) や、NIST の Cloud Computing の定義 (*2) などもその当時からもありました。10 年以上経って 4 度にわたるポータルの変遷などを経て、現在、此処其処で利用されている状況を見ると、それがイメージできるようになるのは、ある程度、時間をかけた市場でのデザインの洗練化が必要なものだったのかもしれません。</p><p>*1 <a href="https://www.technologyreview.com/2011/10/31/257406/who-coined-cloud-computing/">MIT Technology Review - Who coined ‘Cloud Computing’</a></p><p>*2 <a href="https://csrc.nist.gov/publications/detail/sp/800-145/final">The NIST Definition of Cloud Computing</a></p><p>また当時日本マイクロソフト株式会社独自のマーケティング施策の一環として「クラウディア」というキャラクターがいましたが、古くから Azure に携わられている方には覚えている方もいらっしゃるかもしれません。社員がコミックマーケットに参加したりなどして、コミュニティ活動では JAZUG (Japan Azure User Group) 活動 (*3) があったりと、日本マイクロソフトとしては、自由な発想で様々な活動しておりました。</p><p>*3 <a href="https://r.jazug.jp/">Japan Azure User Group</a></p><h2 id="転換期-2013-–-2015"><a href="#転換期-2013-–-2015" class="headerlink" title="転換期 (2013 – 2015)"></a>転換期 (2013 – 2015)</h2><p>2013 年から 2015 年までの期間は Azure と Microsoft にとっても、大きなニュースが多いのではないかと思います。</p><p>2013 年にリリースされた IaaS 関連の製品群である仮想マシン (Virtual Machine: Persistent VM Role) や仮想ネットワーク (Codename: Brooklyn) は製品としてかなり大きな転換となる製品でした。これまでの PaaS 製品群では OS 内部にデータを保存しても、再イメージ化などでOSの内部がリフレッシュされデータが削除されてしまうものでしたが、IaaS 仮想マシンでは、指定されたディスク内に恒久データの保存が可能になりました。仮想ネットワークでは、それまではロードバランサーから直接仮想マシンに接続していたものが、(ある程度は制約がありましたが) 多くのユーザーが直接仮想マシンやネットワークを操作・構成できるようになりました。また、仮想ネットワークを構成することにより、関連するコンピュートリソースをネットワーク的に分離することが可能となり、VPN や専用線 (Express Route) 等も使ってより自由度が高く、複雑なネットワーク構成が可能となりました。</p><p>2013 年には、Backup サービスや復旧サービス (Recovery Service) などが提供開始されました。それ以前にはバックアップする場合には、ストレージデータのコピーにて対応していたものが、バックアップの観点で可用性のオプションが増えました。</p><p>2014 年には、日本では新たにデータセンターが開設になりました。お客様によっては、データを日本国内に配置しなければいけないビジネス要件等もあるため、日本にデータをおけないことに懸念を示すお客様にとっては大きな朗報になったと思います。またこの年は、Azure の名称が Windows Azure から Microsoft Azure に変更になりました (*4)。</p><blockquote><p>Today we are announcing that Windows Azure will be renamed to Microsoft Azure, beginning April 3, 2014. This change reflects Microsoft’s strategy and focus on Azure as the public cloud platform for customers as well as for our own services Office 365, Dynamics CRM, Bing, OneDrive, Skype, and Xbox Live. Our commitment to deliver an enterprise-grade cloud platform for the world’s applications is greater than ever.  ..</p></blockquote><p>*4 <a href="https://azure.microsoft.com/en-us/blog/upcoming-name-change-for-windows-azure/">Upcoming Name Change for Windows Azure</a></p><p>ただの名称変更のようにも見えるのですが、これは Azure が Microsoft にとって今後の戦略的位置付けになる決意表明のようなものでもありました。「Windows Azure」は、当初のコンセプトとして Windows テクノロジーとの結びつきが強いものでしたが、2010 年代から Microsoft はオープンソース活動にもかなり力を入れていました。実際、仮想マシンでも Linux OS を利用することが可能でした。Windows だけでなく、他社開発プロバイダーやオープンソース業界含めたプラットフォームとなる決意でありました。</p><p>またいろいろなサービスがより様々なサービスが Azure の名のもとにオンライン展開、再ブランディングされていくことになります。特に新たなサービスとして、Azure Active Directory (AAD) や AI 関連の技術 (Machine Learning) なども、この時期に登場しています。</p><p>2015 年に 4 代目となる現在のポータル (Codename: Ibiza, 2022 現在のポータル) がリリースされ、Azure のリソース管理システムも Azure Resource Manager (ARM) をベースとしたリソース管理システムに移行しました。それ以前は RDFE (Reddog Frontend)、Azure Service Management (ASM) と呼ばれるものでリソース管理されていましたが、Role Base Access Control (RBAC) によるユーザー管理などがなく、非常に限られたユーザー権限でしか操作ができず、またリソース管理機能も内部的な制限が多かったため、この ARM による新しいリソース管理システム、および、AAD のユーザーにより、Azure リソース管理の自由度がかなり上がりました。</p><p>また仮想マシンの可用性の観点で言えば、以前はホスト OS のメンテナンスが定期的に停止を伴うものでありましたが、2013 年ごろからメモリ保護メンテナンス (Memory-Preserving Maintenance) (*5) や、新たに Live Migration (*5) なども導入し始め、現状では一部の大きなメンテナンスを除き、大きな停止のないメンテナンスが主流となっています。可用性面については、外部のお客様の声を真摯に受け止めて製品改善を進めていきました。この点は、サポートチームによるお客様の声のフィードバックと、継続的な製品改善プロセスが大きく貢献したと思います。</p><p>*5 <a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-and-updates#maintenance-that-doesnt-require-a-reboot">Azure での仮想マシンのメンテナンス - 再起動を必要としないメンテナンス</a></p><p>サポート部門では、この当時、私も IaaS 製品が Beta の頃にちょうど米国での出張が重なりサポート体制の刷新や、新たな製品サポートの準備をしていました。当時はまだサポート部門としては小さくはありましたが、各人やる気に満ち溢れていました。私自身はリードとして、課金のシステムからコンピュート系のサービスにわたるまで見ていましたが、ここから急激に拡大していくことになり、サポートのチームの体制もより大きなものに変わっていきます。</p><p>Azure とは直接関係はありませんが、2014 年に Satya Nadera が新しい Microsoft の CEO になりました。対外的にもニュースになりましたが、これに伴って Microsoft のカルチャーが大きく変わる転換点となりました。このあたりの話は、Satya 自身が「Hit Refresh」という本を出して当時の状況についても説明しているので、ここで言及するよりも、そちらを読むことをお勧めします。Microsoft Teams が社内ハッカソンにて構築されたのは有名な話ではありますが、このカルチャーの転換がイノベーションの誘発に少なからず関連しているのではと思います。</p><h2 id="成長期-2016年-–-現在"><a href="#成長期-2016年-–-現在" class="headerlink" title="成長期 (2016年 – 現在)"></a>成長期 (2016年 – 現在)</h2><p>これ以降はさらに Azure が様々製品に拡張されていっており、新たな機能拡張や新製品の提供などを継続しています。コンピュート系の話題で言えば、ユーザー自身で再デプロイ (Redeploy: 2016) が実装されたり、Azure Monitor / Resource Health (2017)、管理ディスク (Managed Disk: 2017)、Azure Kubernetes Services (2018)、VM 用Serial Console (2018)、可用性 ゾーン (Azure Availability Zone: 2018)、専用ホスト (Dedicated Host: 2019) 等々、可用性と拡張性をベースに機能拡張されています (もちろんこれ以外にもたくさんの製品が出ています)。またこれからさらに多くのサービスが Azure 上に展開されてくるのではないかと思います。</p><p>サポート観点からは IaaS、Network、データベース、AI 系、など複数の部門に分かれ、Microsoft 365 のサポートも含めると、現在は多くの人がオンライン製品系のサポートに従事するようになっています。</p><h2 id="補足：テクニカルサポートについて"><a href="#補足：テクニカルサポートについて" class="headerlink" title="補足：テクニカルサポートについて"></a>補足：テクニカルサポートについて</h2><p>また、最後にせっかくの機会なので、テクニカルサポートの宣伝をさせていただこうと思います。</p><p>以上、みていただいた通り、テクニカルサポートエンジニアの仕事は多岐にわたり、もちろん電話・メール・Web を使っての技術支援をしますが、それと同時に製品改善やチーム貢献の機会があり、自分から申し出れば (それがビジネス上有用であれば)、新しい取り組みを自分で始めることも可能です。単純にサポート担当の窓口として人を置いているわけではなく、戦略的な位置付けとしてチームを配置しお客様へお役に立つ情報の提供や、トラブルシュート、製品改善に役立てています。また製品のスペシャリストになれるので (場合によっては社内で一番)、その後キャリアを積むうえでも利点が多く、コンサルティングやテクニカルセールス、営業 (アカウントマネージャー)、ピープルマネージャー、開発部門、海外のサポートチーム、等々、多くの方が当サポートエンジニアの仕事を経験したうえで、社内外で活躍されています。</p><p>一方、最近はなかなか先を見通すことができない時代になってきており、実際、クラウドに対するサポート体制が各社でここまで大きく転換をするというのは、2009 年当時、どなたも想像もできていなかったのではと思います。これはおそらく今後も同じで、キャリアを考える上では、「どれが正解」というのが見えづらくなっており、まだ見ぬ製品やサービス・新たな形態でのビジネスが登場してくることも考えられ、むしろキャリアの方向性をよりレジリエントかつ柔軟に考える必要があるのかなと思います。最近の話題として、AIの発展により一部職業がなくなるのではという話があります。テクニカルサポートに関して言うと、将来的にAIが発展しても、一部サポートオペレーションは自動化をできる可能性はもちろんあります。しかし、我々の取り扱う内容は基本的に「人」をベースとしたものであり、技術的に複雑な未知の問題、表出されて来なかった要望、などについては、継続して人の手を介する必要があり、今後はより専門性と問題把握力、コミュニケーション力が必要になっていくものになるのではと思います。</p><p>ご本人の嗜好や方向性もあるので、一概にすべての方におすすめできる仕事ではありませんが、長年の経験から技術職の1つの可能性として考えていただくのもよいのかなと思います。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure サポータビリティチームの平原です。現在、私はグローバルエスカレーションチームに所属しており、世界の各国からのエスカレーションや、サポートプロセス改善、製品改善について仕事していますが、2010 年の Azure リリース当初から一貫してビジネスに関わ</summary>
      
    
    
    
    
    <category term="Other" scheme="https://jpaztech.github.io/blog/tags/Other/"/>
    
    <category term="Support Explained" scheme="https://jpaztech.github.io/blog/tags/Support-Explained/"/>
    
    <category term="IaaS" scheme="https://jpaztech.github.io/blog/tags/IaaS/"/>
    
    <category term="Microsoft Azure" scheme="https://jpaztech.github.io/blog/tags/Microsoft-Azure/"/>
    
  </entry>
  
  <entry>
    <title>Azure IaaS VM で実施されるメンテナンスについて</title>
    <link href="https://jpaztech.github.io/blog/vm/vm-maintenance/"/>
    <id>https://jpaztech.github.io/blog/vm/vm-maintenance/</id>
    <published>2022-10-16T13:40:00.000Z</published>
    <updated>2023-01-10T02:14:50.792Z</updated>
    
    <content type="html"><![CDATA[<p>Azure テクニカル サポートチームの鳥越です。</p><p>Azure をご利用いただいているお客様の中にはメンテナンスによる影響を経験された方もいらっしゃるかと存じます。<br>クラウド環境として、新機能の導入や更なる安定稼働を進めていく上で、このメンテナンスは必要不可欠なものです。<br>しかしながら、このメンテナンスといった言葉の中には、どのようなメンテナンスなのかがよくわからないといったご不安もあるかと推察します。</p><span id="more"></span><p>このような背景もあり、メンテナンスについて、またその影響について可能な限り補足させていただければと、このブログ記事を執筆しました。少しでも本内容がお客様のAzureに対する安心と信頼につながれば幸いでございます。<br>※ なお、今回は IaaS のメンテナンスを中心に記載しております。</p><hr><h2 id="■-そもそもメンテナンスとは何か"><a href="#■-そもそもメンテナンスとは何か" class="headerlink" title="■ そもそもメンテナンスとは何か ?"></a>■ そもそもメンテナンスとは何か ?</h2><p>例えば、オンプレミス環境で言えば、ハードウェア廃止による機材の入れ替えや冗長化などの構成変更、物理的な電気系統の検査、サーバーやネットワーク機器のセキュリティを含む Firmware アップデートなどが該当するかと考えます。</p><p><em>余談ですが、私が以前、オンプレミス環境のサポートを行っていた際には、このような　Firmware のアップデートは深夜の業務停止時間帯に数時間確保した上で計画的実施されておりました。しかし、この Firmware のアップデートは必ずうまくいくといった保証もなく、失敗した際のリカバリ対応も多く経験しました。</em></p><hr><h2 id="■-Azure-環境ではどのように考えるべきか"><a href="#■-Azure-環境ではどのように考えるべきか" class="headerlink" title="■ Azure 環境ではどのように考えるべきか ?"></a>■ Azure 環境ではどのように考えるべきか ?</h2><p>Azure 環境は、物理ホスト サーバー群とその上で複雑に制御された機能をつかさどる各プロセスが稼働しています。また、これらをつなぐネットワーク機器や物理ホスト サーバー群を管理するための機能といった様々なコンポーネントが存在します。</p><p>Azure では、定期的にこのようなプラットフォームを更新して、仮想マシン (VM) のホスト インフラストラクチャーの信頼性、パフォーマンス、セキュリティの向上に努めています。これらの更新の目的は、ホスティング環境のソフトウェア コンポーネントの新機能追加、修正から、ネットワーク コンポーネントのアップグレード、ハードウェアの使用停止まで、広い範囲に及びます。</p><hr><h2 id="■-どのようなメンテナンスがあるか"><a href="#■-どのようなメンテナンスがあるか" class="headerlink" title="■ どのようなメンテナンスがあるか ?"></a>■ どのようなメンテナンスがあるか ?</h2><p>VM における再起動の有無により、大きく分けて、以下の 2 種類が考えられます。</p><ul><li>再起動を必要とするメンテナンス</li><li>再起動を必要としないメンテナンス</li></ul><hr><h2 id="■-再起動を必要とするメンテナンスとは"><a href="#■-再起動を必要とするメンテナンスとは" class="headerlink" title="■ 再起動を必要とするメンテナンスとは ?"></a>■ 再起動を必要とするメンテナンスとは ?</h2><p>再起動を必要とするメンテナンスは、計画メンテナンスとも呼ばれ、VM の再起動を伴うためにお客様に対して事前に通知が行われます。<br>セルフ サービス フェーズと呼ばれる準備期間内には、お客様の任意のタイミングにてメンテナンスを実施することができるため、メンテナンスに伴う VM 再起動による業務影響の発生を避けることが可能です。詳細については、下記公開情報をご確認ください。</p><blockquote><p>参考文献) 再起動を必要とするメンテナンス<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-and-updates#maintenance-that-requires-a-reboot">https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-and-updates#maintenance-that-requires-a-reboot</a></p></blockquote><blockquote><p>参考文献) 計画メンテナンスの通知の処理<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications">https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications</a></p></blockquote><p>メンテナンスの目的としては、ソフトウェアや Firmware 更新、古いハードウェアの更新 (移行) 作業やネットワーク スイッチにおける機器の交換作業などが考えられます。</p><div class="alert is-info"><p class="alert-title">Note</p><p>ネットワーク スイッチにおける機器ついては、現在、ネットワーク スイッチの冗長性を上げて、仮に 1 つのネットワーク スイッチに問題が生じた場合にも、もう 1 つのネットワーク スイッチで問題なく配下の物理ホスト サーバーおよび VM が稼働を続けることができるよう、日々 Azure プラットフォーム側の改善に努めております。</p></div><hr><h2 id="■-再起動を必要としないメンテナンスとは"><a href="#■-再起動を必要としないメンテナンスとは" class="headerlink" title="■ 再起動を必要としないメンテナンスとは ?"></a>■ 再起動を必要としないメンテナンスとは ?</h2><p>Azure では、物理ホスト サーバー群とその上で複雑に制御された機能をつかさどる各プロセスが稼働しており、これらは新しいバージョンのリリースと共に更新が必要となります。これらの更新作業が、再起動を必要としないメンテナンスに該当します。</p><blockquote><p>参考文献) 再起動を必要としないメンテナンス<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-and-updates#maintenance-that-doesnt-require-a-reboot">https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-and-updates#maintenance-that-doesnt-require-a-reboot</a></p></blockquote><p>ほとんどのプラットフォーム更新は、お客様の VM に影響しません。しかしながら影響を及ぼさない更新が不可能な場合、Azure は、お客様の <strong>VM への影響が最小となる更新メカニズム</strong> を利用して更新を行います。</p><h3 id="■-影響が最小となる更新メカニズムとは"><a href="#■-影響が最小となる更新メカニズムとは" class="headerlink" title="■ 影響が最小となる更新メカニズムとは ?"></a>■ 影響が最小となる更新メカニズムとは ?</h3><p>Windows Azure から Azure に名前が変更された 2014 年頃には、物理ホスト サーバーのモジュールの更新であったとしても、メンテナンスとして物理ホスト サーバーの再起動が必要となる場合があり、メンテナンスに伴いお客様の VM は毎回数分間の停止が必要でした。</p><p>このようなお客様への影響を可能な限り最小限にするため、Azure は投資、開発、改善を行い続けている結果、多くのメンテナンスでほとんどお客様が影響を感じないメンテナンスを実現することが可能となりました。</p><p>再起動を必要としないメンテナンスとしては下記のようなものがございます。</p><blockquote><p>参考文献) 影響がゼロまたは影響の少ないメンテナンス テクノロジの進化の変遷<br><a href="https://azure.microsoft.com/ja-jp/blog/advancing-noimpact-and-lowimpact-maintenance-technologies/">https://azure.microsoft.com/ja-jp/blog/advancing-noimpact-and-lowimpact-maintenance-technologies/</a></p></blockquote><blockquote><p>参考文献) Advancing failure prediction and mitigation—introducing Narya<br><a href="https://azure.microsoft.com/en-us/blog/advancing-failure-prediction-and-mitigation-introducing-narya/">https://azure.microsoft.com/en-us/blog/advancing-failure-prediction-and-mitigation-introducing-narya/</a></p></blockquote><h4 id="プラン-A-ホット-パッチ"><a href="#プラン-A-ホット-パッチ" class="headerlink" title="プラン A: ホット パッチ"></a>プラン A: ホット パッチ</h4><p>ホット パッチは、VM に一切ダウンタイムを生じさせることなく、物理ホスト サーバー上の実行中のプロセスに対して変更を行うことができるものであり、Azure では物理ホスト サーバーの更新プログラムを適用する際にできる限り使用しています。これは、物理ホスト サーバー上の機能を新たに呼び出す際、更新されたバージョンにリダイレクトすることで実現しています。</p><p>Azure では 2017 年からホット パッチを使用しており、それ以降、ホット パッチを使用できる範囲の拡大に取り組んでいます。たとえば 2018 年には、ハイパーバイザーに対してホット パッチが使用可能となりました。将来的には、さらなるカスタマー エクスペリエンスの向上のため、これまで “更新にはサーバーの再起動がつきもの” とされてきた Firmware への対応のため、ハードウェア メーカーと連携して検討を勧めています。</p><div class="alert is-important"><p class="alert-title">重要</p><p>ホットパッチのデモは、以下のビデオにて公開されています。</p><p>仮想化ホスト OS における特定のドライバーの置き換えが、人間には認識できないほどのわずかな時間にて成功しています。</p><p>このようなドライバーの更新は、たった 1 つのモジュールの置き換えであっても一般的な OS ではシステム再起動が</p><p>必須となっていたものですが、Azure OS ではこの一部についてはシステムを一切停止させずに更新していくことが可能となっています。</p><blockquote><p>[YouTube] <a href="https://www.youtube.com/watch?v=t3Vo37V9oU8&t=4216s">Inside Azure Datacenter Architecture with Mark Russinovich : Build 2018</a></p></div></blockquote><iframe width="560" height="315" src="https://www.youtube.com/embed/t3Vo37V9oU8?start=4216" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>大規模なホスト更新プログラムの中には、機能レベルのホット パッチでは適用できない変更が含まれているものもございます。それらの更新プログラムについては、メモリ保持メンテナンスを使用するようにしています。</p><h4 id="プラン-B-メモリ保持メンテナンス"><a href="#プラン-B-メモリ保持メンテナンス" class="headerlink" title="プラン B: メモリ保持メンテナンス"></a>プラン B: メモリ保持メンテナンス</h4><p>メモリ保持メンテナンスでは、RAM 内のメモリを保持して VM を “一時停止 (Freeze)” し、物理ホスト サーバーの更新を実施します。更新完了後には VM を再開し、クロックを自動的に同期する作業を実施します。</p><p>Azure では 2018 年からメモリ保持メンテナンスを使用しており、それ以降、3 つの観点で機能の向上を図ってきました。1 つ目は、物理ホスト サーバーを再起動せずに更新が実施できるホスト コンポーネントを対象とした影響の少ないメモリ保持メンテナンスのバリエーションの開発、2 つ目は、VM で発生する一時停止時間の短縮、3 つ目は、メモリ保持メンテナンスによって更新できる VM の種類の拡充です。</p><div class="alert is-important"><p class="alert-title">重要</p><p>メモリ保持メンテナンスのデモは、以下のビデオにて公開されています。</p><p>3D グラフィックスによるリアルタイムな映像が表示されていますが、1 秒未満のゲスト VM の停止時間にて、ホスト OS 側のドライバーの更新を行うことに成功しています。</p><blockquote><p>[YouTube] <a href="https://www.youtube.com/watch?v=t3Vo37V9oU8&t=4149s">Inside Azure Datacenter Architecture with Mark Russinovich : Build 2018</a></p></div></blockquote><iframe width="560" height="315" src="https://www.youtube.com/embed/t3Vo37V9oU8?start=4149" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><div class="alert is-warning"><p class="alert-title">警告</p><p>現状、メモリ保持メンテナンスはさまざまな技術的理由により、M、N、H シリーズなど特定の VM サイズ シリーズに対応できておりません。</p><p>このようなまれなケースでは、より影響の大きな (ホストの再起動や、VM の再展開などを伴う) メンテナンスを行う必要があるため、お客様には事前に通知し、それぞれのワークロードに適したタイミングでメンテナンスを実行できるようにしています。</p></div><h3 id="■-メモリ保持メンテナンスについて"><a href="#■-メモリ保持メンテナンスについて" class="headerlink" title="■ メモリ保持メンテナンスについて"></a>■ メモリ保持メンテナンスについて</h3><p>上記のように、ホットパッチでの対応が難しいものについてはメモリ保持メンテナンスが実施されます　 (逆に言うと、多くのメンテナンスがメモリ保持メンテナンスを用いずにホットパッチ機能を利用して更新が行われるように改善が進められました　)。</p><p>ドキュメントにはこのメンテナンスは通常、最長で 30 秒間といった記載がございます。<br>この記載がメンテナンスは 30 秒間で必ず完了するものといった誤解を生むことにつながりました。</p><h3 id="■-メンテナンス時間-30-秒間について"><a href="#■-メンテナンス時間-30-秒間について" class="headerlink" title="■ メンテナンス時間 30 秒間について"></a>■ メンテナンス時間 30 秒間について</h3><p>Azureをご利用いただく上で必要となるこれらのメンテナンスに対して、少しでもお客様に影響を与えないようカスタマー エクスペリエンスの向上を続けております。<br>その結果、メモリ保持メンテナンスであったとしても、ほとんどのメンテナンスで、99 パーセンタイル (P99) において Azure 基盤側の更新処理が 30 秒以内に完了できるようになりました。</p><div class="alert is-info"><p class="alert-title">Note</p><p>パーセンタイルとは、主に統計で使われる用語であり、最小値から並べてその値がどの位置にいるかを示す単位となります。</p><p>つまり P99 の場合、”99/100 番目の位置は 30 秒以内である” =&gt; “ほぼ 30 秒以内に終わる” ことを示しています。</p></div><p>しかしながら、100　% 完了とはなっておらず、お客様によっては、どうしても 30 秒以上の影響を受けてしまう状況が発生してしまうことは、現在に至っても避けられてはおりません。</p><p>メンテナンス内容によっても影響範囲が大きいもの、小さいものがございます。</p><p>例えば、ホスト サーバー上で動作するモジュールの置き換えであれば、ホットパッチまたは軽微なメモリ保持メンテナンスで解決いたしますが、ホスト サーバーのオペレーティングシステムの (カーネルを含むような) 更新を伴うような大きなメンテナンスの場合には、メモリ保持メンテナンスであったとしても、その影響が色濃く表れることもございます。</p><p>ご利用いただいている VM のオペレーティングシステムにより、古い Linux OS (カーネル) を利用されている場合には、想定以上にメンテナンスに対する影響の時間が長くなることもございます。<br>また、OS だけでなく、ネットワーク インフラストラクチャーにおける更新作業についても、OS やお客様の VM 自体を停止するものではありませんが、TCP/IP の自動的なリトライ ロジックを超えて瞬断が発生する可能性がございます。</p><p><span style="text-decoration:underline;">メンテナンスの影響時間は適用される更新プログラムやその内容により大きく左右されるため、一概にメンテナンス全体で 30 秒間影響を受けるものでは無く、また影響の大きなメンテナンス (メモリ保持メンテナンス) であった場合、多くのお客様で 30 秒以内にメンテナンスが収まっていたとしても、100 % のお客様で 30 秒以内にメンテナンスが完了することをお約束することは叶いません。</span></p><div class="alert is-info"><p class="alert-title">Note</p><p>Azure Virtual Machine の SLA も、これらのメンテナンスの改善と関連し向上しています。</p><p>Azure において、2022 年 10 月現在、過去最後に VM の再起動を伴う大規模なメンテナンスを行ったものは、2018 年 1 月 3 日頃のものとなっております。</p><p>※ 一部リージョンのハードウェアの更改に伴い、VM の再起動を伴うメンテナンスが発生することは局所的に存在します。</p><p>　</p><p>このような背景から、2018 年 3 月には、Azure Virtual Machine の SLA からメンテナンスに関連するダウンタイムの除外を削除しています。</p><p>つまり、たとえ計画されたメンテナンスであったとしても、お客様の VM に分単位のダウンタイムをもたらした場合には、合計 SLA に影響するということとなっています。　</p><blockquote><p>参考文献) Virtual Machines の SLA</p><p><a href="https://azure.microsoft.com/ja-jp/support/legal/sla/virtual-machines/v1_9/">https://azure.microsoft.com/ja-jp/support/legal/sla/virtual-machines/v1_9/</a></p><p>参照箇所: バージョン履歴</p><p>1.7 最終更新: 2018 年 3 月</p><p>リリース ノート:単一インスタンス仮想マシンメンテナンスに関連するダウンタイムの除外を削除</p></div></blockquote><div class="alert is-info"><p class="alert-title">Note</p><p>SLA ダウンタイムは分単位で計算されます。月間での合計 SLA がお客様の VM の稼働時間に対して 99.9 % (単一インスタンス / Premium SSD または Ultra ディスクの場合) を下回る場合に返金となります。　</p><blockquote><p>月間稼働率 (%) = (月内時間 (分) - ダウンタイム) / 月内時間 (分) x 100</p></div></blockquote><hr><h2 id="■-おわりに"><a href="#■-おわりに" class="headerlink" title="■ おわりに"></a>■ おわりに</h2><p>Azure では、引き続きメンテナンスに伴うお客様への影響時間短縮も含めたカスタマー エクスペリエンスの向上に尽力しています。また、将来を見据えて可用性と信頼性を確保するために機械学習ベースの洞察と自動化に多大な投資を行っています。</p><p>現時点では 30 秒程度との記載がございますが、このようなメンテナンスへの私たちの取り組みと、今後もより一層お客様が安心、信頼し Azure をご利用いただけるよう改善を続けていく思いを込めた記載であることをご理解いただけますと幸いでございます。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Azure テクニカル サポートチームの鳥越です。&lt;/p&gt;
&lt;p&gt;Azure をご利用いただいているお客様の中にはメンテナンスによる影響を経験された方もいらっしゃるかと存じます。&lt;br&gt;クラウド環境として、新機能の導入や更なる安定稼働を進めていく上で、このメンテナンスは必要不可欠なものです。&lt;br&gt;しかしながら、このメンテナンスといった言葉の中には、どのようなメンテナンスなのかがよくわからないといったご不安もあるかと推察します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="maintenance" scheme="https://jpaztech.github.io/blog/tags/maintenance/"/>
    
  </entry>
  
  <entry>
    <title>AKS に問題が発生した際にお寄せいただきたい情報について</title>
    <link href="https://jpaztech.github.io/blog/containers/aks-collect-logs/"/>
    <id>https://jpaztech.github.io/blog/containers/aks-collect-logs/</id>
    <published>2022-10-13T00:00:00.000Z</published>
    <updated>2023-01-10T02:14:50.316Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの山下です。</p><p>今回は、ご利用いただいている AKS に問題（Pod に接続できない、Pending の状態となっている、等) が発生し、弊サポートチームにお問い合わせをいただく際に採取いただきたい情報についてご紹介します。</p><span id="more"></span><hr><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>弊サポートチームでは、日々多くのお客様より AKS で発生した問題のご支援をしております。その際、状況の把握のためにいくつかのコマンドの実行をお願いしております。<br>本記事では、お問い合わせ前にお客様にて情報採取を可能とすることや、コマンドの内容に齟齬が生まれないようにすることを目的として、実行いただくコマンドをご紹介いたします。  </p><hr><h2 id="必要な権限について"><a href="#必要な権限について" class="headerlink" title="必要な権限について"></a>必要な権限について</h2><p>kubectl コマンドを実行し、各ネームスペースから関連するリソースを取得できる権限が必要になります。<br>具体的には、Kubernetes RBAC を使用している AKS クラスターであれば「Azure Kubernetes Service クラスター ユーザー ロール」、Azure RBAC を使用している AKS クラスターであれば「Azure Kubernetes Service RBAC 管理者」または「Azure Kubernetes Service RBAC クラスター管理者」の権限が必要となります。</p><blockquote><p>参考）</p><ul><li><a href="https://learn.microsoft.com/ja-jp/azure/aks/concepts-identity">Azure Kubernetes Service (AKS) でのアクセスと ID オプション</a></li><li><a href="https://learn.microsoft.com/ja-jp/azure/aks/control-kubeconfig-access">Azure ロールベースのアクセス制御を使用して、Azure Kubernetes Service (AKS) 内の Kubernetes 構成ファイルへのアクセス権を定義する</a></li></ul></blockquote><p>お客様にて何らかの異常を検知されたことでお問い合わせをいただいた際に、コマンドの実行をご案内したところ、お問い合わせいただいた方はコマンドを実行するための権限をお持ちではなかったため、情報の採取ならびに解決までにお時間を要してしまったケースも残念ながら過去に複数ございました。</p><p>そのような時に、「サポートの方で基盤から確認してもらえないか」「代わりにコマンドを実行して確認してもらえないか」といったご相談をいただくこともございました。</p><p>しかしながら、Azure ではお客様のデータを保護する観点から、我々サポートチームからお客様環境にコマンドを実行して取得する、といった仕組みがございませんため、そのようなご相談をお受けすることが残念ながら叶いません。  </p><p>正常性を監視されている方には必要な権限を付与していただく、または情報のご取得ができる方へのエスカレーションができるよう、緊急時のプロセスをお客様内で確立していただくことを予めご検討くださいますよう、何卒お願い申し上げます。</p><hr><h2 id="取得いただきたい情報"><a href="#取得いただきたい情報" class="headerlink" title="取得いただきたい情報"></a>取得いただきたい情報</h2><p>それでは問題が発生している AKS クラスターより情報を採取するためのコマンドを以下にご案内いたします。お問い合わせいただく際には、下記コマンドの実行結果とともに、どのリソース (Pod/Service 等) で問題が発生しているかをお寄せください。問題の内容によっては必ずしも必要ではない情報もございますが、本記事では多くの状況に対応するという観点で網羅的に記載しておりますので、冗長な点はご容赦頂ければ幸いです。<br>実行した結果、何も出力されなかった場合や、kubectl コマンドの実行が失敗する場合には、その旨を弊サポートチームまでお知らせくださいますと幸いです。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes -o wide &gt; get_nodes.txt</span><br><span class="line">kubectl describe nodes &gt; describe_nodes.txt</span><br><span class="line">kubectl get pod -A -o wide &gt; get_pods.txt</span><br><span class="line">kubectl describe pods -A &gt; describe_pods.txt</span><br><span class="line">kubectl get svc -A &gt; get_svc.txt</span><br><span class="line">kubectl describe svc -A &gt; describe_svc.txt</span><br><span class="line">kubectl describe ep -A &gt; describe_ep.txt</span><br><span class="line">kubectl get ingress -A -o yaml &gt; ingress.yaml</span><br><span class="line">kubectl get networkpolicy -A -o yaml &gt; networkpolicy.yaml</span><br><span class="line">kubectl logs &lt;対象の pod 名&gt; -n &lt;pod の namespace&gt; --timestamps=true &gt; &lt;pod 名&gt;.log</span><br><span class="line">kubectl logs &lt;対象の pod 名&gt; -n &lt;pod の namespace&gt; --timestamps=true -p &gt; &lt;pod 名&gt;_p.log</span><br></pre></td></tr></table></figure><hr><h3 id="補足事項"><a href="#補足事項" class="headerlink" title="補足事項"></a>補足事項</h3><p>Azure Portal からお問い合わせをいただく際、ファイルを複数添付できないという制限がございます。ご提供いただく際には一つのファイルに圧縮したうえで添付いただく、もしくはお問い合わせ後に弊サポートチームよりお知らせするアップロードサイトにてご提供いただきますようお願い申し上げます。</p><p>本稿が少しでも皆様のご参考となれば幸いです。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの山下です。&lt;/p&gt;
&lt;p&gt;今回は、ご利用いただいている AKS に問題（Pod に接続できない、Pending の状態となっている、等) が発生し、弊サポートチームにお問い合わせをいただく際に採取いただきたい情報についてご紹介します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Containers" scheme="https://jpaztech.github.io/blog/tags/Containers/"/>
    
    <category term="Azure Kubernetes Service (AKS)" scheme="https://jpaztech.github.io/blog/tags/Azure-Kubernetes-Service-AKS/"/>
    
  </entry>
  
  <entry>
    <title>アンマネージド ディスクを使用している仮想マシンのマネージド ディスクへの移行について</title>
    <link href="https://jpaztech.github.io/blog/vm/unmanaged-disk-retired/"/>
    <id>https://jpaztech.github.io/blog/vm/unmanaged-disk-retired/</id>
    <published>2022-10-12T03:00:00.000Z</published>
    <updated>2023-01-10T02:14:50.756Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの木下です。<br>今回は、度々お問い合わせいただきます、アンマネージド ディスク (非管理ディスク) を使用している仮想マシンのマネージド ディスク (管理ディスク) への移行についてご紹介いたします。</p><span id="more"></span><hr><p>2017 年にマネージド ディスク (管理ディスク) がリリースされて以降、マネージド ディスクの機能強化が行われてきました。今後もマネージド ディスクの機能向上に備えるため、2022 年 9 月 30 日以降、アンマネージド ディスクは非推奨となり、2025 年 9 月 30 日をもちまして廃止が予定されております。</p><div class="alert is-important"><p class="alert-title">重要</p><p>Azure の更新情報や Tracking ID: JTP9-JD0 にて周知されている情報となります。</p><p>参考）Azure unmanaged disks will be retired on 30 September 2025</p><p><a href="https://azure.microsoft.com/ja-jp/updates/azure-unmanaged-disks-will-be-retired-on-30-september-2025/">https://azure.microsoft.com/ja-jp/updates/azure-unmanaged-disks-will-be-retired-on-30-september-2025/</a></p></div><p>上記の通り、2025 年 9 月 30 日以降、アンマネージド ディスクを使用している仮想マシンは利用できなくなりますので、この期日までにアンマネージド ディスクを使用している仮想マシンをマネージド ディスクへ移行する必要があります。</p><div class="alert is-info"><p class="alert-title">Note</p><p>Azure 更新情報 URL 内に記載の “Page blobs will not be affected by this change.” の箇所につきまして補足いたします。</p><p>アンマネージド ディスクは Azure ストレージ内にページ BLOB として格納した VHD ファイルであり、これを仮想マシンにて利用しております。</p><p>今回、アンマネージド ディスクは 2025 年 9 月 30 日をもって廃止となり、アンマネージド ディスクを使用している仮想マシンは利用できなくなりますが、Azure ストレージ内に格納されている VHD ファイル (ページ BLOB) 自体が削除されることはございません。この点はご安心くださいませ。</p></div><p>お客様のご利用の環境において、アンマネージド ディスクを使用した仮想マシンが存在するのかどうかを確認し、存在する場合は計画的にマネージド ディスクへの移行を行いましょう。</p><hr><h2 id="1-アンマネージド-ディスクを使用している仮想マシンが存在するかの確認"><a href="#1-アンマネージド-ディスクを使用している仮想マシンが存在するかの確認" class="headerlink" title="1. アンマネージド ディスクを使用している仮想マシンが存在するかの確認"></a>1. アンマネージド ディスクを使用している仮想マシンが存在するかの確認</h2><p>アンマネージド ディスクを使用している仮想マシンが存在するかどうかは Azure Portal や Azure CLI でご確認いただくことができます。</p><h3 id="▼-Azure-Portal-を使用する場合"><a href="#▼-Azure-Portal-を使用する場合" class="headerlink" title="▼ Azure Portal を使用する場合"></a>▼ Azure Portal を使用する場合</h3><p>[Azure Portal] &gt; [仮想マシン (Virtual Machines)] ＞ [ビューの管理] &gt; [列の編集] をクリックします。</p><p><img src="/blog/vm/unmanaged-disk-retired/01.png"></p><p>[+ 列の追加] をクリックします。</p><p><img src="/blog/vm/unmanaged-disk-retired/02.png"></p><p>[マネージド ディスクを使用する] を選択し、保存します。</p><p><img src="/blog/vm/unmanaged-disk-retired/03.png"></p><p>[マネージド ディスクを使用する] の項目が追加されます。</p><p><img src="/blog/vm/unmanaged-disk-retired/04.png"></p><p>マネージド ディスクを使用している場合は「はい」、アンマネージド ディスクを使用している場合は「いいえ」と表示されます。<br>この項目が「いいえ」の場合、アンマネージド ディスクを使用した仮想マシンとなりますので、マネージド ディスクへの移行が必要であるとご判断いただくことが可能です。</p><h3 id="▼-Azure-CLI-を使用する場合"><a href="#▼-Azure-CLI-を使用する場合" class="headerlink" title="▼ Azure CLI を使用する場合"></a>▼ Azure CLI を使用する場合</h3><p>コマンド例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ vmids=$(az vm list --query [].id -o tsv)</span><br><span class="line">$ az vm show --ids <span class="variable">$vmids</span> --query <span class="string">&quot;[].&#123;vmname:name, rgname:resourceGroup, unmanageddisk:storageProfile.osDisk.vhd.uri&#125;&quot;</span> -o table</span><br><span class="line">Vmname    Rgname    Unmanageddisk</span><br><span class="line">--------  --------  ----------------------------------------------------</span><br><span class="line">testvm01  testrg01</span><br><span class="line">testvm02  testrg02  https://sample.blob.core.windows.net/vhds/sample.vhd</span><br></pre></td></tr></table></figure><p>[Unmanageddisk] 項目に VHD ファイルの URL が表示されている仮想マシンは、マネージド ディスクを使用した仮想マシンとなります。</p><h3 id="▼-Azure-PowerShell-を使用する場合"><a href="#▼-Azure-PowerShell-を使用する場合" class="headerlink" title="▼ Azure PowerShell を使用する場合"></a>▼ Azure PowerShell を使用する場合</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS /home/azureuser&gt; Get-AzVM -Status | Select-Object Name,ResourceGroupName,@&#123;Name=<span class="string">&quot;Unmanaged Disk&quot;</span>; Expression=&#123;<span class="variable">$_</span>.StorageProfile.OsDisk.Vhd.Uri&#125;&#125;</span><br><span class="line"></span><br><span class="line">Name                ResourceGroupName   Unmanaged Disk</span><br><span class="line">----                -----------------   --------------------------------</span><br><span class="line">testvm01            testrg01 </span><br><span class="line">testvm02            testrg02            https://sample.blob.core.windows.net/vhds/sample.vhd</span><br></pre></td></tr></table></figure><p>[Unmanaged Disk] 項目に VHD ファイルの URL が表示されている仮想マシンは、マネージド ディスクを使用した仮想マシンとなります。</p><hr><h2 id="2-マネージド-ディスクへの移行方法"><a href="#2-マネージド-ディスクへの移行方法" class="headerlink" title="2. マネージド ディスクへの移行方法"></a>2. マネージド ディスクへの移行方法</h2><p>アンマネージド ディスクからマネージド ディスクへの移行は、管理層を移行するという挙動となりますため、ディスクに格納されているデータ量に関わらず数分程度で完了することが想定となります。<br>ただし、移行操作に伴い VM の停止処理が発生しますので、この点は予めご留意いただきますようお願いいたします。</p><p>アンマネージド ディスクを使用した仮想マシンをマネージド ディスクへ移行する手順としては以下となります。</p><p>1.Azure Portal より対象の VM を選択します。</p><p>2.対象 VM の  OS・データ ディスクの VHD ファイルが格納されている Azure ストレージ アカウントを確認します。</p><p><img src="/blog/vm/unmanaged-disk-retired/05.png"></p><p>OS・データ ディスクの各 [VHD の URI] 箇所より Azure ストレージ アカウント名を確認することができます。</p><p><img src="/blog/vm/unmanaged-disk-retired/06.png"></p><p><img src="/blog/vm/unmanaged-disk-retired/07.png"></p><p>3.[ディスク] ブレードの上部 [マネージド ディスクに移行] 項目をクリックします。</p><p><img src="/blog/vm/unmanaged-disk-retired/08.png"></p><p>4.マネージド ディスクへの移行画面に遷移しますので、[移行] をクリックします。</p><p><img src="/blog/vm/unmanaged-disk-retired/09.png"></p><ol start="5"><li>VM が停止し、移行が開始されます。(約 2-3 分程度で完了します)</li></ol><p><img src="/blog/vm/unmanaged-disk-retired/10.png"></p><p>6.マネージド ディスクに変換されたことを確認します。</p><p><img src="/blog/vm/unmanaged-disk-retired/11.png"></p><p>7.1 で確認した対象の Azure ストレージ アカウントのコンテナー内から VHD ファイル自体は削除されていないことを確認します。</p><p><img src="/blog/vm/unmanaged-disk-retired/12.png"></p><p><img src="/blog/vm/unmanaged-disk-retired/13.png"></p><p>マネージド ディスクへの移行方法の詳細や注意事項については以下公開情報にておまとめしておりますのでご参考ください。<br>なお、マネージド ディスクへの移行は必ずテスト環境等で検証を行っていただいた上でご実施いただきますようお願いいたします。</p><blockquote><p>参考）</p><ul><li><a href="https://docs.microsoft.com/ja-jp/azure/virtual-machines/windows/convert-unmanaged-to-managed-disks">Windows 仮想マシンをアンマネージド ディスクからマネージド ディスクに移行する</a></li><li><a href="https://docs.microsoft.com/ja-jp/azure/virtual-machines/linux/convert-unmanaged-to-managed-disks">Linux 仮想マシンをアンマネージド ディスクからマネージド ディスクに移行する</a></li></ul></blockquote><hr><h2 id="3-マネージド-ディスクを利用することの利点や価格"><a href="#3-マネージド-ディスクを利用することの利点や価格" class="headerlink" title="3. マネージド ディスクを利用することの利点や価格"></a>3. マネージド ディスクを利用することの利点や価格</h2><p>マネージド ディスクをご利用いただくことによって得られる利点や価格に関しましては以下におまとめしておりますので、必要に応じてこちらもご参照ください。</p><blockquote><p>参考）</p><ul><li><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/managed-disks-overview#benefits-of-managed-disks">マネージド ディスクの利点</a></li><li><a href="https://azure.microsoft.com/ja-jp/pricing/details/managed-disks/">Managed Disks の価格</a></li><li><a href="https://azure.microsoft.com/ja-jp/pricing/details/storage/page-blobs/">Unmanaged Disk Azure ページ BLOB の価格</a></li></ul></blockquote><p>なお、アンマネージド ディスクの Standard HDD では、実際に格納しているデータ量に応じた課金となっておりましたが、マネージド ディスクでは Standard HDD も含め、ディスク リソースとしてプロビジョニングされたディスク サイズに対して課金が発生いたします。移行に伴い課金額に差異が発生する可能性がある点について、予めご認識いただけますと幸いです。</p><p>マネージド ディスクについてよく寄せられるご質問をおまとめした公開情報のご用意もございますので、こちらも併せてご参考ください。</p><blockquote><p>参考）</p><ul><li><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/faq-for-disks">Azure IaaS VM ディスクと Premium マネージド ディスクおよびアンマネージド ディスクについてよく寄せられる質問</a></li></ul></blockquote><p>本稿が皆様のお役に立てれば幸いです。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの木下です。&lt;br&gt;今回は、度々お問い合わせいただきます、アンマネージド ディスク (非管理ディスク) を使用している仮想マシンのマネージド ディスク (管理ディスク) への移行についてご紹介いたします。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Managed Disk" scheme="https://jpaztech.github.io/blog/tags/Managed-Disk/"/>
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
  </entry>
  
  <entry>
    <title>Azureで仮想マシン名を変更する</title>
    <link href="https://jpaztech.github.io/blog/vm/how-to-rename-vm/"/>
    <id>https://jpaztech.github.io/blog/vm/how-to-rename-vm/</id>
    <published>2022-09-29T00:30:00.000Z</published>
    <updated>2023-01-10T02:14:50.596Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポート チーム、インターン生の杉野です。</p><p>お客様より、リソース管理の都合上、既存の仮想マシンのリソース名を変更したいというお問い合わせをいただくことがあります。</p><p>ゲスト OS 内のホスト名は、ゲスト OS 内よりすぐに変更いただくことが可能です。<br>しかしながら、Azure のリソース名である仮想マシン名は Azure Portal 等より変更することは叶わず、変更実施する場合には仮想マシンの再作成が必要となります。<br>そこで今回は、仮想マシン名を変更する方法およびその注意点についてご紹介いたします。</p><span id="more"></span><h2 id="目次"><a href="#目次" class="headerlink" title="目次"></a>目次</h2><ol><li>仮想マシン名とは</li><li>変更手順</li><li>[おまけ] 仮想マシン名の代わりにタグでも管理できる</li></ol><hr><h2 id="1-仮想マシン名とは"><a href="#1-仮想マシン名とは" class="headerlink" title="1. 仮想マシン名とは"></a>1. 仮想マシン名とは</h2><p>今回変更する “仮想マシン名” とは、Azure のリソースとして表示される名前を指しています。<br>Azure Portal にて仮想マシンを選択し、左メニュー [概要] を選択した画面に表示される “コンピューター名” や、ゲスト OS 内で表示される “コンピューター名”、”ホスト名” とは異なりますのでご注意ください。<br>ただし、Azure Marketplace や一般化されたイメージより、新規に仮想マシンを作成した場合には、仮想マシン名と同名にて “コンピューター名” や “ホスト名” が設定されます。</p><p><img src="/blog/vm/how-to-rename-vm/01.png"></p><p>ゲスト OS 内の “コンピューター名” や “ホスト名” は、管理のためにシステム名などに基づき命名されることが多いかと思います。<br>当該環境の用途が変更となった場合には、管理の観点から新しいシステムに応じて名前を変える必要がありますが、それにより、ゲスト OS 内の名前と Azure リソースとしての仮想マシン名が異なってしまった場合にも管理が複雑となってしまうことが想定されます。</p><hr><h2 id="2-変更手順"><a href="#2-変更手順" class="headerlink" title="2. 変更手順"></a>2. 変更手順</h2><p>冒頭に記載した通り、Azure のリソース名を簡単に変える方法はなく、今回の場合は仮想マシンの再作成が必要となります。<br>再作成手順の概要は以下の通りとなります。</p><ul><li>事前準備: 引き継ぎたい情報を確認する</li><li>手順 1: 仮想マシンを削除する</li><li>手順 2: 仮想マシンを新しい名前で作成する</li></ul><h3 id="事前準備-引き継ぎたい情報を確認する"><a href="#事前準備-引き継ぎたい情報を確認する" class="headerlink" title="事前準備: 引き継ぎたい情報を確認する"></a>事前準備: 引き継ぎたい情報を確認する</h3><p>再作成時には、元の仮想マシンと同様の設定を実施する必要があるかと思いますので、事前に構成を控えておくことをお勧めします。<br>下記に項目の例を紹介しますが、その他必要な設定および構成がある場合は、適宜控えておきましょう。</p><h4 id="仮想マシン-左メニュー-概要"><a href="#仮想マシン-左メニュー-概要" class="headerlink" title="仮想マシン - 左メニュー [概要]"></a>仮想マシン - 左メニュー [概要]</h4><p>[必須項目]</p><ul><li>リソース グループ名</li><li>場所 (リージョン)</li><li>仮想マシンのサイズ</li><li>パブリック IP アドレス (利用している場合)<br>※ IP アドレスが表示されている場合にはクリックし、リソース名を確認します。</li><li>仮想ネットワーク / サブネット名</li></ul><p><img src="/blog/vm/how-to-rename-vm/05.png"></p><p>[設定がある場合]</p><ul><li>可用性とスケーリング (可用性セットまたは可用性ゾーン)</li></ul><p><img src="/blog/vm/how-to-rename-vm/06.png"></p><h4 id="仮想マシン-左メニュー-ネットワーク"><a href="#仮想マシン-左メニュー-ネットワーク" class="headerlink" title="仮想マシン - 左メニュー [ネットワーク]"></a>仮想マシン - 左メニュー [ネットワーク]</h4><div class="alert is-warning"><p class="alert-title">警告</p><p>既存の VNET/ Subnet、NIC をご利用いただく場合、既存の NSG 等との紐づけが実施されたままとなりますので、再設定は不要となります。</p></div><p>[元の NIC を使う場合]</p><ul><li>ネットワーク インターフェイス名 (複数の場合はすべて) を控えます。</li></ul><div class="alert is-info"><p class="alert-title">Note</p><p><strong>NIC は引き継げる ?</strong></p><p>Azure PowerShell や Azure CLI を用いて仮想マシンを作成する場合には既存の NIC を指定することが可能ですが、Azure Portal から仮想マシンを作成いただく場合には指定することは現状叶いません。</p><p>Azure Portal から操作を行いたい場合には、仮想マシン作成後に NIC の付け替えを実施いただく必要があります。</p></div><p>[元の NIC を使わない場合]<br>NSG や負荷分散等の設定は必要に応じて控えておきましょう。</p><p><img src="/blog/vm/how-to-rename-vm/20.png"></p><h4 id="仮想マシン-左メニュー-ディスク"><a href="#仮想マシン-左メニュー-ディスク" class="headerlink" title="仮想マシン - 左メニュー [ディスク]"></a>仮想マシン - 左メニュー [ディスク]</h4><ul><li>OS ディスク名とデータ ディスク名 (複数の場合はすべて) を控えます。</li><li>全ディスクのホスト キャッシュ設定も忘れずに控えておきましょう。</li></ul><p><img src="/blog/vm/how-to-rename-vm/08.png"></p><h4 id="その他"><a href="#その他" class="headerlink" title="その他"></a>その他</h4><p>上記以外にも仮想マシンの再作成時に設定可能な項目は複数あります。必要な項目は控えておきましょう。</p><ul><li>Azure ハイブリッド特典の設定</li><li>近接配置グループ名</li><li>Azure Dedicated Host の使用の有無</li><li>容量予約の使用の有無</li><li>拡張機能名 (複数の場合はすべて)</li><li>VM アプリケーション (複数の場合はすべて)</li><li>自動シャットダウンの設定</li><li>バックアップの設定</li><li>ゲスト OS の更新プログラム</li><li>ゲスト OS 診断の設定</li><li>ブート診断の設定<br>など</li></ul><h3 id="手順-1-仮想マシンを削除する"><a href="#手順-1-仮想マシンを削除する" class="headerlink" title="手順 1: 仮想マシンを削除する"></a>手順 1: 仮想マシンを削除する</h3><div class="alert is-warning"><p class="alert-title">警告</p><p><strong>誤操作に備えて</strong></p><p>予期せぬご状況に備えるためにも、操作前には Azure Backup やディスクのスナップショット (要 OS シャットダウン) をご取得いただくことをお勧めします。</p><p>　</p><p>ご参考) Azure VM バックアップについて</p><p><a href="https://learn.microsoft.com/ja-jp/azure/backup/backup-azure-vms-introduction">https://learn.microsoft.com/ja-jp/azure/backup/backup-azure-vms-introduction</a></p><p>　</p><p>ご参考) 仮想ハード ディスクの Azure スナップショットを作成する</p><p><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/snapshot-copy-managed-disk?tabs=portal">https://learn.microsoft.com/ja-jp/azure/virtual-machines/snapshot-copy-managed-disk?tabs=portal</a></p></div><p>以下の画面の通り、仮想マシンの [削除] をクリックします。</p><p><img src="/blog/vm/how-to-rename-vm/03.png"></p><p>[削除] をクリックした後に表示される確認画面にて、”強制削除の適用” や 各関連リソースの “VM で削除” のボックスにチェックが入っていないことを確認します。<br>問題がない場合には、削除について理解した文言にチェックを入れ、[削除] をクリックします。</p><p><img src="/blog/vm/how-to-rename-vm/02.png"></p><h3 id="手順-2-仮想マシンを新しい名前で作成する"><a href="#手順-2-仮想マシンを新しい名前で作成する" class="headerlink" title="手順 2: 仮想マシンを新しい名前で作成する"></a>手順 2: 仮想マシンを新しい名前で作成する</h3><p>削除した仮想マシンで使用していた OS ディスクより、控えた内容をもとに仮想マシンを作成します。</p><p>今回は、Azure Portal を使用して仮想マシンを作成し、その後、元の NIC を使用するために NIC の付け替えを実施する手順をご紹介します。</p><div class="alert is-warning"><p class="alert-title">警告</p><p>今回の Azure Portal で仮想マシンを作成する手順の場合、新たな NIC が仮想マシンに接続されるため、MAC アドレスが変更されます。</p><p>Linux 仮想マシンの場合、設定ファイル内に MAC アドレスが含まれる可能性がありますので、ご注意いただけますと幸いです。</p><p>　</p><p>ご参考) ネットワーク インターフェイスの作成、変更、削除</p><p><a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/virtual-network-network-interface?tabs=network-interface-portal">https://learn.microsoft.com/ja-jp/azure/virtual-network/virtual-network-network-interface?tabs=network-interface-portal</a></p><p>抜粋：注意</p><blockquote><p>Azure では、ネットワーク インターフェイスの仮想マシンへのアタッチと、仮想マシンの初回起動の後にのみ、ネットワーク インターフェイスに MAC アドレスが割り当てられます。</p><p>Azure によってネットワーク インターフェイスに割り当てられる MAC アドレスは指定できません。</p><p>MAC アドレスがネットワーク インターフェイスに割り当てられると、そのネットワーク インターフェイスが削除されるか、プライマリ ネットワーク インターフェイスのプライマリ IP 構成に割り当てられたプライベート IP アドレスが変更されるまで、その状態は変わりません。</p><p>IP アドレスと IP 構成の詳細については、IP アドレスの管理に関するページをご覧ください。</p></div></blockquote><h4 id="仮想マシンの作成"><a href="#仮想マシンの作成" class="headerlink" title="仮想マシンの作成"></a>仮想マシンの作成</h4><ol><li><p>削除した仮想マシンで使用していた OS ディスク (控えていた OS ディスク名を参照) を選択します。<br><img src="/blog/vm/how-to-rename-vm/09.png"></p></li><li><p>OS ディスクの [概要] から [VM の作成] を選択します。<br><img src="/blog/vm/how-to-rename-vm/10.png"></p></li><li><p>先ほど控えた内容をもとに、仮想マシンを作成します。<br>以下に例を示しますが、各項目はご自身の環境に合わせて設定してください。</p><ul><li><p><strong>[基本] タブ</strong>：<br><img src="/blog/vm/how-to-rename-vm/19.png"></p><div class="alert is-warning"><p class="alert-title">警告</p><p>可用性オプション (可用性セットまたは可用性ゾーン) につきましては、仮想マシン作成時にのみ設定できる項目になりますので、ご利用いただく場合には忘れずにご設定ください。</p><p>　</p><p>可用性ゾーンをご指定いただく場合、ディスクで指定いただいているゾーンと同じゾーンを指定する必要がありますのでご注意ください。</p></div></li><li><p><strong>[ディスク] タブ</strong>：<br>既存のデータ ディスクを接続する場合は、 [ディスク] タブで [既存のディスクの接続] を選択します。<br>データ ディスクのホストのキャッシュ設定も控えたパラメータに設定します。<br><img src="/blog/vm/how-to-rename-vm/12.png"></p></li><li><p><strong>[ネットワーク] タブ</strong>：<br>既存のネットワーク インターフェースの接続は仮想マシン作成後に行います。そのため、この段階での “NIC ネットワーク セキュリティ グループ” の設定は不要です。<br>※ 既存の VNET/ Subnet、NIC をご利用いただく場合、既存の NSG との紐づけが実施されたままとなりますので、仮想マシン作成時に新たに NSG を設定いただく必要はございません。<br><img src="/blog/vm/how-to-rename-vm/13.png"></p></li><li><p>全ての設定が完了後、 [確認および作成] から[作成] をクリックします。<br><img src="/blog/vm/how-to-rename-vm/14.png"></p></li></ul></li><li><p>作成が完了すると新しく作成した仮想マシンを確認することができます。<br><img src="/blog/vm/how-to-rename-vm/15.png"></p></li></ol><h4 id="NIC-の付け替え"><a href="#NIC-の付け替え" class="headerlink" title="NIC の付け替え"></a>NIC の付け替え</h4><ol><li><p>仮想マシン作成後、既存 NIC を接続するため、仮想マシンを停止 (割り当て解除) します。<br><img src="/blog/vm/how-to-rename-vm/16.png"></p></li><li><p>仮想マシン停止 (割り当て解除) 後、仮想マシンのページから [ネットワーク] - [ネットワーク インターフェイスの接続] を選択し、削除した仮想マシンで使用していた NIC を接続します。<br><img src="/blog/vm/how-to-rename-vm/17.png"></p></li><li><p>既存の NIC の接続完了後も、仮想マシン作成時に作成された NIC がまだプライマリとなっているの状態なので、[ネットワーク インターフェイスのデタッチ] を選択し、分離する必要があります。<br><img src="/blog/vm/how-to-rename-vm/18.png"></p><p>NIC のデタッチを実施後、セカンダリとして接続した既存 NIC は自動的にプライマリとなります。<br>なお、デタッチした NIC については削除されても問題ありません。</p></li><li><p>仮想マシンを起動します。</p></li></ol><hr><h2 id="3-おまけ-仮想マシン名の代わりにタグでも管理できる"><a href="#3-おまけ-仮想マシン名の代わりにタグでも管理できる" class="headerlink" title="3. [おまけ] 仮想マシン名の代わりにタグでも管理できる"></a>3. [おまけ] 仮想マシン名の代わりにタグでも管理できる</h2><p>ここまでの内容の通り、Azure のリソースとしての仮想マシン名を変えるためには再作成が必要となり、構成の確認や再設定等、それなりの時間がかかることがお分かりいただけたかと思います。</p><p>そのため、仮想マシン名にすぐに変更されうる情報 (プロジェクト名や担当者名など) を使うと、後々に運用変更が発生した際に、異なる名前による管理の負荷や変更作業の負荷がかかる可能性があります。</p><p>それでは、どのように管理するのがよいのか。<br>Azure では、リソース管理に用いるタグという機能が用意されています。</p><blockquote><p>ご参考) リソースの名前付けとタグ付けの意思決定ガイド<br><a href="https://learn.microsoft.com/ja-jp/azure/cloud-adoption-framework/decision-guides/resource-tagging/?toc=/azure/azure-resource-manager/management/toc.json">https://learn.microsoft.com/ja-jp/azure/cloud-adoption-framework/decision-guides/resource-tagging/?toc=%2Fazure%2Fazure-resource-manager%2Fmanagement%2Ftoc.json</a></p></blockquote><blockquote><p>ご参考) タグを使用して Azure リソースと整理階層を整理する<br><a href="https://docs.microsoft.com/ja-jp/azure/azure-resource-manager/resource-group-using-tags">https://docs.microsoft.com/ja-jp/azure/azure-resource-manager/resource-group-using-tags</a></p></blockquote><p><img src="/blog/vm/how-to-rename-vm/04.png"></p><p>変更されうる細かな情報をタグに記載しておけば、後からの変更も簡単にできます。<br>仮想マシンに付与するタグを変更する場合、仮想マシンの停止は不要であり、変更処理自体もお時間を要さないことが想定されています。(弊社環境での検証時には、数十秒程度で完了しました。)<br>リソースの管理手段として、ご参考となれば幸いです。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポート チーム、インターン生の杉野です。&lt;/p&gt;
&lt;p&gt;お客様より、リソース管理の都合上、既存の仮想マシンのリソース名を変更したいというお問い合わせをいただくことがあります。&lt;/p&gt;
&lt;p&gt;ゲスト OS 内のホスト名は、ゲスト OS 内よりすぐに変更いただくことが可能です。&lt;br&gt;しかしながら、Azure のリソース名である仮想マシン名は Azure Portal 等より変更することは叶わず、変更実施する場合には仮想マシンの再作成が必要となります。&lt;br&gt;そこで今回は、仮想マシン名を変更する方法およびその注意点についてご紹介いたします。&lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
  </entry>
  
  <entry>
    <title>Azure KMS の IP アドレスが変わります</title>
    <link href="https://jpaztech.github.io/blog/vm/azure-kms-update/"/>
    <id>https://jpaztech.github.io/blog/vm/azure-kms-update/</id>
    <published>2022-09-20T02:00:00.000Z</published>
    <updated>2023-01-10T02:14:50.488Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポート チームの鳥越です。</p><p>近日中に新しい Azure KMS の IP アドレスがリリースされる予定となっております。<br>そこで本記事では、Azure KMS の IP アドレスに関する下記の資料の補足をご紹介します。</p><span id="more"></span><p>なお、下記ブログ記事も合わせてご参考いただけますと幸いです。</p><blockquote><p>ご参考) Azure Windows Virtual Machine Activation: two new KMS IP addresses (…and why you should care)<br><a href="https://techcommunity.microsoft.com/t5/azure-compute-blog/azure-windows-virtual-machine-activation-two-new-kms-ip/ba-p/3621189">https://techcommunity.microsoft.com/t5/azure-compute-blog/azure-windows-virtual-machine-activation-two-new-kms-ip/ba-p/3621189</a><br>ご参考) Generally available: New KMS DNS in Azure Global Cloud<br><a href="https://azure.microsoft.com/en-us/updates/new-kms-dns-in-azure-global-cloud/">https://azure.microsoft.com/en-us/updates/new-kms-dns-in-azure-global-cloud/</a></p></blockquote><hr><h2 id="〇-何が起こりますか"><a href="#〇-何が起こりますか" class="headerlink" title="〇 何が起こりますか?"></a>〇 何が起こりますか?</h2><p>2022 年 7 月に新しい Azure KMS の IP アドレスとして、20.118.99.224 と 40.83.235.53 の 2 つの新しい KMS IP アドレスを発表しました。</p><p>Azure グローバル クラウドの KMS サーバーの最初の DNS 名は azkms.core.windows.net で　20.118.99.224 および 40.83.235.53 を指し示します。<br>Azure グローバル クラウドの KMS サーバーの 2 番目の DNS 名は kms.core.windows.net で、IP アドレスは 23.102.135.246 です。</p><p>つまり、カスタム ルート構成を行っている環境では、Azure グローバル クラウドの 3 つの IP アドレスすべてをカスタム ルートに追加する必要があります。</p><hr><h2 id="〇-どのような影響がありますか"><a href="#〇-どのような影響がありますか" class="headerlink" title="〇 どのような影響がありますか?"></a>〇 どのような影響がありますか?</h2><p>ほとんどの仮想マシンについて影響はないと考えられますが、旧来の Azure KMS の IPアドレス(23.102.135.246) を UDR などで登録している、または、kms.core.windows.net に対する URL アクセスを限定している環境については、azkms のエンドポイントを追加いただく必要がございます。</p><p>追加されない場合、仮想マシンは Azure KMS サーバーにアクセスできないため、以下のようなエラーメッセージが記録されます。</p><blockquote><p>「エラー: 0xC004F074 ソフトウェア ライセンス サービスで、コンピューターのライセンス認証ができなかったことが報告されました。キー管理サービス (KMS) に接続できませんでした。詳細については、アプリケーション イベント ログを参照してください。」</p></blockquote><p>動作影響に関して、認証に失敗した場合のライセンスの猶予期間は 180 日間です。<br>つまり、お客様の構成の関係で、新しい azkms エンドポイントにアクセスできなかった場合、前回のアクセス認証から 180 日間の猶予がありますので、慌てて対策を行う必要はありません。</p><p>また、実際のライセンス切れが発生した場合には、通知モード (ライセンス認証切れ状態) となりますが、こちらは仮想マシンの稼働に大きな影響 (強制シャットダウン、ログオン不可、サーバー / クライアント機能の使用制限など) を与えるものではありません。<br>なお、通知モードは、再度 KMS 認証を行い成功した際に解除されます。</p><p>そのため、今回の通知からの変更で間に合わなかった場合には、180 日間の猶予において対策を実施いただけますと幸いです。</p><blockquote><p>ご参考) Windows ライセンス認証が期限切れになるとどうなりますか?<br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-activation-problems#what-happens-if-windows-activation-period-expires">https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-activation-problems#what-happens-if-windows-activation-period-expires</a></p></blockquote><hr><h2 id="〇-どのような対応が必要ですか"><a href="#〇-どのような対応が必要ですか" class="headerlink" title="〇 どのような対応が必要ですか?"></a>〇 どのような対応が必要ですか?</h2><p>以下のお客様については、新しい Azure KMS エンドポイントへのアクセス許可を追加いただくようお願いいたします。</p><p><strong>対象の構成</strong></p><blockquote><ul><li>UDR にて旧来の Azure KMS の IP アドレス (23.102.135.246) を指定している</li><li>エンドポイントを kms.core.windows.net のみに限定している</li></ul></blockquote><p><strong>必要な対応</strong><br>新しい KMS エンドポイントへのアクセス許可を追加</p><blockquote><ul><li>エンドポイント : azkms.core.windows.net</li><li>新しいKMS IP アドレス : 20.118.99.224 と 40.83.235.53</li></ul></blockquote><hr><h2 id="〇-新しい-Azure-KMS-エンドポイントへの接続確認方法"><a href="#〇-新しい-Azure-KMS-エンドポイントへの接続確認方法" class="headerlink" title="〇 新しい Azure KMS エンドポイントへの接続確認方法"></a>〇 新しい Azure KMS エンドポイントへの接続確認方法</h2><p>以下のコマンドを実施し、疎通に問題がないかご確認お願いいたします。</p><ol><li>PowerShell を開く</li><li>次のコマンドを実施する<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test-netconnection</span> azkms.core.windows.net <span class="literal">-port</span> <span class="number">1688</span> </span><br><span class="line"><span class="built_in">test-netconnection</span> <span class="number">20.118</span>.<span class="number">99.224</span> <span class="literal">-port</span> <span class="number">1688</span> </span><br><span class="line"><span class="built_in">test-netconnection</span> <span class="number">40.83</span>.<span class="number">235.53</span> <span class="literal">-port</span> <span class="number">1688</span> </span><br></pre></td></tr></table></figure></li></ol><p>接続が可能であれば特に対処は必要ありません。<br>接続が失敗した場合には、前項の「どのような対応が必要ですか?」をご確認いただき、設定変更をお願いいたします。</p><hr><h2 id="〇-補足事項"><a href="#〇-補足事項" class="headerlink" title="〇 補足事項"></a>〇 補足事項</h2><p>今回の変更ですが、今後多くのお客様が Azure を利用していく上で、Azure KMS サーバーを増強し、負荷上昇による認証失敗を解消するための措置となります。<br>今後も弊社 Azure インフラストラクチャの安定した稼働に努めてまいりますので、お手数をおかけしますが、作業についてご理解給われますと幸いです。</p><br>ご紹介は以上となります。上記情報がお役に立てれば幸いです。]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポート チームの鳥越です。&lt;/p&gt;
&lt;p&gt;近日中に新しい Azure KMS の IP アドレスがリリースされる予定となっております。&lt;br&gt;そこで本記事では、Azure KMS の IP アドレスに関する下記の資料の補足をご紹介します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
  </entry>
  
  <entry>
    <title>Azure Storage Explorer を用いて、コマンド無しで VM を別のリージョン・サブスクリプション・テナントに移動/複製をしてみよう</title>
    <link href="https://jpaztech.github.io/blog/vm/copy-vm-with-storage-explorer/"/>
    <id>https://jpaztech.github.io/blog/vm/copy-vm-with-storage-explorer/</id>
    <published>2022-08-22T05:00:00.000Z</published>
    <updated>2023-01-10T02:14:50.504Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの富田です。<br> <br>Azure 上の VM およびマネージド ディスクについて、  </p><ul><li><strong>別のリージョンに移動/複製をしたい</strong>  </li><li><strong>別のサブスクリプションに移動/複製をしたい</strong>  </li><li><strong>別のテナントにあるサブスクリプションに移動/複製をしたい</strong>  </li></ul><p>というご要望をいただくことがございます。<br> <br>これらを実現する手段は幾つかありますが、<br>Azure Storage Explorer を使うと、上記のご要望がコマンド不要で全て GUI で完結することが可能です！<br>今回はこの方法についてスクリーンショットを交えて紹介させていただきます。     </p><hr><h1 id="手順の概要について"><a href="#手順の概要について" class="headerlink" title="手順の概要について"></a>手順の概要について</h1><p> <br>まず、大まかな流れについてご説明させていただきます。     </p><ul><li>Azure Storage Explorer をインストールする  </li><li>Azure Storage Explorer で対象のサブスクリプションに接続する  </li><li>対象の VM を割り当て解除（停止）する  </li><li>VM 停止時間を最小にするために一時的にディスク コピーをする（任意のためスキップ可）  </li><li>Azure Storage Explorer でディスクを移行先に複製する  </li><li>複製したディスクから新規に VM を作成する  </li></ul><p>手順の概要図としては以下のようになります。<br>   <br><img src="/blog/vm/copy-vm-with-storage-explorer/image15.png"> </p><p>勿論この方法で、  </p><ul><li>マネージド ディスクだけを複製する  </li><li>データ ディスクも含めて複製する  </li><li>同一のサブスクリプション内に VM を複製する  </li></ul><p>といったことも可能です。  </p><p>なお、転送や作成したディスク等には所定の料金が発生したしますのでこの点はご了承くださいませ。<br>また、Windows VM を複製しそれをご利用いただく場合、基本的には「一般化したイメージから VM を複製」いただく必要がございます。<br>この詳細は <a href="https://jpaztech.github.io/blog/vm/vm-replica-1/#Windows-VM%E3%82%92%E8%A4%87%E8%A3%BD%E3%81%97%E3%82%88%E3%81%86%E3%81%A8%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E6%96%B9%E3%81%B8%E3%81%AE%E6%B3%A8%E6%84%8F%E5%96%9A%E8%B5%B7">Windows-VM を複製しようとしている方への注意喚起</a> をご参照ください。  </p><p>それでは早速詳細な手順を見ていきましょう。  </p><hr><h1 id="Azure-Storage-Explorer-をインストールする"><a href="#Azure-Storage-Explorer-をインストールする" class="headerlink" title="Azure Storage Explorer をインストールする"></a>Azure Storage Explorer をインストールする</h1><p>Azure Storage Explorer は GUI でマネージド ディスクやストレージ アカウントのデータ管理を行える、<br>とても便利なソフトウェアとなります！  </p><p>まずは Azure Storage Explorer をインストールしましょう。<br>以下の URL より Azure Storage Explorer を入手することができます。<br> <br>■ご参考：Azure Storage Explorer<br><a href="https://azure.microsoft.com/ja-jp/features/storage-explorer/">https://azure.microsoft.com/ja-jp/features/storage-explorer/</a>     </p><hr><h1 id="Azure-Storage-Explorer-で対象のサブスクリプションに接続する"><a href="#Azure-Storage-Explorer-で対象のサブスクリプションに接続する" class="headerlink" title="Azure Storage Explorer で対象のサブスクリプションに接続する"></a>Azure Storage Explorer で対象のサブスクリプションに接続する</h1><p>インストールが完了したら、Azure Storage Explorer を開き、各種操作が可能な Azure ユーザーでログインをします。<br>コンセントのアイコンの「接続ダイアログを開く」を選択し、「サブスクリプション」を選択の上ログインを実施してください。<br> <br><img src="/blog/vm/copy-vm-with-storage-explorer/image2.png"><br> <br>なお、別のテナントに VM コピーを試みる場合は上記のログイン作業を、２回実施します。<br>「移行元サブスクリプション」「移行先サブスクリプション」と 2 つともログインしておきましょう。     </p><hr><h1 id="対象の-VM-を割り当て解除（停止）する"><a href="#対象の-VM-を割り当て解除（停止）する" class="headerlink" title="対象の VM を割り当て解除（停止）する"></a>対象の VM を割り当て解除（停止）する</h1><p>VM が割り当て解除（停止）状態でない場合は、ディスクの転送が叶いません。<br>転送を行うために、対象となる VM を Azure ポータル等で割り当て解除（停止）しましょう。<br> <br><img src="/blog/vm/copy-vm-with-storage-explorer/image3.png">   </p><p>また、転送するディスク名も確認しておきましょう。<br>VM の [ディスク] ブレードより、複製を行いたいディスク名が確認できます。  </p><p><img src="/blog/vm/copy-vm-with-storage-explorer/image4.png"> </p><hr><h1 id="VM-停止時間を最小にするために一時的にディスクコピーをする（任意のためスキップ可）"><a href="#VM-停止時間を最小にするために一時的にディスクコピーをする（任意のためスキップ可）" class="headerlink" title="VM 停止時間を最小にするために一時的にディスクコピーをする（任意のためスキップ可）"></a>VM 停止時間を最小にするために一時的にディスクコピーをする（任意のためスキップ可）</h1><p>こちらの手順は任意のためにスキップ可能です。<br>VM 停止時間を最小に抑えたい場合のみ実行をご検討ください。  </p><p>VM が割り当て解除状態であれば、そのまま VM にアタッチされているディスクの転送は開始は可能です。<br>しかしながら、転送が完了するまでは VM が起動できないという制約もあります。<br> <br>同一リージョン等では転送にそれほど時間がかからないものと存じますが、一概な転送時間はご案内が叶いません。<br>大容量のディスクをリージョン間コピーする際など、<br>転送に時間がかかる場合は元の VM 起動ができない期間が発生する可能性もございます。  </p><p>そのため、VM 停止時間を最小に抑えたい場合は、</p><ul><li>VM 停止後にディスクのスナップショットを取得する</li><li>スナップショット取得が完了したら元の VM 起動する</li><li>スナップショットから転送用ディスクを一時的に作成</li><li>転送用ディスクを転送する</li></ul><p> <br>といった手順を実施することで、VM 停止時間を最小に抑えることが可能です。<br>この場合は以下の図のような流れとなります。  </p><p><img src="/blog/vm/copy-vm-with-storage-explorer/image1.png"> </p><p>それでは、この実際の手順を説明させていただきます。<br>VM 停止が完了したら、VM の [ディスク] ブレードより、複製を行いたいディスクを選択します。<br> <br>なおスナップショット自体は、VM が起動状態でも取得可能ですが、<br>移行後の VM の不具合を防止するため VM 停止状態でスナップショットを取得することを強く推奨いたします。  </p><p><img src="/blog/vm/copy-vm-with-storage-explorer/image4.png"> </p><p>上部にある [スナップショットの作成] を選択します。<br> <br><img src="/blog/vm/copy-vm-with-storage-explorer/image5.png"><br> <br>スナップショット作成のオプションを選択します。<br>下記は一例とはなりますが、今回はスナップショットの種類は [フル] とし、記憶域の種類は [Standard HDD] としています。<br>設定が完了したら、[レビュー] を選択し、スナップショットを作成します。<br> <br><img src="/blog/vm/copy-vm-with-storage-explorer/image6.png"><br> <br>これでスナップショット取得が完了となります。<br>なお、スナップショット取得の所要時間は一概には言えませんが、手元の Windws OS ディスク 128 GB では十数秒で完了しました。<br>スナップショット取得が完了したら、VM を起動頂いて大丈夫です。<br> <br>先ほど取得したスナップショットから一時的に転送用ディスクを作成します。<br>まずは、ポータル上部の検索ボックスで [スナップショット] を検索し、選択します。<br> <br><img src="/blog/vm/copy-vm-with-storage-explorer/image7.png"><br> <br>先ほど取得したスナップショットを一覧より選択します。<br> <br><img src="/blog/vm/copy-vm-with-storage-explorer/image8.png"><br> <br>上部に表示される [ディスクの作成] を選択します。<br> <br><img src="/blog/vm/copy-vm-with-storage-explorer/image9.png"><br> <br>「転送用ディスク」としてマネージド ディスクを作成します。<br>基本的には、デフォルトの設定で問題無いかと思いますが、下記例ではサイズにて [Standard HDD] のディスクを作成するように設定しています。<br>設定が完了したら [確認および作成] を選択し、マネージド ディスクを作成します。<br> <br><img src="/blog/vm/copy-vm-with-storage-explorer/image10.png"><br> <br>不要な課金を無くすためにも、この手順で一時的に作成した「スナップショット」および「転送用のマネージド ディスク」は後ほど削除しましょう。<br>では「転送用ディスク」が作成できましたので、続きの手順に沿って Azure Storage Explorer でディスクを移行先に複製しましょう。<br>（任意のためスキップ可）の手順はここまでです。  </p><hr><h1 id="Azure-Storage-Explorer-でディスクを移行先に複製する"><a href="#Azure-Storage-Explorer-でディスクを移行先に複製する" class="headerlink" title="Azure Storage Explorer でディスクを移行先に複製する"></a>Azure Storage Explorer でディスクを移行先に複製する</h1><p>それでは、OS ディスク（または任意のディスク）を転送先にコピーしましょう。<br> <br>Azure Storage Explorer にて、<br>左側のエクスプローラーより転送対象となるディスクが存在するリソース グループを選択します。<br>そして、対象のディスクを選択し「コピー」を選択します。<br> <br><img src="/blog/vm/copy-vm-with-storage-explorer/image11.png"><br> <br>次に、エクスプローラーで複製先となるリソース グループを選択の上、「貼り付け」を選択します。<br>この際、別テナントや別サブスクリプション上のリソース グループも選択が可能です。<br>以下のように複製先のリージョンを選ぶことが可能となっております。<br> <br><img src="/blog/vm/copy-vm-with-storage-explorer/image12.png"><br> <br>同一リソース グループ内に同一名のマネージド ディスクは作成が叶いませんので、その際は上記画面でディスク名を変更くださいませ。<br>なお、転送状況は以下の通り Azure Storage Explorer 下部のアクティビティ タブにてご確認が可能です。<br> <br><img src="/blog/vm/copy-vm-with-storage-explorer/image13.png"><br> <br>なお、データ ディスクも合わせて複製する必要がある場合は同様の手順で、OS ディスクと合わせて複製を行ってください。     </p><hr><h1 id="複製した-OS-ディスクから新規に-VM-を作成する"><a href="#複製した-OS-ディスクから新規に-VM-を作成する" class="headerlink" title="複製した OS ディスクから新規に VM を作成する"></a>複製した OS ディスクから新規に VM を作成する</h1><p>Azure ポータルで、移行先の複製した OS ディスクのリソースを表示します。<br>複製した OS ディスクから以下の通り VM 作成が可能です。<br> <br><img src="/blog/vm/copy-vm-with-storage-explorer/image14.png"><br> <br>データ ディスクがある場合は、この VM 作成時にデータ ディスクをアタッチしましょう。<br>また VM 複製でなく VM 移動の場合は、複製完了後に移行元の VM および不要なリソースを削除いただくようにお願いいたします。  </p><hr><p>以上が Azure Storage Explorer を用いて、コマンド無しで VM を別のリージョン・サブスクリプション・テナントに移動/複製する方法でした。<br>こちらの内容が皆様のお役に立てれば幸いでございます。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの富田です。&lt;br&gt; &lt;br&gt;Azure 上の VM およびマネージド ディスクについて、  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;別のリージョンに移動/複製をしたい&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;&lt;str</summary>
      
    
    
    
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
    <category term="Linux" scheme="https://jpaztech.github.io/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Azure 上でデプロイした Windows の VM に DVD ドライブが表示される</title>
    <link href="https://jpaztech.github.io/blog/vm/what-is-this-dvd-drive/"/>
    <id>https://jpaztech.github.io/blog/vm/what-is-this-dvd-drive/</id>
    <published>2022-08-19T06:00:00.000Z</published>
    <updated>2023-01-10T02:14:50.824Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの富田です。<br><strong>Azure 上でデプロイした Windows の VM に D ドライブ や E ドライブとして CD / DVD ドライブが表示される</strong><br>というお問い合わせをいただくことがあるため、これについて解説させていただきます。  </p><p><img src="/blog/vm/what-is-this-dvd-drive/what-is-this-dvd-drive.png"> </p><p>結論から申し上げますと、 <strong>これは仮想マシン作成後の予期された動作であり、VM を割り当て解除することで消えます。</strong><br>以下に解説させていただきます。  </p><p>Azure の Marketplace から Windows の仮想マシンを作成した場合、初回起動の際に DVD ドライブ がマウントされる動作となります。<br>一時ディスクの無い VM サイズの場合は D ドライブに、<br>一時ディスクのある VM サイズの場合は E ドライブとして規定でマウントされると存じます。  </p><p>このドライブは、Windows 環境をデプロイする際にセットアップに必要な情報を読み込むためにマウントされますが、<br>お客様が仮想マシンを停止 (割り当て解除) された場合や、Azure 側のメンテナンスなどに伴ってホスト サーバーの変更が発生した際に切断されます。  </p><p>仮想マシンの停止 (割り当て解除) / 起動または再デプロイ、仮想マシンのサイズ変更などにより、仮想マシンへのリソースの割り当てを<br>一度解除いただくことで、次回起動時からはこの DVD ドライブ はマウントされません。  </p><p>なお、再起動や OS からのシャットダウンの場合は、仮想マシンへのリソースの割り当て解除が行われません。<br>そのため、Azure Portal 等より仮想マシンの停止 (割り当て解除) や再デプロイ等を行うようにお願いいたします。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの富田です。&lt;br&gt;&lt;strong&gt;Azure 上でデプロイした Windows の VM に D ドライブ や E ドライブとして CD / DVD ドライブが表示される&lt;/strong&gt;&lt;br&gt;というお問い合わせをいた</summary>
      
    
    
    
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
  </entry>
  
  <entry>
    <title>「仮想マシン エージェントの状態が準備できていません」について</title>
    <link href="https://jpaztech.github.io/blog/vm/vmagent-notready/"/>
    <id>https://jpaztech.github.io/blog/vm/vmagent-notready/</id>
    <published>2022-08-18T06:00:00.000Z</published>
    <updated>2023-01-10T02:14:50.820Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの大野です。</p><p>今回は、度々お問合せいただきます、こちらのメッセージについて、<br>想定される原因およびその判断ポイント、対処についてご紹介いたします。</p><span id="more"></span><p>結論からお伝えすると、このメッセージが表示されることが、<br>必ずしも対象仮想マシンへのネットワーク疎通が取れないことを意味するわけではありません。</p><p><img src="/blog/vm/vmagent-notready/vmagent-notready01.png"> </p><p>想定されるシナリオについては、以下 4 つに分類されるかと思います。</p><h2 id="「仮想マシンエージェントの状態が準備できていません」の想定シナリオ"><a href="#「仮想マシンエージェントの状態が準備できていません」の想定シナリオ" class="headerlink" title="「仮想マシンエージェントの状態が準備できていません」の想定シナリオ"></a>「仮想マシンエージェントの状態が準備できていません」の想定シナリオ</h2><table><thead><tr><th>シナリオ番号</th><th>想定されるシナリオ</th><th>SSH / RDP 接続可否</th></tr></thead><tbody><tr><td>1</td><td>仮想マシン エージェントが停止している</td><td>可</td></tr><tr><td>2</td><td>Wire Server (168.63.129.16) への疎通がゲストOS でブロックされている</td><td>可</td></tr><tr><td>3</td><td>ネットワーク インターフェースが無効化されている</td><td>不可</td></tr><tr><td>4</td><td>ゲスト OS がハング等により稼働していない</td><td>不可</td></tr></tbody></table><h2 id="シナリオ1-仮想マシン-エージェントが停止している"><a href="#シナリオ1-仮想マシン-エージェントが停止している" class="headerlink" title="シナリオ1 : 仮想マシン エージェントが停止している"></a>シナリオ1 : 仮想マシン エージェントが停止している</h2><p>意図的に仮想マシン エージェントのプロセスを停止されている他、<br>仮想マシン エージェントに内在する不具合によって起動していないケースもございます。</p><p>この場合、対象仮想マシンへの SSH 接続は引き続き可能ですが、<br>影響としては、仮想マシン エージェントが拡張機能の管理も兼ねているため、<br>拡張機能のインストールや動作に問題が生じることが想定されます。</p><p>それでは、Linux (Red Hat Enterprise Linux 8.6) で試してみます。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@rhel86 ~]<span class="comment"># systemctl status waagent.service </span></span><br><span class="line">● waagent.service - Azure Linux Agent</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/waagent.service; enabled; vendor preset: disabled)</span><br><span class="line">  Drop-In: /usr/lib/systemd/system/waagent.service.d</span><br><span class="line">           └─10-Slice.conf, 11-CPUAccounting.conf, 12-CPUQuota.conf</span><br><span class="line">   Active: active (running) since Sun 2022-08-14 15:09:14 UTC; 3min 6s ago</span><br><span class="line"> Main PID: 1484 (python3.6)</span><br><span class="line">    Tasks: 6 (<span class="built_in">limit</span>: 49437)</span><br><span class="line">   Memory: 40.8M</span><br><span class="line">      CPU: 6.239s</span><br><span class="line">   CGroup: /azure.slice/waagent.service</span><br><span class="line">           ├─1484 /usr/bin/python3.6 -u /usr/sbin/waagent -daemon</span><br><span class="line">           └─1719 /usr/bin/python3.6 -u bin/WALinuxAgent-2.7.3.0-py2.7.egg -run-exthandlers</span><br><span class="line"></span><br><span class="line">...(省略)...</span><br><span class="line"></span><br><span class="line">[root@rhel86 ~]<span class="comment"># systemctl stop waagent.service </span></span><br><span class="line">[root@rhel86 ~]<span class="comment"># systemctl status waagent.service</span></span><br><span class="line">● waagent.service - Azure Linux Agent</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/waagent.service; enabled; vendor preset: disabled)</span><br><span class="line">  Drop-In: /usr/lib/systemd/system/waagent.service.d</span><br><span class="line">           └─10-Slice.conf, 11-CPUAccounting.conf, 12-CPUQuota.conf</span><br><span class="line">   Active: inactive (dead) since Sun 2022-08-14 15:12:35 UTC; 6s ago</span><br><span class="line">  Process: 1484 ExecStart=/usr/bin/python3.6 -u /usr/sbin/waagent -daemon (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 1484 (code=exited, status=0/SUCCESS)</span><br><span class="line">      CPU: 6.318s</span><br><span class="line"></span><br><span class="line">...(省略)...</span><br></pre></td></tr></table></figure><p>しばらくしてから、対象仮想マシンの概要欄を確認すると、エラーになっていることがご確認いただけるかと思います。<br>一方、この状態では特段問題なく、SSH 接続いただけるかと思います。</p><p><img src="/blog/vm/vmagent-notready/vmagent-notready02.png"> </p><h3 id="判断いただくポイント"><a href="#判断いただくポイント" class="headerlink" title="判断いただくポイント"></a>判断いただくポイント</h3><p>このシナリオでは、SSH / RDP 接続が可能なため、<br>まずは対象仮想マシンにアクセスいただき、仮想マシン エージェントのサービスが起動しているか確認いただければと思います。</p><h3 id="想定される対処について"><a href="#想定される対処について" class="headerlink" title="想定される対処について"></a>想定される対処について</h3><p>仮想マシン エージェントが停止している場合には、手動で起動を実施いたします。</p><ul><li><a href="https://docs.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/linux-azure-guest-agent#troubleshoot-a-not-ready-status">準備ができていない状態のトラブルシューティング - Azure Linux エージェントのトラブルシューティング</a></li></ul><p>もし、手動で起動してもエラーとなるようでしたら、仮想マシン エージェントを更新し、<br>再度お試しいただき、起動いただけるか、ご確認ください。</p><ul><li><a href="https://docs.microsoft.com/ja-jp/azure/virtual-machines/extensions/update-linux-agent">VM で Azure Linux エージェントを更新する方法</a></li></ul><h2 id="シナリオ2-Wire-Server-168-63-129-16-への疎通がゲストOS-でブロックされている"><a href="#シナリオ2-Wire-Server-168-63-129-16-への疎通がゲストOS-でブロックされている" class="headerlink" title="シナリオ2 : Wire Server (168.63.129.16) への疎通がゲストOS でブロックされている"></a>シナリオ2 : Wire Server (168.63.129.16) への疎通がゲストOS でブロックされている</h2><p>Wire Server (168.63.129.16) は、仮想マシン内からのみアクセス可能な仮想パブリック IP アドレスになります。<br>仮想マシン エージェントからこの IP アドレスに対して正常性の通知を行っています。</p><p>この IP アドレスへの通信は、ネットワーク セキュリティ グループ (NSG) で制限することはできませんが、<br>ゲスト OS のファイアウォール機能にて制限は可能です。</p><p>試してみます。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@rhel86 ~]<span class="comment"># curl http://168.63.129.16/?comp=versions</span></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;Versions&gt;</span><br><span class="line">  &lt;Preferred&gt;</span><br><span class="line">    &lt;Version&gt;2015-04-05&lt;/Version&gt;</span><br><span class="line">  &lt;/Preferred&gt;</span><br><span class="line">  &lt;Supported&gt;</span><br><span class="line">    &lt;Version&gt;2015-04-05&lt;/Version&gt;</span><br><span class="line">    &lt;Version&gt;2012-11-30&lt;/Version&gt;</span><br><span class="line">    &lt;Version&gt;2012-09-15&lt;/Version&gt;</span><br><span class="line">    &lt;Version&gt;2012-05-15&lt;/Version&gt;</span><br><span class="line">    &lt;Version&gt;2011-12-31&lt;/Version&gt;</span><br><span class="line">    &lt;Version&gt;2011-10-15&lt;/Version&gt;</span><br><span class="line">    &lt;Version&gt;2011-08-31&lt;/Version&gt;</span><br><span class="line">    &lt;Version&gt;2011-04-07&lt;/Version&gt;</span><br><span class="line">    &lt;Version&gt;2010-12-15&lt;/Version&gt;</span><br><span class="line">    &lt;Version&gt;2010-28-10&lt;/Version&gt;</span><br><span class="line">  &lt;/Supported&gt;</span><br><span class="line">&lt;/Versions&gt;</span><br></pre></td></tr></table></figure><p>168.63.129.16 に対して、アウトバウンド方向の通信を遮断します。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@rhel86 ~]<span class="comment"># firewall-cmd --direct --add-rule ipv4 filter OUTPUT 0 -d  168.63.129.16/32 -j DROP</span></span><br><span class="line">success</span><br><span class="line">[root@rhel86 ~]<span class="comment"># firewall-cmd --direct --get-all-rules</span></span><br><span class="line">ipv4 filter OUTPUT 0 -d 168.63.129.16/32 -j DROP</span><br></pre></td></tr></table></figure><p>遮断されていることを確認します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@rhel86 ~]# curl http://168.63.129.16/?comp=versions</span><br><span class="line">curl: (7) Failed to connect to 168.63.129.16 port 80: Connection timed out</span><br></pre></td></tr></table></figure><p>しばらく経つと、こちらの場合も、Azure ポータルから仮想マシン エージェントに問題がある旨ご確認いただけるかと思います。</p><h3 id="判断いただくポイント-1"><a href="#判断いただくポイント-1" class="headerlink" title="判断いただくポイント"></a>判断いただくポイント</h3><p>シナリオ1 と同様に、SSH 接続は引き続き可能なため、<br>対象仮想マシンに SSH 接続いただき、シナリオ1 の点を確認いただければと思います。</p><p>こちらが問題なければ、168.63.129.16 に対してネットワーク疎通が取れているか確認いただくことで、<br>ご判断いただけるかと思います。</p><ul><li><a href="https://docs.microsoft.com/ja-jp/azure/virtual-network/what-is-ip-address-168-63-129-16#troubleshoot-connectivity">接続のトラブルシューティング - IP アドレス 168.63.129.16 とは</a></li></ul><p>その他ご判断いただく点といたしましては、仮想マシン エージェントのログ (<code>/var/log/waagent.log</code>) にて、<br>以下のようなログの出力からも Wire Server への疎通に問題があるということをご判断いただけるかと思います。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2022-08-11T07:27:33.509406Z ERROR SendTelemetryHandler ExtHandler Event: name=WALinuxAgent, op=ReportEventErrors, message=DroppedEventsCount: 1</span><br><span class="line">Reasons (first 5 errors): [ProtocolError] [Wireserver Exception] [HttpError] [HTTP Failed] POST http://168.63.129.16/machine -- IOError timed out -- 6 attempts made: Traceback (most recent call last):</span><br></pre></td></tr></table></figure><h3 id="想定される対処について-1"><a href="#想定される対処について-1" class="headerlink" title="想定される対処について"></a>想定される対処について</h3><p>上記の例では、ゲスト OS 内のファイアウォールの対象ルールを無効化いただくことで、<br>対処いただけますが、一概にこの点だけ確認すればよいというご案内ができないため、<br>適宜どのような制限が設定されているかご確認ください。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@rhel86 ~]<span class="comment"># firewall-cmd --direct --remove-rule ipv4 filter OUTPUT 0 -d  168.63.129.16/32 -j DROP</span></span><br><span class="line">success</span><br><span class="line">[root@rhel86 ~]<span class="comment"># firewall-cmd --direct --get-all-rules</span></span><br><span class="line">[root@rhel86 ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>また、特段制限をされていない場合、Wire Server 側に問題があることが想定されますので、<br>該当仮想マシンのご利用に影響がない時間を調整いただき、仮想マシンの再デプロイをご実施いただければと思います。</p><h2 id="シナリオ3-ネットワークインターフェースが無効化されている"><a href="#シナリオ3-ネットワークインターフェースが無効化されている" class="headerlink" title="シナリオ3 : ネットワークインターフェースが無効化されている"></a>シナリオ3 : ネットワークインターフェースが無効化されている</h2><p>こちらが仮想マシン エージェントが稼働していない = ネットワーク接続できないと思われてしまうシナリオになります。<br>これは反対で、アウトバウンド方向のネットワーク疎通が取れないために、結果として仮想マシン エージェントから Wire Server にアクセスができず、<br>仮想マシン エージェントの状態が Not Ready となります。</p><p>試しにネットワーク インターフェース eth0 を無効化してみます。<br>しばらく待つと、SSH 接続が途切れます。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@rhel86 ~]<span class="comment"># ifconfig eth0 down</span></span><br><span class="line">client_loop: send disconnect: Broken pipe</span><br></pre></td></tr></table></figure><p>その後再度 SSH 接続を試みますが、失敗します。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ ssh azureuser@xx.xxx.xxx.xxx</span><br><span class="line">ssh: connect to host xx.xxx.xxx.xxx port 22: Connection timed out</span><br></pre></td></tr></table></figure><p>また、仮想マシン エージェントが準備できていない旨のエラー メッセージが Azure ポータル上でご確認いただけるかと思います。</p><h3 id="判断いただくポイント-2"><a href="#判断いただくポイント-2" class="headerlink" title="判断いただくポイント"></a>判断いただくポイント</h3><p>こちらは対象仮想マシンのブート診断から参照可能なシリアル ログにて、下記のようにログイン プロンプトが表示されているかご確認いただければと思います。<br>(Windows の場合には、ブート診断機能で、スクリーンショットにロック画面が表示いただけるかの確認になります)。</p><p><img src="/blog/vm/vmagent-notready/vmagent-notready03.png"> </p><p>上記より、ゲスト OS としては稼働しているものの、ネットワークとして疎通が取れていないということが想定されます (シナリオ4 との切り分け)。</p><h3 id="想定される対処について-2"><a href="#想定される対処について-2" class="headerlink" title="想定される対処について"></a>想定される対処について</h3><p>ゲスト OS にてネットワークの疎通の問題においても、種々原因が上げられますため、<br>必ずこれを行えば解決するというものではございませんが、以下のネットワーク インターフェースのリセットや、<br>IP アドレスの固定化が設定されていないかご確認いただければと思います。</p><ul><li><a href="https://docs.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/reset-network-interface-azure-linux-vm">Azure Linux VM のネットワーク インターフェイスをリセットする</a></li></ul><p> 上記と併せ、下記ドキュメントの “VM に接続できない” より、Linux / Windows それぞれ特化したトラブルシューティング手順をご確認ください。</p><ul><li><a href="https://docs.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/welcome-virtual-machines">Azure Virtual Machinesトラブルシューティングのドキュメント</a></li></ul><h2 id="シナリオ4-ゲスト-OS-がハング等により稼働していない"><a href="#シナリオ4-ゲスト-OS-がハング等により稼働していない" class="headerlink" title="シナリオ4 : ゲスト OS がハング等により稼働していない"></a>シナリオ4 : ゲスト OS がハング等により稼働していない</h2><p>ゲスト OS が動作しておらず、結果その上で仮想マシン エージェントが動作していないというシナリオになります。</p><h3 id="判断いただくポイント-3"><a href="#判断いただくポイント-3" class="headerlink" title="判断いただくポイント"></a>判断いただくポイント</h3><p>シナリオ3 と同様、シリアル ログをご確認いただき、ログイン プロンプトが返ってきているかご確認いただき、<br>もしそうなっていないのであれば、ゲスト OS で正常にブートしていない可能性があります<br>(Windows の場合には、ブート診断機能で、スクリーンショットにロック画面が表示いただけるかの確認になります)。</p><p>下記の例では、存在しないマウントポイントをブート時にマウントしようとしてしまい、<br>Emergency モードで起動している状況になります。</p><p><img src="/blog/vm/vmagent-notready/vmagent-notready04.png"> </p><h3 id="想定される対処について-3"><a href="#想定される対処について-3" class="headerlink" title="想定される対処について"></a>想定される対処について</h3><p>再起動/再デプロイにより、復旧いただけるかまずはご確認いただくことと、<br>取得済みのバックアップ データから復旧いただくこととなります。</p><p>もし上記施策が当てはまらない場合は、下記仮想マシンのトラブルシューティング ガイドにあります、”VM のデプロイ、アップグレード、移行” の “VM がブートしていない” に、<br>Linux / Windows それぞれ特化したトラブルシューティング手順があるので、ご参考いただければと思います。<br>また、シリアルコンソール機能のご利用が必要となりましたら、同じく下記ドキュメントの “リモート トラブルシューティング ツール” の “シリアル コンソール” を併せてご確認いただければと思います。</p><ul><li><a href="https://docs.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/welcome-virtual-machines">Azure Virtual Machinesトラブルシューティングのドキュメント</a></li></ul><p>本記事が皆様のお役に立てれば幸いです。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの大野です。&lt;/p&gt;
&lt;p&gt;今回は、度々お問合せいただきます、こちらのメッセージについて、&lt;br&gt;想定される原因およびその判断ポイント、対処についてご紹介いたします。&lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="VM Agent" scheme="https://jpaztech.github.io/blog/tags/VM-Agent/"/>
    
  </entry>
  
  <entry>
    <title>Azure Firewall の各ルールの動作について</title>
    <link href="https://jpaztech.github.io/blog/network/firewall-rules/"/>
    <id>https://jpaztech.github.io/blog/network/firewall-rules/</id>
    <published>2022-08-16T03:30:00.000Z</published>
    <updated>2023-01-10T02:14:50.384Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チーム檜山です。</p><p>今回は Azure Firewall の各ルールの動作についてよくあるお問い合わせを紹介させていただきます。</p><hr><p><span id="apprule-block"></span></p><h2 id="Azure-Firewall-のアプリケーションルールで許可されているように見える動作について"><a href="#Azure-Firewall-のアプリケーションルールで許可されているように見える動作について" class="headerlink" title="Azure Firewall のアプリケーションルールで許可されているように見える動作について"></a><a href="#apprule-block">Azure Firewall のアプリケーションルールで許可されているように見える動作について</a></h2><p>HTTP (80), HTTPS (443) の通信において、ネットワークルール、アプリケーションルールで明示的に拒否していない場合、ルールの処理順序に従って、Azure Firewall の既定の動作として、アプリケーションルールで拒否されることが想定される動作となります。</p><p>この動作について Windows の Test-Netconnection や Linux の curl, nc コマンド等 (以下に記載) で TCP の 3way handshake による接続確認を実施した場合はアプリケーションルールで許可していないにもかかわらず、3way handshake が確立され、許可されたように見える動作となります。この動作の詳細を以下に記載します。</p><ul><li>Powershell Test-NetConnection コマンド (Windows)</li></ul><blockquote><p>Test-NetConnection -port 443 <a href="http://www.micorosoft.com/">www.micorosoft.com</a></p><p>ComputerName     : <a href="http://www.micorosoft.com/">www.micorosoft.com</a><br>RemoteAddress    : 40.76.4.15<br>RemotePort       : 443<br>InterfaceAlias   : Ethernet 2<br>SourceAddress    : 10.0.1.5<br><span style="color: red">TcpTestSucceeded : True</span></p></blockquote><ul><li>nc コマンド (linux)</li></ul><blockquote><p>$ nc -vz <a href="http://www.microsoft.com/">www.microsoft.com</a> 443<br>Ncat: Version 7.50 ( <a href="https://nmap.org/ncat">https://nmap.org/ncat</a> )<br><span style="color: red">Ncat: Connected to 23.33.181.181:443.</span><br>Ncat: 0 bytes sent, 0 bytes received in 0.02 seconds.</p></blockquote><h3 id="Azure-Firewall-のアプリケーションルールの動作の詳細について"><a href="#Azure-Firewall-のアプリケーションルールの動作の詳細について" class="headerlink" title="Azure Firewall のアプリケーションルールの動作の詳細について"></a>Azure Firewall のアプリケーションルールの動作の詳細について</h3><p>上述の通り、TCP 80, 443 宛の通信について、ネットワークルールで明示的な拒否、許可がない場合、アプリケーションルールで評価され、許可ルールがない場合は既定の動作としてアプリケーションルールにて拒否されます。<br>アプリケーションルールでは HTTP のホストヘッダ、HTTPS の SNI の Server Name をもとにアプリケーションルール内の FQDN とマッチするかを確認して評価が行われます。</p><p>アプリケーションルールは L7 で動作しますので、内部的には クライアントと Azure Firewall 間で 3way handshake を確立し、HTTP , HTTPS の情報に基づいて通信を制御しますので、3way handshake が確立されることは想定される動作となります。</p><p>NSG にて接続が拒否されている Web サーバーにアクセスした際も、宛先アドレスと 3way handshake は確立可能で、HTTP, HTTPS のレイヤーで拒否されていることから、Azure Firewall が送信元を変換してパケットを返送するような動作であることが確認できます。</p><p><strong>そのため、アプリケーションルールで実際に通信が拒否されるかどうかを確認する際は、ブラウザや curl コマンド等で Web サイトへアクセスし、エラーによりクライアントへ期待される応答 (Status 200 等) が返らないことをご確認ください。</strong></p><p>アプリケーションルールにて拒否されている場合はブラウザや curl コマンドだと以下のような動作となります。</p><ul><li>Chrome [HTTP]</li></ul><table><thead><tr><th align="center"><img src="/blog/network/firewall-rules/http-deny-browser.png" alt="HTTP拒否"></th></tr></thead></table><ul><li>Chrome [HTTPS]</li></ul><table><thead><tr><th align="center"><img src="/blog/network/firewall-rules/https-deny-browser.png" alt="HTTPS拒否"></th></tr></thead></table><ul><li>curl コマンド (HTTP)</li></ul><blockquote><p>$ curl -v <a href="http://www.microsoft.com/">http://www.microsoft.com</a></p><p>About to connect() to <a href="http://www.microsoft.com/">www.microsoft.com</a> port 80 (#0)<br>   Trying 23.33.181.181…<br>Connected to <a href="http://www.microsoft.com/">www.microsoft.com</a> (23.33.181.181) port 80 (#0)<br>GET / HTTP/1.1<br>User-Agent: curl/7.29.0<br>Host: <a href="http://www.microsoft.com/">www.microsoft.com</a><br>Accept: <em>/</em></p><p>HTTP/1.1 470 status code 470<br>Date: Mon, 29 Mar 2021 04:29:57 GMT<br>Content-Length: 144<br>Content-Type: text/plain; charset=utf-8<br>Connection #0 to host <a href="http://www.microsoft.com/">www.microsoft.com</a> left intact<br><span style="color: red">HTTP  request from 10.0.1.4:53460 to <a href="http://www.microsoft.com/">www.microsoft.com:80</a>. Url: <a href="http://www.microsoft.com/">www.microsoft.com</a>. Action: Deny. No rule matched. Proceeding with default action</span></p></blockquote><ul><li>curl コマンド (HTTPS)</li></ul><blockquote><p>$ curl -v <a href="https://www.microsoft.com/">https://www.microsoft.com</a></p><p>About to connect() to <a href="http://www.microsoft.com/">www.microsoft.com</a> port 443 (#0)<br>  Trying 23.33.181.181…<br>Connected to <a href="http://www.microsoft.com/">www.microsoft.com</a> (23.33.181.181) port 443 (#0)<br>Initializing NSS with certpath: sql:/etc/pki/nssdb<br>  CAfile: /etc/pki/tls/certs/ca-bundle.crt<br>CApath: none<br><span style="color: red">NSS error -5938 (PR_END_OF_FILE_ERROR)</span><br><span style="color: red">Encountered end of file</span><br><span style="color: red">Closing connection 0</span><br><span style="color: red">curl: (35) Encountered end of file</span></p></blockquote><p><span id="difference-net-app"></span></p><h2 id="ネットワークルールと、アプリケーションルールの動作の違いについて"><a href="#ネットワークルールと、アプリケーションルールの動作の違いについて" class="headerlink" title="ネットワークルールと、アプリケーションルールの動作の違いについて"></a><a href="#difference-net-app">ネットワークルールと、アプリケーションルールの動作の違いについて</a></h2><h3 id="ネットワークルールの動作について"><a href="#ネットワークルールの動作について" class="headerlink" title="ネットワークルールの動作について"></a>ネットワークルールの動作について</h3><p>ネットワークルールは L4 で動作します。TCP の通信で宛先アドレス、宛先ポートが拒否されている場合、Azure Firewall は SYN/ACK を返しませんので、3way handshake に失敗し、通信が拒否される動作となります。</p><h3 id="アプリケーションルールとネットワークルールの動作の違いについて"><a href="#アプリケーションルールとネットワークルールの動作の違いについて" class="headerlink" title="アプリケーションルールとネットワークルールの動作の違いについて"></a>アプリケーションルールとネットワークルールの動作の違いについて</h3><p>上述の通り、ネットワークルールは L4 で動作し、アプリケーションルールは L7 で動作します。<br>どちらのルールを使用すべきかについては以下がベストプラクティスとなりますので、ご確認いただけますと幸いです。</p><ol><li>HTTP, HTTPS の通信において FQDN ベースで通信を制御できるものはアプリケーションルールを利用する</li><li>HTTP, HTTPS の通信において FQDN ベースで通信を制御できないものはネットワークルールを利用する</li><li>HTTP, HTTPS, MSSQL 以外の通信はネットワークルールを利用する</li></ol><h3 id="アプリケーションルールとネットワークルールの-FQDN-のフィルタリングについて"><a href="#アプリケーションルールとネットワークルールの-FQDN-のフィルタリングについて" class="headerlink" title="アプリケーションルールとネットワークルールの FQDN のフィルタリングについて"></a>アプリケーションルールとネットワークルールの FQDN のフィルタリングについて</h3><p>現在はアプリケーションルール、ネットワークルールどちらでも FQDN のフィルタリングが可能です。<br>ベストプラクティスは上述の通りとなりますが、HTTP, HTTPS の通信でアプリケーションルールの利用を推奨する理由としては以下もございます。</p><ul><li>IP アドレスが同一になるような FQDN でも制御可能 (CDN や AppService 等の同一 IP アドレスを複数のユーザーが利用する基盤が宛先となっている場合でも制御が可能)</li><li>ワイルドカードによる FQDN の指定が可能</li><li>DNS Proxy の利用が不要 (クライアント側の DNS の設定変更も不要)</li><li>Web トラフィックに対する今後の機能追加が優先的に行われる可能性がある </li></ul><p>ネットワークルールでの FQDN のフィルタリングは以下もご一読ください。</p><p><a href="https://docs.microsoft.com/ja-jp/azure/firewall/fqdn-filtering-network-rules">ネットワーク ルールでの FQDN フィルタリング</a></p><p><a href="https://docs.microsoft.com/ja-jp/azure/firewall/dns-settings">Azure Firewall の DNS 設定</a></p><h2 id="Azure-Firewall-のルールの処理順序-フローチャート"><a href="#Azure-Firewall-のルールの処理順序-フローチャート" class="headerlink" title="Azure Firewall のルールの処理順序 (フローチャート)"></a>Azure Firewall のルールの処理順序 (フローチャート)</h2><p>Azure Firewall のルールの処理順序がわかりにくいというお問い合わせをいただくことがございます。以下のフローチャートにて詳細を記載しておりますのでご確認ください。</p><p><img src="/blog/network/firewall-rules/FWdefault-flow.png" alt="フローチャート"></p><p><span id="faq"></span></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a><a href="#faq">FAQ</a></h2><h4 id="設定変更時に既存接続への影響はありますか。"><a href="#設定変更時に既存接続への影響はありますか。" class="headerlink" title="- 設定変更時に既存接続への影響はありますか。"></a>- 設定変更時に既存接続への影響はありますか。</h4><p>DNAT ルール, ネットワークルール, アプリケーションルールの設定変更において、既存の接続に影響が出るような設定変更でなければ既存の接続に影響がでない動作となることを確認しております。</p><h4 id="戻りのパケットは診断ログに記録されますか。"><a href="#戻りのパケットは診断ログに記録されますか。" class="headerlink" title="- 戻りのパケットは診断ログに記録されますか。"></a>- 戻りのパケットは診断ログに記録されますか。</h4><p>ネットワークルールでは TCP の SYN パケットに対して許可/拒否が記録されますが、戻りのパケット (SYN/ACK) は診断ログには記録されない動作となります。</p><h4 id="「Action-Deny-Reason-SNI-TLS-extension-was-missing」で拒否される理由を教えてください。"><a href="#「Action-Deny-Reason-SNI-TLS-extension-was-missing」で拒否される理由を教えてください。" class="headerlink" title="- 「Action: Deny. Reason: SNI TLS extension was missing」で拒否される理由を教えてください。"></a>- 「Action: Deny. Reason: SNI TLS extension was missing」で拒否される理由を教えてください。</h4><p>アプリケーションルールでは TLS の通信を評価する際に Client Hello に含まれる SNI の Server Name を参照し、評価を行っております。そのため、SNI が利用されない通信はアプリケーションルールで制御することができません。</p><p>例えば、<a href="https://1.2.3.4/">https://1.2.3.4</a> のような IP アドレスでアクセスするような方法ですと、SNI が含まれるずにアプリケーションルールで拒否されることが想定されます。対応策としてはネットワークルールにて制御する必要があります。</p><p><a href="https://docs.microsoft.com/ja-jp/azure/firewall/overview#known-issues">既知の問題</a></p><h4 id="NAT-ルールで拒否のログが記録されません。"><a href="#NAT-ルールで拒否のログが記録されません。" class="headerlink" title="- NAT ルールで拒否のログが記録されません。"></a>- NAT ルールで拒否のログが記録されません。</h4><p>NAT ルールで指定されている宛先ポート以外の通信のログは出力されない動作となります。NAT ルールが構成されている宛先ポートに対して通信を行い、拒否のログが出力されるかをご確認ください。</p><h4 id="NAT-ルールの処理順序をおしえてください。"><a href="#NAT-ルールの処理順序をおしえてください。" class="headerlink" title="- NAT ルールの処理順序をおしえてください。"></a>- NAT ルールの処理順序をおしえてください。</h4><ul><li>NAT ルールはネットワークルールより優先的に評価されます。</li><li>NAT ルールが適用されたトラフィックは暗黙的なネットワークルールにより許可されますが、この暗黙的なルールの優先度は明示的なネットワークルールの優先度よりも低くなります。</li></ul><h4 id="ブラックリスト形式でルールを設定できますか。"><a href="#ブラックリスト形式でルールを設定できますか。" class="headerlink" title="- ブラックリスト形式でルールを設定できますか。"></a>- ブラックリスト形式でルールを設定できますか。</h4><p>Azure Firewall は既定でホワイトリスト形式ですが、優先度が低いルールで広い範囲で許可するルールコレクションを設定し、優先度が高いルールコレクションで特定の通信を拒否するルールを設定することでブラックリスト形式で対応することができます。</p><p>以下は設定例です。</p><table><thead><tr><th>優先度</th><th>ネットワーク ルールコレクション</th><th>プロトコル</th><th>送信元</th><th>宛先</th><th>宛先ポート</th><th>アクション</th></tr></thead><tbody><tr><td>100</td><td>Deny-SSH</td><td>TCP</td><td>10.0.0.0/8</td><td>1.2.3.4/32</td><td>22</td><td>Deny</td></tr><tr><td>200</td><td>Allow-ALL</td><td>TCP</td><td>Any</td><td>Any</td><td>*</td><td>Allow</td></tr></tbody></table><p><em><strong>ただし、拒否ルールを作成する際は TCP の戻りのパケット (SYN/ACK) を拒否しないように考慮する必要があります。</strong></em><br>以下のドキュメントにも記載がありますが、TCP の戻りのパケット (SYN/ACK) を拒否するようなルールがある場合、SYN パケットが許可された後も、SYN/ACK パケットが Azure Firewall で拒否されてしまい通信を確立することができません。<br>診断ログにも出力されない動作であることを確認しているため、注意が必要です。</p><p><a href="https://docs.microsoft.com/ja-jp/azure/firewall/rule-processing#three-way-handshake-behavior">https://docs.microsoft.com/ja-jp/azure/firewall/rule-processing#three-way-handshake-behavior</a></p><blockquote><p>ステートフル サービスとして、Azure Firewall では、送信元から送信先への許可されたトラフィックに対する TCP 3 方向ハンドシェイクを行います。 たとえば、VNet-A から VNet-B などです。<br>VNet-A から VNet-B への許可規則を作成しても、VNet-B から VNet-A への新たに開始される接続が許可されるわけではありません。<br>そのため、VNet-B から VNet-A への明示的な拒否規則を作成する必要はありません。 この拒否規則を作成すると、VNet-A から VNet-B への最初の許可規則の 3 方向ハンドシェイクを中断することになります。</p></blockquote><h2 id="参考情報"><a href="#参考情報" class="headerlink" title="参考情報"></a>参考情報</h2><p>Azure Firewall の概要や機能については以下にも記載がありますのでご一読ください。</p><p><a href="https://docs.microsoft.com/ja-jp/azure/firewall/overview">Azure Firewall とは</a></p><p><a href="https://docs.microsoft.com/ja-jp/azure/firewall/features">Azure Firewall の機能</a></p><p><a href="https://docs.microsoft.com/ja-jp/azure/firewall/firewall-faq">Azure Firewall FAQ</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チーム檜山です。&lt;/p&gt;
&lt;p&gt;今回は Azure Firewall の各ルールの動作についてよくあるお問い合わせを紹介させていただきます。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;span id=&quot;apprule-block&quot;&gt;&lt;/span</summary>
      
    
    
    
    
    <category term="Network" scheme="https://jpaztech.github.io/blog/tags/Network/"/>
    
    <category term="Azure Firewall" scheme="https://jpaztech.github.io/blog/tags/Azure-Firewall/"/>
    
  </entry>
  
  <entry>
    <title>イベント ログ Service Control Manage 7031 - RdAgent サービスの再起動について</title>
    <link href="https://jpaztech.github.io/blog/vm/7031-rdagent-restart/"/>
    <id>https://jpaztech.github.io/blog/vm/7031-rdagent-restart/</id>
    <published>2022-05-23T08:30:00.000Z</published>
    <updated>2023-01-10T02:14:50.484Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポート チームの前田です。</p><p>Azure 上の Windows 仮想マシンをご利用のお客様から、RdAgent サービスの再起動を示すイベント ログ Service Control Manager 7031 の原因や影響についてお問い合わせいただくことがあります。そのため、本記事では当該イベントについてご紹介します。</p><span id="more"></span><p><img src="/blog/vm/7031-rdagent-restart/01.png"></p><blockquote><p>ログの名前:   System<br>ソース:       Service Control Manager<br>日付:         yyyy/mm/dd hh:mm:ss<br>イベント ID:  7031<br>レベル:       エラー<br>キーワード:   クラシック<br>説明:<br>RdAgent サービスは予期せぬ原因により終了しました。<br>このサービスの終了は 1 回目です。<br>次の修正操作が 0 ミリ秒以内に実行されます: サービスの再開。</p></blockquote><hr><h2 id="イベント-ログ-Service-Control-Manage-7031"><a href="#イベント-ログ-Service-Control-Manage-7031" class="headerlink" title="イベント ログ Service Control Manage 7031"></a>イベント ログ Service Control Manage 7031</h2><p>RdAgent サービスの予期せぬ終了を示すイベント ログ Service Control Manager 7031 は、一般的に、Windows Azure ゲスト エージェントのアップデート時に実施されるエージェントの再起動に起因して記録されるメッセージとなります。<br>※アップデートは必要に応じて不定期に実施されます。</p><p>アップデート時には新しいバージョンで Windows Azure ゲスト エージェントを起動する必要があるため、サービスの再起動が発生します。そのため、アップデート時に本イベントのエラー メッセージが記録されることは想定通りの動作となります。</p><p>イベント記録後に RdAgent サービスが再開されており、エラー メッセージが継続して出力されていないような場合には、静観いただいて問題ありません。RdAgent サービスが再開された場合には、イベント ログ Service Control Manager 7036 が記録されますのでご確認いただけますと幸いです。</p><p><img src="/blog/vm/7031-rdagent-restart/02.png"></p><blockquote><p>ログの名前:   System<br>ソース:       Service Control Manager<br>日付:         yyyy/mm/dd hh:mm:ss<br>イベント ID:  7036<br>レベル:       情報<br>キーワード:   クラシック<br>説明:<br>RdAgent サービスは 実行中 状態に移行しました。</p></blockquote><h2 id="仮想マシン-エージェントのアップデートと-RdAgent-サービスの再起動"><a href="#仮想マシン-エージェントのアップデートと-RdAgent-サービスの再起動" class="headerlink" title="仮想マシン エージェントのアップデートと RdAgent サービスの再起動"></a>仮想マシン エージェントのアップデートと RdAgent サービスの再起動</h2><p>アップデートの有無についてはイベント ログから判断することは叶わず、C:\WindowsAzure\Logs 配下に出力される WaAppAgent.log を確認する必要があります。</p><h3 id="WaAppAgent-log"><a href="#WaAppAgent-log" class="headerlink" title="WaAppAgent.log"></a>WaAppAgent.log</h3><p>Windows Azure ゲスト エージェントのアップデート時には、C:\WindowsAzure\Logs 配下に出力される WaAppAgent.log に下記のようなログが記録されます。</p><blockquote><p>(前のバージョンでの起動を示すログ)<br><em>[000000XX] [XX/XX/XXXX XX:XX:XX.XX] [INFO]  WindowsAzureGuestAgent starting.  Version X.X.XXXXX.XXX</em><br>…<br>(アップデート処理により停止処理が開始されたことを示すログ)<br><em>[000000XX] [XX/XX/XXXX XX:XX:XX.XX] [WARN]  Stopping from update</em><br>…<br>(エージェントが停止して新しいバージョンでの起動を示すログ)<br><em>[000000XX] [XX/XX/XXXX XX:XX:XX.XX] [INFO]  WindowsAzureGuestAgent stopped successfully.</em><br><em>[000000XX] [XX/XX/XXXX XX:XX:XX.XX] [INFO]  WindowsAzureGuestAgent starting. Version X.X.XXXXX.YYY</em></p></blockquote><h3 id="確認の結果アップデート起因ではない場合"><a href="#確認の結果アップデート起因ではない場合" class="headerlink" title="確認の結果アップデート起因ではない場合"></a>確認の結果アップデート起因ではない場合</h3><p>アップデートの有無にかかわらず、イベント記録後に RdAgent サービスが再開されており、エラー メッセージが継続して出力されていないような場合には、静観いただいて問題ありません。<br>もし、仮想マシン エージェント自体の動作に問題がある場合には、後述の「<a href="https://jpaztech.github.io/blog/vm/7031-rdagent-restart/#%E3%81%8A%E3%81%BE%E3%81%91-%E4%BB%AE%E6%83%B3%E3%83%9E%E3%82%B7%E3%83%B3-%E3%82%A8%E3%83%BC%E3%82%B8%E3%82%A7%E3%83%B3%E3%83%88%E3%81%AE%E7%8A%B6%E6%85%8B%E7%A2%BA%E8%AA%8D%E6%96%B9%E6%B3%95">[おまけ] 仮想マシン エージェントの状態確認方法</a>」をご確認の上、切り分けいただけますと幸いです。</p><hr><h2 id="補足情報"><a href="#補足情報" class="headerlink" title="補足情報"></a>補足情報</h2><h3 id="仮想マシン-エージェントとは"><a href="#仮想マシン-エージェントとは" class="headerlink" title="仮想マシン エージェントとは"></a>仮想マシン エージェントとは</h3><p>仮想マシン エージェントとは、仮想マシンと Azure 基盤側とのやり取りを管理するプロセスであり、仮想マシンの拡張機能の管理や仮想マシンのステータスの報告などを実施しています。<br>Windows 仮想マシンには Windows Azure ゲスト エージェントが、Linux 仮想マシンには Azure Linux エージェント (waagent) があります。</p><blockquote><p>ご参考) [Windows] Azure 仮想マシン エージェントの概要<br><a href="https://docs.microsoft.com/ja-jp/azure/virtual-machines/extensions/agent-windows">https://docs.microsoft.com/ja-jp/azure/virtual-machines/extensions/agent-windows</a></p></blockquote><blockquote><p>ご参考) [Linux] Azure Linux エージェントの理解と使用<br><a href="https://docs.microsoft.com/ja-jp/azure/virtual-machines/extensions/agent-linux">https://docs.microsoft.com/ja-jp/azure/virtual-machines/extensions/agent-linux</a></p></blockquote><h3 id="Windows-仮想マシンの仮想マシン-エージェント-Windows-Azure-ゲスト-エージェント"><a href="#Windows-仮想マシンの仮想マシン-エージェント-Windows-Azure-ゲスト-エージェント" class="headerlink" title="Windows 仮想マシンの仮想マシン エージェント (Windows Azure ゲスト エージェント)"></a>Windows 仮想マシンの仮想マシン エージェント (Windows Azure ゲスト エージェント)</h3><p>Windows Azure ゲスト エージェントは、Azure Marketplace イメージからデプロイされたすべての Windows 仮想マシンに既定でインストールされます。<br>Windows インストーラー パッケージを使用して、手動でインストールすることも可能であり、カスタム イメージを用いて仮想マシンを作成するときやオンプレミス環境を移行いただく際には、手動でのインストールが必要な場合があります。</p><p>Windows 仮想マシンに Windows Azure ゲスト エージェントが正常にインストールされると、次のサービスが 仮想マシンの services.msc に一覧表示されます。</p><ul><li>Windows Azure ゲスト エージェント サービス</li><li>テレメトリ サービス (バージョン 2.7.41491.971 以降のバージョンでは表示されません)</li><li>RdAgent サービス</li></ul><h3 id="RdAgent-とは"><a href="#RdAgent-とは" class="headerlink" title="RdAgent とは"></a>RdAgent とは</h3><p>RdAgent とは、Windows Azure ゲスト エージェント (Windows OS 用の仮想マシン エージェント) のサービスの 1 つであり、RdAgent サービスはゲスト エージェントのインストールや、仮想マシンから物理ホスト上のホスト エージェントにハートビートを送信する役割を担っています。</p><h3 id="RdAgent-が停止している場合の影響"><a href="#RdAgent-が停止している場合の影響" class="headerlink" title="RdAgent が停止している場合の影響"></a>RdAgent が停止している場合の影響</h3><p>RdAgent サービスが実行されていない場合、Windows Azure ゲスト エージェントが正しく動作しません。<br>ゲスト OS 内の動作 (システムやご利用のアプリケーション) には影響しませんが、Azure 基盤側でゲスト OS の状態を取得できずに、プロビジョニングがタイムアウトとなるまで完了しない、拡張機能が正しくご利用いただけない、といったことが発生します。</p><h3 id="おまけ-仮想マシン-エージェントの状態確認方法"><a href="#おまけ-仮想マシン-エージェントの状態確認方法" class="headerlink" title="[おまけ] 仮想マシン エージェントの状態確認方法"></a>[おまけ] 仮想マシン エージェントの状態確認方法</h3><p>仮想マシン エージェントの状態は Azure Portal より確認することが可能です。<br>[Virtual Machines] - [&lt;当該仮想マシン&gt;] のページを開き、左メニュー [概要] の下記画面にて “エージェントの状態” が “Ready” であれば問題なく稼働していると判断できます。</p><p><img src="/blog/vm/7031-rdagent-restart/03.png"></p><p>なお、仮想マシン エージェントが正しく稼働していないように見受けられる場合のトラブルシューティングは、下記公開情報をご確認ください。</p><blockquote><p>ご参考) Azure ゲスト Windowsのトラブルシューティング<br><a href="https://docs.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/windows-azure-guest-agent">https://docs.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/windows-azure-guest-agent</a></p></blockquote><blockquote><p>ご参考) Windows ゲスト エージェント (WinGA) の再インストール方法<br><a href="https://jpaztech.github.io/blog/vm/re-install-windows-azure-guest-agent/">https://jpaztech.github.io/blog/vm/re-install-windows-azure-guest-agent/</a></p></blockquote><br>いかがでしたでしょうか。イベント ログでエラーが記録されていると、影響や対処の有無などでご心配いただくことも多いかと存じますが、RdAgent サービスの予期せぬ終了を示すイベント ログに関して、上記情報がお役に立てれば幸いです。]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポート チームの前田です。&lt;/p&gt;
&lt;p&gt;Azure 上の Windows 仮想マシンをご利用のお客様から、RdAgent サービスの再起動を示すイベント ログ Service Control Manager 7031 の原因や影響についてお問い合わせいただくことがあります。そのため、本記事では当該イベントについてご紹介します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
  </entry>
  
  <entry>
    <title>Azure VM からストレージ アカウントへアクセスする際の挙動とアクセス元制御</title>
    <link href="https://jpaztech.github.io/blog/storage/storageFirewall-accesscontroll/"/>
    <id>https://jpaztech.github.io/blog/storage/storageFirewall-accesscontroll/</id>
    <published>2022-05-06T01:30:00.000Z</published>
    <updated>2023-01-10T02:14:50.484Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの木下です。<br>今回は、Azure VM からストレージ アカウントへアクセスする際の挙動とアクセス元制御ついてご案内します。</p><span id="more"></span><h2 id="Azure-VM-からストレージ-アカウントへアクセスする際の挙動"><a href="#Azure-VM-からストレージ-アカウントへアクセスする際の挙動" class="headerlink" title="Azure VM からストレージ アカウントへアクセスする際の挙動"></a>Azure VM からストレージ アカウントへアクセスする際の挙動</h2><p>VM からストレージ アカウントへアクセスを行う場合、両者のリージョンが異なる場合と、同じ場合ではアクセス元の IP アドレスが異なる点に、ご注意ください。</p><h3 id="VM-とストレージ-アカウントが同一リージョンに存在する場合"><a href="#VM-とストレージ-アカウントが同一リージョンに存在する場合" class="headerlink" title="VM とストレージ アカウントが同一リージョンに存在する場合"></a>VM とストレージ アカウントが同一リージョンに存在する場合</h3><p><strong>パブリック エンドポイント または サービス エンドポイントを使用</strong></p><p>VM からストレージ アカウントへアクセスすると、アクセス元 IP は VM のパブリック IP とならず、Azure 内部で使用しているプライベート IP となります。</p><h3 id="VM-とストレージ-アカウントが異なるリージョンに存在する場合"><a href="#VM-とストレージ-アカウントが異なるリージョンに存在する場合" class="headerlink" title="VM とストレージ アカウントが異なるリージョンに存在する場合"></a>VM とストレージ アカウントが異なるリージョンに存在する場合</h3><p><strong>パブリック エンドポイントを使用</strong></p><p>VM からストレージ アカウントへアクセスすると、アクセス元 IP は VM のパブリック IP となります。</p><p><strong>サービス エンドポイントを使用</strong></p><p>VM からストレージ アカウントへアクセスすると、アクセス元 IP は VM のパブリック IP とならず、Azure 内部で使用しているプライベート IP となります。</p><p>(ご留意)<br>サービス エンドポイントがある仮想ネットワークのリージョンがペア リージョンではない他のリージョンである場合、アクセス元 IP は VM のパブリック IP となります。<br>ただ、現在、プレビュー段階ではありますが、ペア リージョン以外の他のリージョンにある仮想ネットワークからのアクセスにおいてもサービス エンドポイントを利用することが可能となりましました。<br>つまり、サービス エンドポイントを有効化することで、他のリージョンからのアクセスの際にパブリック IP ではなく、Azure 内部で使用しているプライベート IP を利用することができるようになりました。</p><p>参考）すべての地域の Azure リージョン間レプリケーションのペアリング<br><a href="https://docs.microsoft.com/ja-jp/azure/availability-zones/cross-region-replication-azure#azure-cross-region-replication-pairings-for-all-geographies">https://docs.microsoft.com/ja-jp/azure/availability-zones/cross-region-replication-azure#azure-cross-region-replication-pairings-for-all-geographies</a><br>※ペア リージョン例: 東日本リージョンと西日本リージョン</p><p>参考）Azure Storage ファイアウォールおよび仮想ネットワークを構成する &gt; 他のリージョンの仮想ネットワークへのアクセスを有効にする (プレビュー)<br><a href="https://docs.microsoft.com/ja-jp/azure/storage/common/storage-network-security?tabs=azure-powershell#enabling-access-to-virtual-networks-in-other-regions-preview">https://docs.microsoft.com/ja-jp/azure/storage/common/storage-network-security?tabs=azure-powershell#enabling-access-to-virtual-networks-in-other-regions-preview</a></p><blockquote><p>&lt;抜粋&gt;</p><p>別のリージョンにある仮想ネットワークからのアクセスを有効にするには、仮想ネットワークのサブスクリプションに AllowGlobalTagsForStorage 機能を登録します。 ストレージ サービス エンドポイントを備えた他のリージョンにあるサブネットでは、ストレージ アカウントとの通信にパブリック IP アドレスを使用しなくなりました。 トラフィックはすべてプライベート IP アドレスから送信され、それらのサブネットからのトラフィックを許可する IP ネットワーク ルールはいずれも影響を受けなくなりました。</p></blockquote><h3 id="VM-からストレージアカウントへのアクセス検証"><a href="#VM-からストレージアカウントへのアクセス検証" class="headerlink" title="VM からストレージアカウントへのアクセス検証"></a>VM からストレージアカウントへのアクセス検証</h3><p>・VM (東日本) から、ストレージ アカウント (東日本) に対して AzCopy を実施した結果</p><p>[ VM の構成 ]</p><p>パブリック IP : 40.115.XX.XX<br>プライベート IP : 10.1.0.4</p><p>[ ストレージ アカウントの診断ログ] ※1 、※2</p><p>サービス エンドポイント無効、パブリック エンドポイント経由のアクセス</p><blockquote><p>1.0;2022-05-01T09:19:01.3225693Z;GetBlobProperties;SASSuccess;200;4;4;sas;;storageaccountname;blob;”<a href="https://storageaccountname.blob.core.windows.net/container01/test.csv?sas&quot;;&quot;/storageaccountname/container01/test.csv&quot;;XXXXXXXXXXXXXXXXXXXXXXX;0;10.1.0.4:50100;2019-12-12;413;0;543;0;0;;;&quot;&quot;0x8DXXXXXXXXXXXXX&quot;&quot;;Sunday">https://storageaccountname.blob.core.windows.net:443/container01/test.csv?sas&quot;;&quot;/storageaccountname/container01/test.csv&quot;;XXXXXXXXXXXXXXXXXXXXXXX;0;10.1.0.4:50100;2019-12-12;413;0;543;0;0;;;&quot;&quot;0x8DXXXXXXXXXXXXX&quot;&quot;;Sunday</a>, 01-May-22 09:19:01 GMT;;”AzCopy/10.6.0 Azure-Storage/0.10 (go1.13; Windows_NT)”;;”XXXXXXXXXXXXXXXXXXXXXXXX”</p></blockquote><p>アクセス元 IP は 10.1.0.4 であることが分かります。</p><p>サービス エンドポイント有効、サービス エンドポイント経由のアクセス</p><blockquote><p>1.0;2022-05-01T10:43:08.5058732Z;PutBlob;SASSuccess;201;12;12;sas;;akstor001;blob;”<a href="https://storageaccountname.blob.core.windows.net/container01/test.csv?sas&quot;;&quot;/storageaccountname/container01/test.csv&quot;;XXXXXXXXXXXXXXXXXXXXXXX;0;10.1.0.4:50636;2019-12-12;624;806;337;0;806;;&quot;XXXXXXXXXXXXXXXXXXXXXXXX&quot;;&quot;&quot;0x8DXXXXXXXXXXXXX&quot;&quot;;Sunday">https://storageaccountname.blob.core.windows.net:443/container01/test.csv?sas&quot;;&quot;/storageaccountname/container01/test.csv&quot;;XXXXXXXXXXXXXXXXXXXXXXX;0;10.1.0.4:50636;2019-12-12;624;806;337;0;806;;&quot;XXXXXXXXXXXXXXXXXXXXXXXX&quot;;&quot;&quot;0x8DXXXXXXXXXXXXX&quot;&quot;;Sunday</a>, 01-May-22 10:43:08 GMT;;”AzCopy/10.6.0 Azure-Storage/0.10 (go1.13; Windows_NT)”;;”XXXXXXXXXXXXXXXXXXXXXXXX”</p></blockquote><p>アクセス元 IP は 10.1.0.4 であることが分かります。</p><p>・VM (西日本) から、ストレージ アカウント (東日本) に対して AzCopy を実施した結果</p><p>[ VM の構成 ]</p><p>パブリック IP : 20.89.XX.XX<br>プライベート IP : 10.4.0.4</p><p>[ ストレージ アカウントの診断ログ ] ※1 、※2</p><p>サービス エンドポイント無効、パブリック エンドポイント経由のアクセス</p><blockquote><p>1.0;2022-05-01T09:20:17.4989380Z;GetBlobProperties;SASSuccess;200;3;3;sas;;storageaccountname;blob;”<a href="https://storageaccountname.blob.core.windows.net/container02/test.csv?sas&quot;;&quot;/storageaccountname/container02/test.csv&quot;;XXXXXXXXXXXXXXXXXXXXXXX;0;20.89.XX.XX:49842;2019-12-12;413;0;543;0;0;;;&quot;&quot;0x8DXXXXXXXXXXXXX&quot;&quot;;Sunday">https://storageaccountname.blob.core.windows.net:443/container02/test.csv?sas&quot;;&quot;/storageaccountname/container02/test.csv&quot;;XXXXXXXXXXXXXXXXXXXXXXX;0;20.89.XX.XX:49842;2019-12-12;413;0;543;0;0;;;&quot;&quot;0x8DXXXXXXXXXXXXX&quot;&quot;;Sunday</a>, 01-May-22 09:20:17 GMT;;”AzCopy/10.6.0 Azure-Storage/0.10 (go1.13; Windows_NT)”;;”XXXXXXXXXXXXXXXXXXXXXXXX”</p></blockquote><p>アクセス元 IP は 20.89.XX.XX であることが分かります。</p><p>サービス エンドポイント有効、サービス エンドポイント経由のアクセス</p><blockquote><p>1.0;2022-05-01T10:42:56.2621284Z;PutBlob;SASSuccess;201;11;11;sas;;akstor001;blob;”<a href="https://storageaccountname.blob.core.windows.net/container02/test.csv?sas&quot;;&quot;/storageaccountname/container02/test.csv&quot;;XXXXXXXXXXXXXXXXXXXXXXX;0;10.4.0.4:50461;2019-12-12;624;806;337;0;806;;&quot;XXXXXXXXXXXXXXXXXXXXXXXX&quot;;&quot;&quot;0x80x8DXXXXXXXXXXXXX&quot;&quot;;Sunday">https://storageaccountname.blob.core.windows.net:443/container02/test.csv?sas&quot;;&quot;/storageaccountname/container02/test.csv&quot;;XXXXXXXXXXXXXXXXXXXXXXX;0;10.4.0.4:50461;2019-12-12;624;806;337;0;806;;&quot;XXXXXXXXXXXXXXXXXXXXXXXX&quot;;&quot;&quot;0x80x8DXXXXXXXXXXXXX&quot;&quot;;Sunday</a>, 01-May-22 10:42:56 GMT;;”AzCopy/10.6.0 Azure-Storage/0.10 (go1.13; Windows_NT)”;;”XXXXXXXXXXXXXXXXXXXXXXXX”</p></blockquote><p>アクセス元 IP は 10.4.0.4 であることが分かります。</p><p>・VM (米国中部) から、ストレージ アカウント (東日本) に対して AzCopy を実施した結果</p><p>[ VM の構成 ]</p><p>パブリック IP :  40.122.XX.XX<br>プライベート IP : 10.3.0.4</p><p>[ ストレージ アカウントの診断ログ] ※1 、※2</p><p>サービス エンドポイント無効、パブリック エンドポイント経由のアクセス</p><blockquote><p>1.0;2022-05-01T09:19:12.0009834Z;GetBlobProperties;SASSuccess;200;4;4;sas;;akstor001;blob;”<a href="https://storageaccountname.blob.core.windows.net/container03/test.csv?sas&quot;;&quot;/storageaccountname/container03/test.csv&quot;;XXXXXXXXXXXXXXXXXXXXXXX;0;40.122.XX.XX:50144;2019-12-12;413;0;543;0;0;;;&quot;&quot;0x8DXXXXXXXXXXXXX&quot;&quot;;Sunday">https://storageaccountname.blob.core.windows.net:443/container03/test.csv?sas&quot;;&quot;/storageaccountname/container03/test.csv&quot;;XXXXXXXXXXXXXXXXXXXXXXX;0;40.122.XX.XX:50144;2019-12-12;413;0;543;0;0;;;&quot;&quot;0x8DXXXXXXXXXXXXX&quot;&quot;;Sunday</a>, 01-May-22 09:19:11 GMT;;”AzCopy/10.6.0 Azure-Storage/0.10 (go1.13; Windows_NT)”;;”XXXXXXXXXXXXXXXXXXXXXXXX”</p></blockquote><p>アクセス元 IP は 40.122.XX.XX であることが分かります。</p><p>サービス エンドポイント有効、サービスエ ンドポイント経由のアクセス</p><blockquote><p>1.0;2022-05-01T12:10:54.1043116Z;GetBlobProperties;SASSuccess;200;5;5;sas;;akstor001;blob;”<a href="https://storageaccountname.blob.core.windows.net/container03/test.csv?sas&quot;;&quot;/storageaccountname/container03/test.csv&quot;;XXXXXXXXXXXXXXXXXXXXXXX;0;10.3.0.4:51283;2019-12-12;413;0;543;0;0;;;&quot;&quot;0x8DXXXXXXXXXXXXX&quot;&quot;;Sunday">https://storageaccountname.blob.core.windows.net:443/container03/test.csv?sas&quot;;&quot;/storageaccountname/container03/test.csv&quot;;XXXXXXXXXXXXXXXXXXXXXXX;0;10.3.0.4:51283;2019-12-12;413;0;543;0;0;;;&quot;&quot;0x8DXXXXXXXXXXXXX&quot;&quot;;Sunday</a>, 01-May-22 12:10:53 GMT;;”AzCopy/10.6.0 Azure-Storage/0.10 (go1.13; Windows_NT)”;;”XXXXXXXXXXXXXXXXXXXXXXXX”</p></blockquote><p>アクセス元 IP は 10.3.0.4 であることが分かります。</p><p>VM のリージョンとストレージ アカウントのリージョンがペア リージョンでない場合、サービス エンドポイントを利用する際は、以下公開ドキュメントの手順を実施する必要があります。</p><p>参考）他のリージョンの仮想ネットワークへのアクセスを有効にする (プレビュー)<br><a href="https://docs.microsoft.com/ja-jp/azure/storage/common/storage-network-security?tabs=azure-powershell#enabling-access-to-virtual-networks-in-other-regions-preview">https://docs.microsoft.com/ja-jp/azure/storage/common/storage-network-security?tabs=azure-powershell#enabling-access-to-virtual-networks-in-other-regions-preview</a></p><p>※1 ストレージ アカウントの診断ログは、BLOB コンテナーの $logs 配下に格納されます。<br>※2 ストレージ アカウントの診断ログ フォーマット</p><p>参考）Storage分析ログの形式<br><a href="https://docs.microsoft.com/ja-jp/rest/api/storageservices/storage-analytics-log-format">https://docs.microsoft.com/ja-jp/rest/api/storageservices/storage-analytics-log-format</a></p><h3 id="Azure-VM-からストレージ-アカウントへアクセスする際の挙動についてのまとめ"><a href="#Azure-VM-からストレージ-アカウントへアクセスする際の挙動についてのまとめ" class="headerlink" title="Azure VM からストレージ アカウントへアクセスする際の挙動についてのまとめ"></a>Azure VM からストレージ アカウントへアクセスする際の挙動についてのまとめ</h3><p>ストレージ アカウントのアクセス制御について、現段階では、仮想ネットワーク/サブネット単位、もしくは外部からのパブリック IP 単位での制御のみが可能です。<br>そのため、VM とストレージ アカウントが同一リージョンである場合、パブリック エンドポイント、サービス エンドポイントいずれを使用する場合も仮想ネットワーク/サブネット単位での制御までとなります。<br>VM とストレージ アカウントが異なるリージョンにある場合、パブリックエンドポイントを使用する際は、パブリック IP 単位での制御、サービスエンドポイントを使用する際は、仮想ネットワーク/サブネット単位での制御となります。</p><h2 id="ストレージアカウントへのアクセス制御について"><a href="#ストレージアカウントへのアクセス制御について" class="headerlink" title="ストレージアカウントへのアクセス制御について"></a>ストレージアカウントへのアクセス制御について</h2><p>先述の通り、ストレージ アカウントのファイアウォールでは、仮想ネットワーク/サブネット単位、もしくは外部からのパブリック IP 単位での制御のみとなりますが、<br>「ストレージ アカウントへのアクセス制御を VM 単位で行う方法はあるか」というお問い合わせをいただくことがあります。<br>VM 単位でのアクセス元制御を行いたい場合、プレビュー段階の機能とはなりますが、プライベート エンドポイントに対する NSG を利用することで、プライベート エンドポイントの IP アドレスに対して NSG でアクセス制御を行うことが可能となります。</p><p>参考）プライベート エンドポイントのネットワーク ポリシーを管理する<br><a href="https://docs.microsoft.com/ja-jp/azure/private-link/disable-private-endpoint-network-policy">https://docs.microsoft.com/ja-jp/azure/private-link/disable-private-endpoint-network-policy</a></p><blockquote><p>&lt;抜粋&gt;<br>プライベート エンドポイントに対する NSG と UDR のサポートは、一部のリージョンでパブリック プレビュー段階です。 詳細については、「Private Link UDR のサポートのパブリック プレビュー」と「Private Link ネットワーク セキュリティ グループのサポートのパブリック プレビュー」を参照してください。 このプレビュー バージョンはサービス レベル アグリーメントなしで提供されています。運用環境のワークロードに使用することはお勧めできません。 特定の機能はサポート対象ではなく、機能が制限されることがあります。 詳しくは、Microsoft Azure プレビューの追加使用条件に関するページをご覧ください。</p></blockquote><h3 id="VM-単位でのストレージアカウントへのアクセス制御検証"><a href="#VM-単位でのストレージアカウントへのアクセス制御検証" class="headerlink" title="VM 単位でのストレージアカウントへのアクセス制御検証"></a>VM 単位でのストレージアカウントへのアクセス制御検証</h3><p>1.ストレージ アカウントに対して、プライベート エンドポイントを構成します。※3<br><img src="/blog/storage/storageFirewall-accesscontroll/storageFW-ac01.png"></p><p><img src="/blog/storage/storageFirewall-accesscontroll/storageFW-ac02.png"></p><p>2.プライベート エンドポイントのプレビュー機能 (AllowPrivateEndpointNSG) を有効化します。※4</p><p>プライベート エンドポイントのプレビュー機能の有効化状況の確認</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-AzProviderFeature -ProviderNamespace Microsoft.Network -FeatureName AllowPrivateEndpointNSG</span><br></pre></td></tr></table></figure><p>プライベート エンドポイントのプレビュー機能の有効化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Register-AzProviderFeature -FeatureName AllowPrivateEndpointNSG -ProviderNamespace Microsoft.Network</span><br></pre></td></tr></table></figure><p>本機能の有効化には少しお時間を要しますが、RegistrationState が Registered となれば有効化完了です。</p><p>3.対象の仮想ネットワーク/サブネットに対してプライベート エンドポイントの NSG を有効にします。※5</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">SubnetName = <span class="string">&quot;default&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">VnetName = <span class="string">&quot;myVNet&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">RGName = <span class="string">&quot;myResourceGroup&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash">virtualNetwork= Get-AzVirtualNetwork -Name <span class="variable">$VnetName</span> -ResourceGroupName <span class="variable">$RGName</span></span></span><br><span class="line"><span class="meta">($</span><span class="bash">virtualNetwork | Select -ExpandProperty subnets | Where-Object  &#123;<span class="variable">$_</span>.Name -eq <span class="variable">$SubnetName</span>&#125;).PrivateEndpointNetworkPolicies = <span class="string">&quot;Enabled&quot;</span></span>  </span><br><span class="line"><span class="meta">$</span><span class="bash">virtualNetwork | Set-AzVirtualNetwork</span></span><br></pre></td></tr></table></figure><p>4.NSG を設定します。</p><p>ソース IP アドレス/CIDR 範囲：アクセス元 VM のプライベート IP を登録</p><p>宛先 IP アドレス/CIDR 範囲：ストレージ アカウントのプライベート エンドポイントが構成されている仮想ネットワークのアドレス空間から割り振られたプライベート IP を登録</p><p><img src="/blog/storage/storageFirewall-accesscontroll/storageFW-ac03.png"></p><p>5.アクセス拒否した端末よりストレージアカウント内コンテナ―へアクセスします。</p><p>NSG にてアクセス拒否した VM からストレージアカウント内コンテナ―へアクセスできないことを確認します。<br><img src="/blog/storage/storageFirewall-accesscontroll/storageFW-ac04.png"></p><p>上記のようにプライベート エンドポイントに対する NSG を利用することで VM 単位でのアクセス元制御を実現することは可能です。<br>ただし、公開ドキュメントに記載の通り、プライベート エンドポイントに対する NSG のサポートは現時点でプレビュー段階となり、商用環境での運用が正式にサポートされるものではございません。公開ドキュメント上の情報は予告なく変更される可能性がありますので、あらかじめご了承の上、ご利用をご検討くださいませ。</p><p>参考）<br>※3<br>チュートリアル:Azure プライベート エンドポイントを使用してストレージ アカウントに接続する<br><a href="https://docs.microsoft.com/ja-jp/azure/private-link/tutorial-private-endpoint-storage-portal">https://docs.microsoft.com/ja-jp/azure/private-link/tutorial-private-endpoint-storage-portal</a><br>Azure Storage のプライベート エンドポイントを使用する<br><a href="https://docs.microsoft.com/ja-jp/azure/storage/common/storage-private-endpoints">https://docs.microsoft.com/ja-jp/azure/storage/common/storage-private-endpoints</a></p><p>※4<br>Public preview of Private Link Network Security Group Support<br><a href="https://azure.microsoft.com/ja-jp/updates/public-preview-of-private-link-network-security-group-support/">https://azure.microsoft.com/ja-jp/updates/public-preview-of-private-link-network-security-group-support/</a></p><p>※5<br>プライベート エンドポイントのネットワーク ポリシーを管理する<br><a href="https://docs.microsoft.com/ja-jp/azure/private-link/disable-private-endpoint-network-policy#azure-powershell">https://docs.microsoft.com/ja-jp/azure/private-link/disable-private-endpoint-network-policy#azure-powershell</a></p><hr><p>本稿は以上となりますが、いかがでしたでしょうか。 本稿が皆様のお役に立てれば幸いです。</p><p>※本情報の内容（添付文書、リンク先などを含む）は、作成日時点でのものであり、予告なく変更される場合があります。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの木下です。&lt;br&gt;今回は、Azure VM からストレージ アカウントへアクセスする際の挙動とアクセス元制御ついてご案内します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Storage" scheme="https://jpaztech.github.io/blog/tags/Storage/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Japan Azure IaaS Core Support Blog</title>
  
  <subtitle>日本マイクロソフトの Azure IaaS テクニカル サポート チームより、情報をお届けします！</subtitle>
  <link href="https://jpaztech.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://jpaztech.github.io/blog/"/>
  <updated>2023-08-18T00:59:11.638Z</updated>
  <id>https://jpaztech.github.io/blog/</id>
  
  <author>
    <name>Japan Azure IaaS Core Support Team</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Azure Windows VM の KMS ライセンス認証トラブルシューティングについて</title>
    <link href="https://jpaztech.github.io/blog/vm/kms-troubleshooting/"/>
    <id>https://jpaztech.github.io/blog/vm/kms-troubleshooting/</id>
    <published>2023-08-17T08:30:00.000Z</published>
    <updated>2023-08-18T00:59:11.638Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの富田です。<br>Azure 上で稼働する Windows VM のライセンス認証のためにマイクロソフトが KMS サーバー（KMS ホスト サーバー）を提供しております。<br>KMS サーバーへのライセンス認証要求は KMS クライアント (Windows VM) から KMS サーバーに対して定期的かつ自動的に実行されます。<br>Azure Windows VM から Azure の KMS サーバーに対して適切な経路で通信が行えない環境等においては、KMS のライセンス認証が失敗し続け、ライセンス認証切れに関する警告が表示されることがございます。<br>本件について多くのお問い合わせをいただきますため、KMS のライセンス認証のトラブルシューティング等について以下の内容をご紹介させていただきます。</p><ul><li><p><a href="./#KMS-%E3%83%A9%E3%82%A4%E3%82%BB%E3%83%B3%E3%82%B9%E8%AA%8D%E8%A8%BC%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%AE%E8%A7%A3%E8%AA%AC">KMS ライセンス認証についての解説</a></p><ul><li><a href="./#KMS-%E3%83%A9%E3%82%A4%E3%82%BB%E3%83%B3%E3%82%B9%E8%AA%8D%E8%A8%BC%E3%81%AE%E6%A6%82%E8%A6%81">KMS ライセンス認証の概要</a></li><li><a href="./#KMS-%E3%83%A9%E3%82%A4%E3%82%BB%E3%83%B3%E3%82%B9%E8%AA%8D%E8%A8%BC%E3%81%AB%E5%BF%85%E8%A6%81%E3%81%AA%E8%A8%AD%E5%AE%9A%E3%81%8A%E3%82%88%E3%81%B3%E9%80%9A%E4%BF%A1%E8%A6%81%E4%BB%B6">KMS ライセンス認証に必要な設定および通信要件</a></li><li><a href="./#%E8%87%AA%E5%8B%95%E7%9A%84%E3%81%AA%E3%83%A9%E3%82%A4%E3%82%BB%E3%83%B3%E3%82%B9%E8%AA%8D%E8%A8%BC%E3%81%8A%E3%82%88%E3%81%B3%E6%9C%89%E5%8A%B9%E6%9C%9F%E9%99%90%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">自動的なライセンス認証および有効期限について</a></li><li><a href="./#%E3%83%A9%E3%82%A4%E3%82%BB%E3%83%B3%E3%82%B9%E8%AA%8D%E8%A8%BC%E5%88%87%E3%82%8C%E3%81%AE%E5%BD%B1%E9%9F%BF">ライセンス認証切れの影響</a></li></ul></li><li><p><a href="./#%E3%83%88%E3%83%A9%E3%83%96%E3%83%AB%E3%82%B7%E3%83%A5%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E6%96%B9%E6%B3%95">トラブルシューティング方法</a></p><ul><li><a href="./#%E6%89%8B%E5%8B%95%E3%83%A9%E3%82%A4%E3%82%BB%E3%83%B3%E3%82%B9%E8%AA%8D%E8%A8%BC%E3%81%AE%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E5%AE%9F%E8%A1%8C">手動ライセンス認証のコマンド実行</a></li><li><a href="./#%E3%83%A9%E3%82%A4%E3%82%BB%E3%83%B3%E3%82%B9%E7%8A%B6%E6%85%8B%E3%81%8A%E3%82%88%E3%81%B3%E8%A8%AD%E5%AE%9A%E7%A2%BA%E8%AA%8D">ライセンス状態および設定確認</a></li><li><a href="./#KMS-%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%81%B8%E3%81%AE%E5%90%8D%E5%89%8D%E8%A7%A3%E6%B1%BA%E3%81%8A%E3%82%88%E3%81%B3%E7%96%8E%E9%80%9A%E7%A2%BA%E8%AA%8D%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%81%AE%E5%AE%9F%E8%A1%8C">KMS サーバーへの名前解決および疎通確認コマンドの実行</a></li><li><a href="./#%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88%E3%83%AD%E3%82%B0%E3%81%A7%E3%83%A9%E3%82%A4%E3%82%BB%E3%83%B3%E3%82%B9%E3%83%AD%E3%82%B0%E3%82%92%E8%A6%8B%E3%82%8B">イベントログでライセンスログを見る</a></li></ul></li><li><p><a href="./#%E3%82%88%E3%81%8F%E3%81%82%E3%82%8B%E3%83%88%E3%83%A9%E3%83%96%E3%83%AB%E3%81%AE%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3">よくあるトラブルのパターン</a></p><ul><li><a href="./#KMS-%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%81%AE%E4%B8%80%E6%99%82%E7%9A%84%E3%81%AA%E8%B2%A0%E8%8D%B7">KMS サーバーの一時的な負荷</a></li><li><a href="./#%E3%83%95%E3%82%A1%E3%82%A4%E3%82%A2%E3%82%A6%E3%82%A9%E3%83%BC%E3%83%AB%E8%A3%BD%E5%93%81%E3%81%A7%E9%80%9A%E4%BF%A1%E3%82%92%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B">ファイアウォール製品で通信をブロックしている</a></li><li><a href="./#%E5%BC%B7%E5%88%B6%E3%83%88%E3%83%B3%E3%83%8D%E3%83%AA%E3%83%B3%E3%82%B0%E7%92%B0%E5%A2%83%EF%BC%88%E3%82%AA%E3%83%B3%E3%83%97%E3%83%AC%E3%83%9F%E3%82%B9%E7%AD%89%E3%82%92%E7%B5%8C%E7%94%B1%E3%81%97%E7%9B%B4%E6%8E%A5%E9%80%9A%E4%BF%A1%E3%81%A8%E3%81%AA%E3%81%A3%E3%81%A6%E3%81%84%E3%81%AA%E3%81%84%EF%BC%89">強制トンネリング環境（オンプレミス等を経由し直接通信となっていない）</a></li><li><a href="./#Standard-SKU-%E3%81%AE-Azure-Load-Balancer-%E9%85%8D%E4%B8%8B%E3%81%AE-VM-%E3%81%A7%E5%A4%96%E9%83%A8%E6%8E%A5%E7%B6%9A%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84">Standard SKU の Azure Load Balancer 配下の VM で外部接続ができない</a></li><li><a href="./#Tokens-dat-%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E7%A0%B4%E6%90%8D">Tokens.dat ファイルの破損</a></li></ul></li><li><p><a href="./#%E3%81%95%E3%81%84%E3%81%94%E3%81%AB%EF%BC%88%E3%81%9D%E3%81%AE%E4%BB%96%E3%81%AE%E8%A6%81%E5%9B%A0%E7%AD%89%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%EF%BC%89">さいごに（その他の要因等について）</a></p></li></ul><hr><h2 id="KMS-ライセンス認証についての解説"><a href="#KMS-ライセンス認証についての解説" class="headerlink" title="KMS ライセンス認証についての解説"></a>KMS ライセンス認証についての解説</h2><p>先述の通り、Azure 上の Windows VM は定期的かつ自動的に KMS ライセンス認証が行われます。<br>KMS ライセンス認証についてどのように行われるのかといった概要などをご紹介させていただきます。  </p><hr><h3 id="KMS-ライセンス認証の概要"><a href="#KMS-ライセンス認証の概要" class="headerlink" title="KMS ライセンス認証の概要"></a>KMS ライセンス認証の概要</h3><p>Azure 上で稼働する Windows VM は従量課金制となっており、原則稼働時の従量課金にライセンス料が含まれております。<br>ゲスト OS となる Windows からは KMS（Key Management Services）サーバーに、定期的なライセンス認証が行われます。<br>このライセンス認証先の KMS サーバーは Azure 上にマイクロソフトがご用意しております。<br>そのため、お客様のご利用の Windows VM から KMS サーバーへのライセンス認証の通信経路が確保されている必要がございます。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p>Azure 上にお客様ご自身で KMS ホストサーバーの役割を担う KMS ホストを構築いただく場合は、そのサーバーではオンプレミス環境と同様に KMS ホストサーバー用の MAK キー（KMS ホスト キー）を使用してライセンス認証を実施する手順が必要となります。  </p></div><hr><h3 id="KMS-ライセンス認証に必要な設定および通信要件"><a href="#KMS-ライセンス認証に必要な設定および通信要件" class="headerlink" title="KMS ライセンス認証に必要な設定および通信要件"></a>KMS ライセンス認証に必要な設定および通信要件</h3><p>Azure VM から KMS サーバーへの通信は、<strong>TCP 宛先ポート 1688</strong> で以下のドメインに対して行われます。</p><blockquote><p><strong>kms.core.windows.net</strong> もしくは <strong>azkms.core.windows.net</strong></p></blockquote><p>このドメインは以下の IP アドレスのいずれかに名前解決されます。</p><blockquote><p><strong>20.118.99.224, 40.83.235.53, 23.102.135.246</strong></p></blockquote><p>なお、KMS ライセンスサーバー自体は Azure 上にご用意をしておりますが、上記の通りグローバル IP アドレスで名前解決されますので、VM からは Internet 方向としてルーティングされる必要がございます。  </p><p>重要な点として、原則 VM から直接 KMS サーバーへの通信を行っていただく必要がございます。<br>オンプレミス環境を経由したライセンス認証の通信ではライセンス認証が失敗することがございます。<br>この点については後述の「強制トンネリング環境（直接通信となっていない）」をご参照ください。<br>下図は KMS ライセンス認証の成功・失敗の例を表した図となります。</p><p><img src="/blog/vm/kms-troubleshooting/2023-08-04-16-23-05.png"></p><div class="alert is-success"><p class="alert-title">ヒント</p><p>KMS ライセンスサーバーへのライセンス認証通信については、NSG（ネットワークセキュリティグループ）の影響を受けないよう暗黙的なルールが存在します。</p><p>例外的にサブネットに対して 0.0.0.0/0 のルールがある場合は、暗黙的なルールがスキップされ、明示的に許可ルールが必要となります。  </p></div><p>また、OS 毎に KMS 専用のプロダクトキーの設定が必要です。<br>Azure マーケットプレイスからデプロイした VM 等では既定でこのプロダクトキーが設定されており、対応は不要でございますが、以下のシナリオに該当する場合は手動でライセンスキーの入力が必要となります。</p><ul><li>コンピューターをマルチ ライセンス認証キー (MAK) の使用から KMS クライアントに変換する</li><li>Windows の製品版 (OEM/Retail) ライセンスを KMS クライアントに変換する</li><li>コンピューターが以前に KMS ホストであった場合 KMS クライアントに変換する</li></ul><p>■ご参考：キー管理サービス (KMS) クライアントのライセンス認証とプロダクト キー<br><a href="https://learn.microsoft.com/ja-jp/windows-server/get-started/kms-client-activation-keys">https://learn.microsoft.com/ja-jp/windows-server/get-started/kms-client-activation-keys</a></p><hr><h3 id="自動的なライセンス認証および有効期限について"><a href="#自動的なライセンス認証および有効期限について" class="headerlink" title="自動的なライセンス認証および有効期限について"></a>自動的なライセンス認証および有効期限について</h3><p>ライセンス認証は既定では以下の間隔で自動的に認証されます。  </p><ul><li>ライセンス認証がされていない状態：2 時間に 1 回の頻度</li><li>ライセンス認証がされている状態：7 日に 1 回の頻度</li></ul><p>また、ライセンス認証は毎回必ず成功する必要はなく、一度認証されれば 180 日の有効期限が付与されます。<br>認証に成功する度に有効期限が再び 180 日からカウントされます。  </p><p>つまり、正常な状況であれば定期的なライセンス認証によって、180 日の有効期限が毎回更新されるという形となります。</p><hr><h3 id="ライセンス認証切れの影響"><a href="#ライセンス認証切れの影響" class="headerlink" title="ライセンス認証切れの影響"></a>ライセンス認証切れの影響</h3><p>Windows 8 / Windows Server 2012 以降の OS の場合のライセンス認証の影響について記載させていただきます。<br>上記期間内にライセンス認証が成功しない場合は、通知モード（ライセンス認証切れ状態）となります。<br>この際の影響は以下のようなものとなり VM への接続不可や使用不可になるといった影響はございません。<br>しかしながら、ライセンス認証が切れる前にライセンス認証が成功となるようご対応をお願いいたします。  </p><ol><li>画面の右下にライセンス認証が必要であることを示すウォーターマーク（透かし文字） が表示されます。</li><li>壁紙の右下に OS の情報を示す文字が表示されます。（Windows 8 / Windows Server 2012 及び 2012 R2 のみ）</li><li>パーソナル設定内の項目は設定変更不可となります。</li><li>自身が KMS ホストの場合、KMS クライアントの認証が行えません。</li></ol><hr><h2 id="トラブルシューティング方法"><a href="#トラブルシューティング方法" class="headerlink" title="トラブルシューティング方法"></a>トラブルシューティング方法</h2><p>ライセンス有効期限が近づくと、以下のようなライセンス認証を促すメッセージなどが表示されることがございます。  </p><p><img src="/blog/vm/kms-troubleshooting/2023-08-02-11-38-39.png" alt="Windows のライセンスの有効期限がもうすぐ切れます [設定] で Windows のライセンス認証を行う必要があります"></p><p>また、ライセンス認証が切れた際にメッセージが表示されるものと存じます。</p><p><img src="/blog/vm/kms-troubleshooting/2023-08-02-11-39-40.png" alt="Windows ライセンスの有効期限が切れています"></p><p>この場合は、何からの理由で自動的なライセンス認証が繰り返し失敗しており、ライセンス認証がまもなく切れる / 切れてしまっているといった状況が考えられます。 </p><p>よくあるライセンス認証の失敗のエラーコードとして「0xC004F074」や「0x8007139F」が表示されることがございます。<br>エラーコードから一発で原因究明ができるのが望ましいですが、恐縮ながら KMS ライセンス認証のトラブルシューティングは 1 つずつ原因切り分け等を行う必要がございます。<br>そのため、まずは先述の必要な通信要件等が可能な状況かご確認いただくことが必要です。<br>以下に正常なライセンス認証を行うためのトラブルシューティング方法を解説させていただきます。  </p><p>■ご参考：Azure Windows 仮想マシンのライセンス認証に関する問題のトラブルシューティング<br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-activation-problems">https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-activation-problems</a></p><hr><h3 id="手動ライセンス認証のコマンド実行"><a href="#手動ライセンス認証のコマンド実行" class="headerlink" title="手動ライセンス認証のコマンド実行"></a>手動ライセンス認証のコマンド実行</h3><p>まずは、手動でのライセンス認証コマンドを実行し、ライセンス認証が正常に成功するかご確認頂くのが良いかと存じます。<br>別途設定などの修正等を行った後にライセンス認証が成功するか確認する際にもこちらのコマンドをご利用いただけます。<br>管理者特権の Windows PowerShell プロンプトにて以下のコマンドの実行をお願いいたします。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>..<span class="number">12</span> | <span class="built_in">ForEach-Object</span> &#123; <span class="built_in">Invoke-Expression</span> <span class="string">&quot;<span class="variable">$env:windir</span>\system32\cscript.exe <span class="variable">$env:windir</span>\system32\slmgr.vbs /ato&quot;</span> ; <span class="built_in">start-sleep</span> <span class="number">5</span> &#125;</span><br></pre></td></tr></table></figure><p>こちらのコマンドは、KMS サーバーに対しライセンス認証を 5 秒毎に 12 回実行するコマンドとなっております。<br>1 回のみの実行の場合、一時的な問題で失敗することがございますため複数回の実行としております。<br>成功した場合は以下のようなメッセージが表示されます。  </p><blockquote><p>Windows(R)、ServerDatacenter エディションのアクティブ化 (12345678-1234-1234-1234-1234-12345678) … 製品が正常にアクティブ化されました。</p></blockquote><hr><h3 id="ライセンス状態および設定確認"><a href="#ライセンス状態および設定確認" class="headerlink" title="ライセンス状態および設定確認"></a>ライセンス状態および設定確認</h3><p>ライセンス状態および設定確認を行うには PowerShell で以下のコマンドを実行します。  </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscript c:\windows\system32\slmgr.vbs /dlv</span><br></pre></td></tr></table></figure><p><img src="/blog/vm/kms-troubleshooting/2023-08-02-11-37-28.png"></p><p>上記のように、ライセンスの状態やライセンス認証先の情報の確認が可能でございます。</p><hr><h3 id="KMS-サーバーへの名前解決および疎通確認コマンドの実行"><a href="#KMS-サーバーへの名前解決および疎通確認コマンドの実行" class="headerlink" title="KMS サーバーへの名前解決および疎通確認コマンドの実行"></a>KMS サーバーへの名前解決および疎通確認コマンドの実行</h3><p>KMS ライセンス認証が失敗している原因として、名前解決ができていないといった事や、疎通が失敗している可能性がございます。<br>この点の原因切り分けのためには以下の PowerShell コマンドを実行します。</p><ul><li>DNS での名前解決の確認</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 古い情報での名前解決を抑止するため DNS キャッシュをクリア</span></span><br><span class="line">ipconfig /flushdns</span><br><span class="line"></span><br><span class="line"><span class="comment"># KMS サーバーの名前解決が可能か確認する</span></span><br><span class="line">nslookup kms.core.windows.net</span><br><span class="line">nslookup azkms.core.windows.net</span><br></pre></td></tr></table></figure><p>成功した場合は、以下のように KMS サーバーの IP アドレスが名前解決されます。</p><p><img src="/blog/vm/kms-troubleshooting/2023-08-02-11-43-58.png"></p><p>名前解決ができていない場合は、DNS サーバーの設定の見直しやポート 53 UDP での DNS の通信ができているかといった点を確認する必要がございます。</p><ul><li>KMS サーバーへのポート 1688 での疎通確認</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Test-NetConnection</span> <span class="literal">-ComputerName</span> kms.core.windows.net <span class="literal">-Port</span> <span class="number">1688</span></span><br></pre></td></tr></table></figure><p>成功した場合は、以下のような <strong>TcpTestSucceeded : True</strong> の結果が表示されます。</p><p><img src="/blog/vm/kms-troubleshooting/2023-08-02-11-43-05.png"></p><p>こちらの通信が成功しない場合は、OS 内部や経由しているファイアウォールでの通信がブロックされている等の原因が考えられますため、後述のトラブルシューティングなどでこの通信を成功させるように修正が必要です。</p><hr><h3 id="イベントログでライセンスログを見る"><a href="#イベントログでライセンスログを見る" class="headerlink" title="イベントログでライセンスログを見る"></a>イベントログでライセンスログを見る</h3><p>ライセンス認証の成功・失敗については Windows OS 内の Event Viewer を用いて、<br> <strong>Event Viewer (Local) &gt; Windows Logs &gt; Application</strong><br>よりアプリケーションイベントログよりご確認いただくことが可能でございます。<br>以下にトラブルシューティングで使われるイベント ID をご紹介させていただきます。</p><ul><li>12288：KMS クライアントから KMS サーバーに認証を要求した際のログ</li></ul><p>イベント ID 12288 は KMS クライアントが KMS サーバーに対してライセンス認証を要求した際のログとなります。<br>後述の「12289：ライセンス認証の結果表示」と対になるログでございますので、「12288：ライセンス認証開始」はあるが「12289：ライセンス認証の結果表示」が無いといった場合は、以下のいずれかの状況を意味します。  </p><ol><li>KMS クライアントが KMS サーバーに接続できなかったこと</li><li>KMS サーバーが応答しなかったこと</li><li>KMS クライアントが KMS サーバーからの応答を受信しなかったこと</li></ol><p><img src="/blog/vm/kms-troubleshooting/2023-08-02-13-40-29.png"></p><ul><li>12289：ライセンス認証の結果表示</li></ul><p>イベント ID 12289 は KMS ライセンス認証の結果を表示します。<br>以下の図の通り Info に表示されている 3 個目のフラグが「1」の場合はライセンス認証成功です。<br>「0」となっとる場合はライセンス認証失敗となります。</p><p><img src="/blog/vm/kms-troubleshooting/2023-08-02-13-40-57.png"></p><p>■ご参考：便利な KMS クライアント イベント<br><a href="https://learn.microsoft.com/ja-jp/windows-server/get-started/activation-troubleshoot-kms-general#useful-kms-client-events">https://learn.microsoft.com/ja-jp/windows-server/get-started/activation-troubleshoot-kms-general#useful-kms-client-events</a></p><ul><li>8198, 8200：ライセンス認証の失敗</li></ul><p>イベント ID 8198, 8200 は KMS ライセンス認証の失敗時に表示されることのあるログとなります。  </p><p>後述の「KMS サーバーの一時的な負荷」のセクションに記載の通り、一時的な KMS サーバーの負荷の問題で表示される可能性がございますが、「12289：ライセンス認証の結果表示」にて正常にライセンス認証がされている場合は無視可能となります。<br>そのため、「8198, 8200：ライセンス認証の失敗」は常に発生しておらず単発的な場合は、無視いただいて問題ございません。</p><hr><h2 id="よくあるトラブルのパターン"><a href="#よくあるトラブルのパターン" class="headerlink" title="よくあるトラブルのパターン"></a>よくあるトラブルのパターン</h2><p>お客様から「ライセンス認証が失敗する」といった場合に、よくあるトラブルのパターンおよびその対処方法についてご案内をさせていただきます。  </p><hr><h3 id="KMS-サーバーの一時的な負荷"><a href="#KMS-サーバーの一時的な負荷" class="headerlink" title="KMS サーバーの一時的な負荷"></a>KMS サーバーの一時的な負荷</h3><p>Azure のKMS サーバーは全世界の Azure 上の Windows OS を認証している関係で、稀に負荷が集中するといったタイミングで応答ができない場合がございます。<br>一般的には、エラーイベントが数日に１回、といった頻度で記録されるに留まりますが、場合によっては丸 1 日継続するようなケースもあります。<br>Azure データセンターでも、随時 KMS の補強作業を行っていますが、常時 100 ％成功を目指しているものではございません。<br>この理由としては、先述の通り Windows のライセンス認証はその後リトライされ、ライセンス失効期間内で毎回失敗し続けなければライセンスが失効することはありません。<br>つまりライセンス認証失敗のエラーイベントが恒常的にではなく、一時的に記録されるだけである場合、無視可能です。  </p><p>他方、一時的ではなく常に毎回ライセンス認証失敗が失敗している場合は別の原因があるものと考えられますため、別途トラブルシューティングが必要でございます。</p><hr><h3 id="ファイアウォール製品で通信をブロックしている"><a href="#ファイアウォール製品で通信をブロックしている" class="headerlink" title="ファイアウォール製品で通信をブロックしている"></a>ファイアウォール製品で通信をブロックしている</h3><p>KMS の通信が Azure Firewall 等のファイアウォール製品を経由している場合、このファイアウォールでライセンス認証の通信がブロックされている可能性がございます。  </p><p><img src="/blog/vm/kms-troubleshooting/2023-08-04-16-25-28.png"></p><p>このような場合は以下のいずれかの方法でご対応をお願いいたします。  </p><ul><li>解決方法 1：UDR を用いてファイアウォールを経由しないルーティングを行う</li></ul><p>UDR を用いて KMS サーバーへのライセンス認証の通信についてファイアウォールを経由しないようなルーティングとする方法となります。<br>設定方法については、<a href="./#%E5%BC%B7%E5%88%B6%E3%83%88%E3%83%B3%E3%83%8D%E3%83%AA%E3%83%B3%E3%82%B0%E7%92%B0%E5%A2%83%EF%BC%88%E3%82%AA%E3%83%B3%E3%83%97%E3%83%AC%E3%83%9F%E3%82%B9%E7%AD%89%E3%82%92%E7%B5%8C%E7%94%B1%E3%81%97%E7%9B%B4%E6%8E%A5%E9%80%9A%E4%BF%A1%E3%81%A8%E3%81%AA%E3%81%A3%E3%81%A6%E3%81%84%E3%81%AA%E3%81%84%EF%BC%89">「強制トンネリング環境（オンプレミス等を経由し直接通信となっていない）」</a> セクションの解決方法と同じになりますので、そちらをご参照ください。  </p><p><img src="/blog/vm/kms-troubleshooting/2023-08-04-16-27-07.png"></p><ul><li>解決方法 2：ファイアウォール製品でライセンス認証の通信を許可する</li></ul><p>先述の通り、ライセンス認証には以下の通信要件が必要でございますので、お使いのファイアウォール製品で Azure VM からの以下の通信を許可する設定をお願いいたします。  </p><table><thead><tr><th>項目</th><th>通信要件</th></tr></thead><tbody><tr><td>ドメイン</td><td>kms.core.windows.net および azkms.core.windows.net</td></tr><tr><td>IP アドレス</td><td>20.118.99.224, 40.83.235.53, 23.102.135.246</td></tr><tr><td>ポート</td><td>1688</td></tr><tr><td>プロトコル</td><td>TCP</td></tr></tbody></table><p><img src="/blog/vm/kms-troubleshooting/2023-08-04-16-29-13.png"></p><p>上手く改善されない場合は原因切り分けのために「解決方法 1：UDR を用いてファイアウォールを経由しないルーティングを行う」の方を実施していただけますと幸いです。</p><hr><h3 id="強制トンネリング環境（オンプレミス等を経由し直接通信となっていない）"><a href="#強制トンネリング環境（オンプレミス等を経由し直接通信となっていない）" class="headerlink" title="強制トンネリング環境（オンプレミス等を経由し直接通信となっていない）"></a>強制トンネリング環境（オンプレミス等を経由し直接通信となっていない）</h3><p>KMS サーバーは Azure 上の VM からの直接通信のみを受け付ける動作となっております。<br>そのため、Azure VM から送信される通信を強制トンネリングを用いて VPN / ExpressRoute を通過し、オンプレミス環境を経由するような設定を頂いている場合は、ライセンス認証が失敗いたします。  </p><p><img src="/blog/vm/kms-troubleshooting/2023-08-07-09-11-09.png"></p><p>このオンプレミス環境で KMS サーバーに接続できるような設定をしたとしても、実際のライセンス認証実行にて認証ができない状況となりますので留意ください。</p><p>■ご参考：強制トンネリングを使用したライセンス認証の問題<br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/custom-routes-enable-kms-activation">https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/custom-routes-enable-kms-activation</a></p><ul><li>解決方法：UDR を用いてファイアウォールを経由しないルーティングを行う</li></ul><p>Azure 上の VNET に属する Subnet 単位で UDR（User Defined Route）を用いて、特定 IP アドレスへの通信のルーティングを変更することが可能です。<br>すなわち、KMS サーバー（20.118.99.224, 40.83.235.53, 23.102.135.246）への通信のみ、直接通信とするために Next Hop を Internet にします。</p><p><img src="/blog/vm/kms-troubleshooting/2023-08-07-09-13-02.png"></p><p>ポータルからこの設定を行う、具体的な手順をご紹介させていただきます。  </p><p>まずは対象の Azure VM の画面にて右側のメニューより「ネットワーク」を選択肢し、対象の仮想ネットワーク / サブネットのリンクを選択します。</p><p><img src="/blog/vm/kms-troubleshooting/2023-08-02-15-26-12.png"></p><p>対象の Subnet に設定されているルート テーブル名を選択します。</p><p><img src="/blog/vm/kms-troubleshooting/2023-08-02-16-26-20.png"></p><p>左側のメニューより「ルート」を選択し「追加」より、KMS サーバーへの通信のみ、直接通信とするために Next Hop を Internet とするルートを 3 つそれぞれ作成します。<br>アドレス プレフィックスには、それぞれ以下の値をご入力ください。  </p><table><thead><tr><th>アドレス プレフィックス</th></tr></thead><tbody><tr><td>20.118.99.224/32</td></tr><tr><td>40.83.235.53/32</td></tr><tr><td>23.102.135.246/32</td></tr></tbody></table><p><img src="/blog/vm/kms-troubleshooting/2023-08-03-11-26-51.png"></p><p>これで、KMS ライセンス認証の通信を直接 KMS サーバーと通信するルーティングテーブルの設定ができました。</p><hr><h3 id="Standard-SKU-の-Azure-Load-Balancer-配下の-VM-で外部接続ができない"><a href="#Standard-SKU-の-Azure-Load-Balancer-配下の-VM-で外部接続ができない" class="headerlink" title="Standard SKU の Azure Load Balancer 配下の VM で外部接続ができない"></a>Standard SKU の Azure Load Balancer 配下の VM で外部接続ができない</h3><p>Standard SKU の Azure Load Balancer 配下の VM の場合、外部接続ができない状態となっていることに伴い KMS ライセンス認証の通信ができない場合がございます。<br>また、可用性セットの VM の場合、同一可用性セット内の別の VM が Standard SKU の Azure Load Balancer 配下にあると、同じく外部通信ができない状況が発生します。  </p><p>このような Standard SKU の Azure Load Balancer 配下の VM の場合は、KMS サーバーへの通信ができるように明示的に外部接続のポリシーを構成する必要がございます。<br>こちらのシナリオについては別途解説を行っているブログ記事がございますので、こちらをご参照くださいませ。</p><p>■ご参考：Azure VM の外部接続 (SNAT) オプション まとめ<br><a href="https://jpaztech.github.io/blog/network/snat-options-for-azure-vm/">https://jpaztech.github.io/blog/network/snat-options-for-azure-vm/</a></p><hr><h3 id="Tokens-dat-ファイルの破損"><a href="#Tokens-dat-ファイルの破損" class="headerlink" title="Tokens.dat ファイルの破損"></a>Tokens.dat ファイルの破損</h3><p>ライセンス認証を行ったところ以下のように「エラー コード: 0xC004E015 / 0xC004D301 / 0xC004E002」といったエラーが表示される場合がございます。  </p><p><img src="/blog/vm/kms-troubleshooting/2023-08-07-09-13-40.png" alt="現在 Windows のライセンス認証を行えません。後でもう一度実行してください。問題が解決しない場合は、システム管理者にお問い合わせください。 エラー コード: 0xC004E015"></p><p>この場合は Tokens.dat ファイルの破損が発生している可能性がございます。<br>以下の公開情報の手順で、Tokens.dat ファイルの再構築を行った後に、手動のライセンス認証が成功するかお試しいただけますと幸いです。</p><p>■ご参考：Tokens.dat ファイルの再構築<br><a href="https://learn.microsoft.com/ja-jp/windows-server/get-started/activation-rebuild-tokens-dat-file">https://learn.microsoft.com/ja-jp/windows-server/get-started/activation-rebuild-tokens-dat-file</a></p><hr><h2 id="さいごに（その他の要因等について）"><a href="#さいごに（その他の要因等について）" class="headerlink" title="さいごに（その他の要因等について）"></a>さいごに（その他の要因等について）</h2><p>以上がトラブルシューティングおよび、よくあるトラブルのパターンとなりますが、稀に上記以外の要因でもライセンス認証の失敗の可能性もございます。  </p><p>【例】</p><ul><li>OS 内部のファイアウォールでの KMS ライセンス認証通信のブロック</li><li>ライセンスキーが正常に登録されていない</li></ul><p>これらのシナリオに該当しない可能性もございますので、上記のトラブルシューティングで改善しない場合は、実施したトラブルシューティングの内容や対象の VM の情報などを添えて弊社の技術サポート窓口にお問い合わせをいただけますと幸いでございます。<br>上述の内容が皆様のお役に立つことを願っております。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの富田です。&lt;br&gt;Azure 上で稼働する Windows VM のライセンス認証のためにマイクロソフトが KMS サーバー（KMS ホスト サーバー）を提供しております。&lt;br&gt;KMS サーバーへのライセンス認証要求は</summary>
      
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
    <category term="KMS" scheme="https://jpaztech.github.io/blog/tags/KMS/"/>
    
  </entry>
  
  <entry>
    <title>Azure Files はユーザー毎のマウントが必要です</title>
    <link href="https://jpaztech.github.io/blog/vm/azure-files-user-mount/"/>
    <id>https://jpaztech.github.io/blog/vm/azure-files-user-mount/</id>
    <published>2023-08-16T08:30:00.000Z</published>
    <updated>2023-08-18T00:59:11.430Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの富田です。<br>今回はタイトルの通り、Azure Files はユーザー毎のマウントが必要となっております点についてご案内させていただきます。  </p><p>お客様より「Windows 環境でユーザー A でマウントした Azure Files についてユーザー B より参照ができない。」というお問い合わせをいただくことがございます。<br>こちらは仕様となっており、マウントを行ったユーザー以外のユーザーからは Azure Files のマウント先を参照できないものとなっております。<br>そのためユーザー毎にマウントを行っていただく必要がございます点、ご留意くださいませ。</p><p>なお、IIS といったミドルウェアで Azure Files を参照させる場合は、System アカウントで Azure Files のマウントが必要な場合がございます。<br>しかしながら、System アカウントでの Azure Files のマウントは永続化が叶いませんため、起動の度にマウントが必要となります点ご留意くださいませ。  </p><p>簡単ではございますが、Azure Files のマウントについて解説をさせていただきました。<br>Azure Files 自体についての詳細は公式ドキュメントをご参照くださいませ。  </p><p>■ご参考：Azure Files とは<br><a href="https://learn.microsoft.com/ja-jp/azure/storage/files/storage-files-introduction">https://learn.microsoft.com/ja-jp/azure/storage/files/storage-files-introduction</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの富田です。&lt;br&gt;今回はタイトルの通り、Azure Files はユーザー毎のマウントが必要となっております点についてご案内させていただきます。  &lt;/p&gt;
&lt;p&gt;お客様より「Windows 環境でユーザー A でマウン</summary>
      
    
    
    
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="Azure Files" scheme="https://jpaztech.github.io/blog/tags/Azure-Files/"/>
    
  </entry>
  
  <entry>
    <title>Azure VM の作成/起動/停止ユーザーを確認する方法</title>
    <link href="https://jpaztech.github.io/blog/vm/vm-create-activity-log/"/>
    <id>https://jpaztech.github.io/blog/vm/vm-create-activity-log/</id>
    <published>2023-07-31T09:00:00.000Z</published>
    <updated>2023-08-18T00:59:11.774Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポート チームの前田です。</p><p>今回は、よくお問い合わせをいただいております、Azure VM の作成者が不明な場合の確認方法についてご紹介いたします。<br>本ブログでは Azure VM を例に紹介いたしますが、ストレージ アカウントなど他のリソースでも応用が可能な内容となりますので、皆様のご参考となりましたら幸いでございます。</p><hr><h2 id="使用する機能について"><a href="#使用する機能について" class="headerlink" title="使用する機能について"></a>使用する機能について</h2><p>Azure VM の作成者の特定には、アクティビティ ログを利用いたします。<br>アクティビティ ログとは、Azure のプラットフォーム ログであり、様々な操作、イベントに関する情報を記録しております。<br>本件でご紹介いたします Azure VM 等リソースの作成の他、VM の起動、停止などの履歴も記録されますので、一度は目にしたことのある方も多い機能かと存じます。<br>今回は数あるイベントの中から、VM の作成時に記録される内容についてご紹介いたします。</p><p>参考) Azure Monitor アクティビティ ログ<br><a href="https://learn.microsoft.com/ja-jp/azure/azure-monitor/essentials/activity-log?tabs=powershell">https://learn.microsoft.com/ja-jp/azure/azure-monitor/essentials/activity-log?tabs=powershell</a></p><hr><h2 id="アクティビティ-ログの確認方法"><a href="#アクティビティ-ログの確認方法" class="headerlink" title="アクティビティ ログの確認方法"></a>アクティビティ ログの確認方法</h2><p>では早速、VM 作成時のアクティビティ ログを確認してまいります。<br>今回は特定の Azure VM のアクティビティ ログより確認を行いますが、アクティビティ ログはリソース グループおよびサブスクリプション単位での確認も可能でございますので、状況に合わせスコープを選定いただければと存じます。</p><p>また、アクティビティ ログは絞り込んだ期間内のログに関し、CSV 形式にてダウンロードすることも可能でございますので、ご都合の良い手法にてご確認をお願いいたします。</p><p>[Virtual Machine] より [アクティビティ ログ] を選択します。<br><img src="/blog/vm/vm-create-activity-log/activitylog001.png"></p><p>検索期間がデフォルトでは直近 6 時間となっているため、VM を作成したおおよその日時で [カスタム] より絞り込みを行います。<br>絞り込みが難しい場合、ログの保存期間である 90 日間となるよう日時を指定します。<br><img src="/blog/vm/vm-create-activity-log/activitylog002.png"></p><p>最も古い [Create or Update Virtual Machine] の項目をクリックします。<br><img src="/blog/vm/vm-create-activity-log/activitylog003.png"></p><p>表示された項目のうち、[イベント開始者] のユーザーが VM の作成者となります。<br><img src="/blog/vm/vm-create-activity-log/activitylog004.png"></p><p>なお、上記確認方法について注意点が 2 点ございます。</p><ol><li><p>アクティビティ ログの保存期間について<br>このアクティビティ ログは単独での保存期間が 90 日となりますため、これを超過しており、かつ別の場所へのログの退避を実施していない場合、ご利用いただくことが叶いませんので、予めご了承いただければと存じます。</p></li><li><p>[Create or Update Virtual Machine] の該当項目について<br>上記の項目につきましては、VM の作成の他、VM のサイズ変更等の際にも表示されるログとなります。<br>このため、上記名称のより古いログがございます場合は、再度ご確認をいただく必要がございます。</p></li></ol><hr><h2 id="その他、よく利用されるアクティビティ-ログ"><a href="#その他、よく利用されるアクティビティ-ログ" class="headerlink" title="その他、よく利用されるアクティビティ ログ"></a>その他、よく利用されるアクティビティ ログ</h2><p>VM の作成者のほか、VM の起動、割り当て解除を実施したユーザーの確認方法につきましても多くお問い合わせをいただきますことから、併せてアクティビティ ログの出力内容についてご紹介いたします。</p><h3 id="■-VM-の起動ユーザー"><a href="#■-VM-の起動ユーザー" class="headerlink" title="■ VM の起動ユーザー"></a>■ VM の起動ユーザー</h3><p>アクティビティ ログの出力のうち、Start Virtual Machine が該当します。<br>イベント開始者が VM を起動したユーザーです。<br><img src="/blog/vm/vm-create-activity-log/activitylog005.png"></p><h3 id="■-VM-の割り当て解除の実施ユーザー"><a href="#■-VM-の割り当て解除の実施ユーザー" class="headerlink" title="■ VM の割り当て解除の実施ユーザー"></a>■ VM の割り当て解除の実施ユーザー</h3><p>アクティビティ ログの出力のうち、Deallocate Virtual Machine が該当します。<br>イベント開始者が VM の割り当て解除を実施したユーザーです。<br> <img src="/blog/vm/vm-create-activity-log/activitylog006.png"></p><hr><h2 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h2><p>いかがでしたでしょうか。<br>以上が Azure VM の作成者をアクティビティ ログから特定する方法でございました。<br>この他にも Azure VM のアクティビティ ログには様々な内容が記録されますので、添付いたしました弊社ドキュメントを含めぜひご活用いただければと存じます。<br>本記事が皆様のお役に立つ内容となっておりましたら幸いでございます。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポート チームの前田です。&lt;/p&gt;
&lt;p&gt;今回は、よくお問い合わせをいただいております、Azure VM の作成者が不明な場合の確認方法についてご紹介いたします。&lt;br&gt;本ブログでは Azure VM を例に紹介いたしますが、ストレージ</summary>
      
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
  </entry>
  
  <entry>
    <title>ゲスト OS 内からネットワーク接続のプロパティを変更しないでください</title>
    <link href="https://jpaztech.github.io/blog/vm/avoiding-changes-to-DNS-and-IP-in-GuestOS/"/>
    <id>https://jpaztech.github.io/blog/vm/avoiding-changes-to-DNS-and-IP-in-GuestOS/</id>
    <published>2023-07-31T08:30:00.000Z</published>
    <updated>2023-08-18T00:59:11.430Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポート チームの新見です。</p><p>Azure VM のゲスト OS 内から DNS サーバーの設定や ゲスト OS 自体の IP アドレスなどのようなネットワーク接続のプロパティを変更した際に、Azure VM への接続に失敗してしまったというお問い合わせをいただくことがあります。<br>本記事では、Azure VM のゲスト OS 内からネットワーク接続のプロパティを変更することは非推奨であることと、変更してしまった場合の対処法と、推奨している手順についてご紹介いたします。   </p><p>以下公開資料にもございますように、 Azure VM ではゲスト OS 内部で DNS サーバーの設定や ゲスト OS 自体の IP アドレスなどのネットワーク接続のプロパティの設定は原則変更しないようお願いしています。   </p><blockquote><p>ご参考) <a href="https://docs.microsoft.com/ja-jp/azure/virtual-network/virtual-networks-name-resolution-for-vms-and-role-instances#specify-dns-servers">DNS サーバーの指定 </a><br>ーーーーーーーーー抜粋ーーーーーーーーー<br>DNS サーバーの IP などのネットワーク接続プロパティは、VM 内で直接編集しないでください。<br>これは、仮想ネットワーク アダプターを交換したときのサービス回復時にネットワーク接続プロパティが消去される可能性があるためです。<br>これは、Windows VM と Linux VM の両方に適用されます。<br>ーーーーーーーーーーーーーーーーーーーー</p></blockquote><blockquote><p>ご参考) <a href="https://docs.microsoft.com/ja-jp/azure/virtual-network/virtual-network-network-interface-addresses#private">Azure ネットワーク インターフェイスの IP アドレスの追加、変更、削除</a><br>ーーーーーーーーー抜粋ーーーーーーーーー<br>必要がない限り、仮想マシンのオペレーティング システム内のネットワーク インターフェイスの IP アドレスを手動で設定しないでください。<br>ーーーーーーーーーーーーーーーーーーーー </p></blockquote><p>Azure VM には、必ず 1 個以上のネットワーク インターフェイス(NIC) が接続されている必要があります。<br>Azure VM のゲスト OS 側の NIC に設定される IP アドレスは、デフォルトで DHCP サーバーから Azure 側の NIC で指定した IP アドレスが割り振られるように設定されています。<br>もし、Azure VM のゲスト OS 内でネットワーク接続のプロパティを変更した場合、Azure 側で保持している NIC のプロパティと整合性が取れなくなり、一切の通信が出来なくなることがあります。   </p><h1 id="ゲスト-OS-から直接設定を変更したことで接続不可となってしまった場合の対処策"><a href="#ゲスト-OS-から直接設定を変更したことで接続不可となってしまった場合の対処策" class="headerlink" title="ゲスト OS から直接設定を変更したことで接続不可となってしまった場合の対処策"></a>ゲスト OS から直接設定を変更したことで接続不可となってしまった場合の対処策</h1><p> <br>Azure VM のゲスト OS 内で ネットワーク設定の変更をしたことにより接続に失敗した際の対処法としては、まず、再起動をすることで解決する場合があります。 </p><p>再起動後も復旧しない場合は、一般的に NIC をリセットすることで復旧可能です。<br>NIC リセットの手順は、以下の公開情報をご参照ください。<br> <br>ご参考) <a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/reset-network-interface">Azure Windows VM のネットワーク インターフェイスをリセットする方法</a>  </p><h1 id="推奨している-DNS-サーバーの変更手順"><a href="#推奨している-DNS-サーバーの変更手順" class="headerlink" title="推奨している DNS サーバーの変更手順"></a>推奨している DNS サーバーの変更手順</h1><p> <br>DNS サーバーの設定は Azure 上で変更することで、自動的にAzure VM のゲスト OS 内の情報も変更されます。<br>そのため、DNS サーバーの設定を変更する場合は、Azure 上で DNS サーバーを変更するようお願いいたします。<br>DNS サーバーの設定変更の手順は、以下の公開情報をご参照ください。 </p><p>ご参考) <a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/virtual-network-network-interface?tabs=network-interface-portal#change-dns-servers">ネットワーク インターフェイスの作成、変更、削除 | DNS サーバーの変更</a>  </p><h1 id="推奨しているプライベート-IP-アドレスの変更手順"><a href="#推奨しているプライベート-IP-アドレスの変更手順" class="headerlink" title="推奨しているプライベート IP アドレスの変更手順"></a>推奨しているプライベート IP アドレスの変更手順</h1><p>プライベート IP アドレスも Azure 上で変更することで ゲスト OS 内の情報も変更されるため、Azure 上で変更するようお願いいたします。<br>プライベート IP アドレスは、静的割り当てに変更することで、サブネットの範囲内での任意の IP アドレスを割り当てられます。<br>同じネットワークに割り当てたいプライベート IP アドレスが存在する場合は指定できないので、割り当てられている VM のプライベート IP アドレスを予め別のものに変更するなどして対応いただくようお願いいたします。<br>プライベート IP の設定変更の手順は、以下の公開資料をご参照ください。 </p><p>ご参考) <a href="https://docs.microsoft.com/ja-jp/azure/virtual-network/ip-services/virtual-networks-static-private-ip-arm-pportal#change-private-ip-address-to-static">静的プライベート IP アドレスを持つ VM を作成する</a></p><h1 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h1><p> <br>この記事では、Azure VM のゲスト OS からネットワーク接続のプロパティを変更することが非推奨であることと、変更してしまった場合の対処法についてお伝えしました。<br>接続失敗の発生を防ぐためにネットワーク接続のプロパティを変更したい場合は、原則 Azure 上から変更するようお願いします。<br>本稿が少しでも皆様の一助となれば幸いです。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポート チームの新見です。&lt;/p&gt;
&lt;p&gt;Azure VM のゲスト OS 内から DNS サーバーの設定や ゲスト OS 自体の IP アドレスなどのようなネットワーク接続のプロパティを変更した際に、Azure VM への接続に失敗し</summary>
      
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>強制トンネリング利用時の VPN ゲートウェイの動作変更についてのアナウンス</title>
    <link href="https://jpaztech.github.io/blog/network/vpn-defaultsite-update-2022feb/"/>
    <id>https://jpaztech.github.io/blog/network/vpn-defaultsite-update-2022feb/</id>
    <published>2023-05-26T04:00:00.000Z</published>
    <updated>2023-08-18T00:59:11.338Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームです。</p><p>Azure の仮想ネットワーク ゲートウェイ (以下「ゲートウェイ」) を用いたサイト間 VPN 接続について、2022 年 2 月 24 日以降に、強制トンネリングに関する一部の動作の変更が行われることがアナウンスされました。</p><p>影響が生じる可能性のあるお客様には通知がすでに送信されているか、近日中に送信されることが想定されます。しかしながら、通知に含まれる説明は要点のみとなっているため、本記事にてその補足をさせていただきます。</p><p><strong>※追記</strong><br>2023 年 5 月 再度、強制トンネリング利用時の仮想ネットワーク ゲートウェイの動作変更のアナウンス (Tracking ID:VK3J-580)が通知されました。<br>これは、2022 年に通知されたアナウンス (Tracking ID:ZTPX-19Z)と同様の内容となりますが、動作変更の延期により今回あらためて仮想ネットワーク ゲートウェイ は、2023/6/12 ~ 6/16 の間に動作変更が実施されるという旨のアナウンスとなります。<br>2022 年に通知を受け取ったお客様の中で、下記の対応を行っていない環境については、動作変更の影響を受ける条件や合致確認の方法、動作変更の内容および変更の影響を受けないようにする対処方法をご確認の上、2023/6/12 より前にご対応いただけますと幸いでございます。</p><span id="more"></span><p><br><br></p><h2 id="本記事の内容"><a href="#本記事の内容" class="headerlink" title="本記事の内容"></a>本記事の内容</h2><p>本記事では、動作変更の影響を受ける条件やその合致確認の方法、動作変更の内容および変更の影響を受けないようにする対処方法ついてまとめております。本記事を参考に影響有無を確認するとともに、影響が想定される場合は 2 月 24 日までにあらかじめ対処を実施いただければと思います。</p><p>前半ではリソース マネージャー モデル（新しいモデル）のための手順、後半ではクラシック モデル（古いモデル）のための手順をおまとめしておりますので、それぞれご利用の環境に合わせて確認ください。</p><p><br><br></p><h2 id="今回の動作変更の背景"><a href="#今回の動作変更の背景" class="headerlink" title="今回の動作変更の背景"></a>今回の動作変更の背景</h2><p>Azure のゲートウェイには、「SKU」と呼ばれるパラメーターがあり、ゲートウェイの性能や冗長構成を指定することができます。ゲートウェイの SKU には、大きくわけて以下の 2 種類があります。</p><ul><li>末尾に AZ がつく SKU: VpnGw1AZ、VpnGw2AZ、VpnGw3AZ、VpnGw4AZ、VpnGw5AZ<br></li><li>末尾に AZ がつかない SKU: VpnGw1、VpnGw2、VpnGw3、VpnGw4、VpnGw5、Basic、Standard、HighPerformance</li></ul><p>AZ がつく SKU とつかない SKU では、冗長性確保のためのデータセンター内部の配置が少し違うのみで、そのほかに機能面での基本的な違いはありません。</p><p>しかし今回、特定の条件下において、AZ がつく SKU と AZ がつかない SKU で強制トンネリングに関する一部の動作 (詳細は後述) に差異があることが判明しました。AZ がつかない SKU を対象に動作変更を行い、AZ がつく SKU の動作を正として動作を揃えるというのが、今回のアナウンスの内容です。</p><p><br><br></p><h2 id="動作変更の内容"><a href="#動作変更の内容" class="headerlink" title="動作変更の内容"></a>動作変更の内容</h2><h3 id="強制トンネリングを実現する-2-種類の方法"><a href="#強制トンネリングを実現する-2-種類の方法" class="headerlink" title="強制トンネリングを実現する 2 種類の方法"></a>強制トンネリングを実現する 2 種類の方法</h3><p>Azure のサイト間 VPN においては、Azure 仮想ネットワークから送信されるすべての通信を、データセンターのバックボーンネットワークではなく、VPN にルーティングする「強制トンネリング」という構成が可能です。サイト間 VPN で強制トンネリングを構成するためには、以下の 2 種類の方法があります。</p><ul><li>方法 1. 対向のルーターと BGP で経路交換を行い、対向のルーターからデフォルト ルート 0.0.0.0/0 (を広報する)</li><li>方法 2. BGP は利用せず、ゲートウェイに DefaultSite の設定を行う</li></ul><h3 id="動作が変更される対象となる方法"><a href="#動作が変更される対象となる方法" class="headerlink" title="動作が変更される対象となる方法"></a>動作が変更される対象となる方法</h3><p>このうち、方法 2 を利用している場合は、SKU によって強制トンネリングのために必要な作業が少し異なります。SKU に AZ がつく場合は、DefaultSite の設定を行うだけで、仮想ネットワーク内の全てのサブネットに対して、デフォルト ルートを VPN に向けるルートが反映されます。</p><p>しかし AZ がつかない場合は、DefaultSite の設定を行うだけでは強制トンネリングのためのルートが適用されません。DefaultSite の設定に加えて、0.0.0.0/0 のネクストホップをゲートウェイにしたユーザー定義ルート (UDR) を各サブネットに適用することで、はじめて強制トンネリングがそのサブネットで有効になります。</p><p>今回の動作変更では、この動作を AZ がつく SKU に合わせます。つまり、DefaultSite の設定がされている環境では、0.0.0.0/0 をゲートウェイに向ける UDR が適用されていなくても、強制トンネリングが有効になります。対象の環境においては、強制トンネリングが現状有効になっていないサブネットで、2 月 24 日以降に突然強制トンネリングが有効になる、ということが起こり得ます。</p><p>※ 方法 1 (BGP) を利用している場合は、今回の動作変更による影響はありません。</p><p><br><br></p><h2 id="動作変更による影響が生じる条件"><a href="#動作変更による影響が生じる条件" class="headerlink" title="動作変更による影響が生じる条件"></a>動作変更による影響が生じる条件</h2><p>以下の 5 つの条件に <strong>すべて</strong> 合致した場合に、今回の動作変更の影響を受けます。</p><ul><li>A. VPN 用の仮想ネットワーク ゲートウェイがある</li><li>B. ゲートウェイの SKU は末尾に AZ がつかないものである</li><li>C. サイト間 VPN を利用している</li><li>D. BGP でデフォルト ルートを 0.0.0.0/0 を受信していない</li><li>E. DefaultSiteの設定がされている</li></ul><p>それぞれの条件についての合致確認の方法は、本記事の末尾にまとめております。</p><p><br><br></p><h2 id="条件にすべて合致した場合の対応"><a href="#条件にすべて合致した場合の対応" class="headerlink" title="条件にすべて合致した場合の対応"></a>条件にすべて合致した場合の対応</h2><p>上記の 5 つの条件に <strong>すべて</strong> 合致した場合、動作変更の影響が生じる可能性があります。つまり、0.0.0.0/0 をゲートウェイに向けるユーザー定義ルートが適用されていなくても、2 月 24 日以降の動作変更によって、強制トンネリングがそのサブネットで有効になります。</p><p>予期せず強制トンネリングが有効になることを防ぐためには、あらかじめ 0.0.0.0/0 のネクストホップをインターネットに向ける UDR を適用することが有効です。2 月 24 日よりも前にこの UDR を適用しておくことで、その UDR が適用されたサブネットでは、動作変更によって強制トンネリングが突然有効になる状況を回避することができます。</p><p>（したがって、現状ですでに 0.0.0.0/0 のネクストホップをインターネットに設定する UDR が適用されているサブネットについては、影響を受けません）</p><h3 id="対応手順の例"><a href="#対応手順の例" class="headerlink" title="対応手順の例"></a>対応手順の例</h3><p>具体的な手順の一例は以下のとおりです。各パラメーターについてはお客様の環境に合わせて確認および決定してください。</p><ol><li><p><b>Azure ポータルを開きます。<br></b><br><a href="https://portal.azure.com/">https://portal.azure.com/</a></p></li><li><p><b>すでに対象のサブネットにルート テーブルが適用されている場合は、手順 5) までスキップします。</b></p></li><li><p><b>[ルート テーブル] を開き、[+作成] をクリックします。</b></p></li><li><p><b>以下のパラメーターを入力し、[確認および作成] をクリックします。(詳細なパラメーターは環境に合わせてください)</b><br><br>　リソース グループ: 任意<br><br>　リージョン: ルート テーブルの適用対象の仮想ネットワークと合わせる<br><br>　名前: ルート テーブルの任意の名前<br><br>　ゲートウェイのルートを伝達する: Yes</p></li><li><p><b>4) で作成したルート テーブルか、既存のルート テーブルを開きます。</b></p></li><li><p><b>[ルート] メニューをクリックし、[+追加] をクリックします。</b></p></li><li><p><b>以下のパラメーターでルートを追加して [OK] をクリックします。</b><br><br>　ルート名: 任意の名前<br><br>　アドレス プレフィックス: 0.0.0.0/0<br><br>　ネクスト ホップの種類: インターネット<br></p></li><li><p><b>すでに対象のサブネットにルート テーブルが適用されている状態で作業を行った場合は、これで終了です。</b></p></li><li><p><b>[サブネット] メニューをクリックし、[+関連付け] をクリックします。</b></p></li><li><p><b>ルート テーブルの適用対象の仮想ネットワークとサブネットを選択して、[OK] をクリックします。</b></p></li></ol><p>※ ルート テーブルの設定手順は <a href="https://docs.microsoft.com/ja-jp/azure/virtual-network/manage-route-table">公開資料</a> でも説明されておりますので、あわせてご覧ください。</p><p><br>　<br>　<br></p><h2 id="条件に合致しているかどうかを確認するための詳細手順"><a href="#条件に合致しているかどうかを確認するための詳細手順" class="headerlink" title="条件に合致しているかどうかを確認するための詳細手順"></a>条件に合致しているかどうかを確認するための詳細手順</h2><p>A～E それぞれの条件について、合致しているかどうかを確認するための手順の一例をご紹介いたします。</p><h3 id="A-VPN-用の仮想ネットワーク-ゲートウェイがあることの確認"><a href="#A-VPN-用の仮想ネットワーク-ゲートウェイがあることの確認" class="headerlink" title="A. VPN 用の仮想ネットワーク ゲートウェイがあることの確認"></a>A. VPN 用の仮想ネットワーク ゲートウェイがあることの確認</h3><p>Azure ポータルで [仮想ネットワーク ゲートウェイ] メニューを開き、[ゲートウェイの種類] が [Vpn] のものがあれば、この条件に合致しています。</p><p><img src="/blog/network/vpn-defaultsite-update-2022feb/vpn-defaultsite-update-2022feb-a01.png" alt="画面イメージ"></p><h3 id="B-ゲートウェイの-SKU-は末尾に-AZ-がつかないものであることの確認"><a href="#B-ゲートウェイの-SKU-は末尾に-AZ-がつかないものであることの確認" class="headerlink" title="B. ゲートウェイの SKU は末尾に AZ がつかないものであることの確認"></a>B. ゲートウェイの SKU は末尾に AZ がつかないものであることの確認</h3><p>A. でみつけたゲートウェイをクリックし、[SKU] 欄を確認して「AZ」が含まれていないものであれば、この条件に合致しています。（以下の画像は「AZ」が含まれる場合の例、つまり条件に合致しない例です）</p><p><img src="/blog/network/vpn-defaultsite-update-2022feb/vpn-defaultsite-update-2022feb-b01.png" alt="画面イメージ"></p><h3 id="C-サイト間-VPN-を利用していることの確認"><a href="#C-サイト間-VPN-を利用していることの確認" class="headerlink" title="C. サイト間 VPN を利用していることの確認"></a>C. サイト間 VPN を利用していることの確認</h3><p>A. でみつけたゲートウェイをクリックし、[接続] メニューをクリックします。</p><p><img src="/blog/network/vpn-defaultsite-update-2022feb/vpn-defaultsite-update-2022feb-c01.png" alt="画面イメージ"></p><p>[接続] オブジェクトが表示されれば、この条件に合致しています。</p><p><img src="/blog/network/vpn-defaultsite-update-2022feb/vpn-defaultsite-update-2022feb-c02.png" alt="画面イメージ"></p><h3 id="D-BGP-でデフォルト-ルートを-0-0-0-0-0-を受信していないことの確認"><a href="#D-BGP-でデフォルト-ルートを-0-0-0-0-0-を受信していないことの確認" class="headerlink" title="D. BGP でデフォルト ルートを 0.0.0.0/0 を受信していないことの確認"></a>D. BGP でデフォルト ルートを 0.0.0.0/0 を受信していないことの確認</h3><p>A. でみつけたゲートウェイをクリックし、[BGP ピア] メニューをクリックします。</p><p>[学習したルート] に 0.0.0.0/0 が含まれて <strong>いなければ</strong>、この条件に合致しています。（0.0.0.0/0 が含まれていたら、この条件に合致しませんので今回の変更の影響も受けません。少し紛らわしいのでご注意ください）</p><h3 id="E-DefaultSiteの設定がされていることの確認"><a href="#E-DefaultSiteの設定がされていることの確認" class="headerlink" title="E. DefaultSiteの設定がされていることの確認"></a>E. DefaultSiteの設定がされていることの確認</h3><p>この確認は PowerShell での作業が必要になります。</p><ol><li><p><b>Azure PowerShell を起動するか、<a href="https://shell.azure.com/">Cloud Shell</a> (PowerShell を選択) を開きます。</b></p></li><li><p><b>Azure PowerShell の場合、以下のコマンドを実行してサインインします。</b><br><br>Login-AzAccount</p></li><li><p><b>A. でみつけたゲートウェイが構築されているサブスクリプション ID を確認し、以下のコマンドを実行して操作対象のサブスクリプションを指定します。</b><br><br>Select-AzSubscription -SubscriptionId &lt;確認したサブスクリプション ID&gt;</p></li><li><p><b>以下のコマンドを実行し、対象のゲートウェイの構成情報を取得・表示します。</b><br><br>Get-AzVirtualNetworkGateway -Name &lt;ゲートウェイの名前&gt; -ResourceGroupName &lt;ゲートウェイのリソース グループ名&gt;</p></li><li><p><b>出力結果の中から、GatewayDefaultSite という行を探します。サイト名の情報が入っている場合は、この条件に合致します。「null」となっている場合は合致しません。</b></p></li></ol><br><hr><p><br>　<br>　<br>　<br><br><b>※ 以下は、クラシック デプロイ モデルをご利用の方に向けた手順です。</b><br><br></p><hr><h2 id="クラシックの場合-条件にすべて合致した場合の対応"><a href="#クラシックの場合-条件にすべて合致した場合の対応" class="headerlink" title="(クラシックの場合) 条件にすべて合致した場合の対応"></a>(クラシックの場合) 条件にすべて合致した場合の対応</h2><p>クラシック デプロイ モデルをご利用の場合における具体的な手順の一例は以下のとおりです。各パラメーターについてはお客様の環境に合わせて確認および決定してください。</p><h3 id="事前準備-Azure-PowerShell-の利用"><a href="#事前準備-Azure-PowerShell-の利用" class="headerlink" title="事前準備: Azure PowerShell の利用"></a>事前準備: Azure PowerShell の利用</h3><p>クラシック デプロイ モデルにおける対処のためには、Azure PowerShell をご利用いただくことができます。対処用のコマンドを実行するためには、事前に以下のコマンドを実行する必要があります。</p><ol><li><p><b>以下のコマンドを実行し、サインインします。</b><br><br>Add-AzureAccount</p></li><li><p><b>以下のコマンドを実行し、対象のサブスクリプションを指定します。</b><br><br>Select-AzureSubscription -SubscriptionId &lt;サブスクリプション ID&gt;</p></li></ol><h3 id="対応手順の例-1"><a href="#対応手順の例-1" class="headerlink" title="対応手順の例"></a>対応手順の例</h3><p>具体的な手順の一例は以下のとおりです。各パラメーターについてはお客様の環境に合わせて確認および決定してください。</p><ol><li><p><b>対象のサブネットにすでにルート テーブルが適用されているかどうかを確認します。</b><br><br>Get-AzureSubnetRouteTable -VirtualNetworkName “仮想ネットワーク名” -SubnetName “サブネット名”</p></li><li><p><b>すでに対象のサブネットにルート テーブルが適用されている場合は、手順 4) までスキップします。</b></p></li><li><p><b>任意の名前でルート テーブルを作成します。</b><br><br>New-AzureRouteTable -Name “ルート テーブルの名前” -Location “リージョン名”</p></li><li><p><b>ルート テーブルに、0.0.0.0/0 のネクストホップを Internet に指定したルートを追加します。</b><br><br>Get-AzureRouteTable -Name “ルート テーブルの名前” | Set-AzureRoute -RouteName “DefaultRoute” -AddressPrefix “0.0.0.0/0” -NextHopType Internet</p></li><li><p><b>すでに対象のサブネットにルート テーブルが適用されている状態で作業を行った場合は、これで終了です。</b></p></li><li><p><b>ルート テーブルをサブネットに適用します。</b><br><br>Set-AzureSubnetRouteTable -VirtualNetworkName “仮想ネットワーク名” -SubnetName “サブネット名” -RouteTableName “ルート テーブルの名前”</p></li></ol><br><hr><br><h2 id="クラシックの場合-条件に合致しているかどうかを確認するための詳細手順"><a href="#クラシックの場合-条件に合致しているかどうかを確認するための詳細手順" class="headerlink" title="(クラシックの場合) 条件に合致しているかどうかを確認するための詳細手順"></a>(クラシックの場合) 条件に合致しているかどうかを確認するための詳細手順</h2><p>クラシック デプロイ モデルをご利用の場合において、A～E それぞれの条件について、合致しているかどうかを確認するための手順の一例をご紹介いたします。</p><h3 id="事前準備-Azure-PowerShell-の利用-1"><a href="#事前準備-Azure-PowerShell-の利用-1" class="headerlink" title="事前準備: Azure PowerShell の利用"></a>事前準備: Azure PowerShell の利用</h3><p>クラシック デプロイ モデルにおける合致確認には、Azure PowerShell をご利用いただくことができます。合致確認用のコマンドを実行するためには、事前に以下のコマンドを実行する必要があります。</p><ol><li><p><b>以下のコマンドを実行し、サインインします。</b><br><br>Add-AzureAccount</p></li><li><p><b>以下のコマンドを実行し、対象のサブスクリプションを指定します。</b><br><br>Select-AzureSubscription -SubscriptionId &lt;確認したサブスクリプション ID&gt;</p></li></ol><h3 id="A-VPN-用の仮想ネットワーク-ゲートウェイがあることの確認-1"><a href="#A-VPN-用の仮想ネットワーク-ゲートウェイがあることの確認-1" class="headerlink" title="A. VPN 用の仮想ネットワーク ゲートウェイがあることの確認"></a>A. VPN 用の仮想ネットワーク ゲートウェイがあることの確認</h3><p>(確認不要) 下記 E. の手順に包含されるため、本手順は割愛します。</p><h3 id="B-ゲートウェイの-SKU-は末尾に-AZ-がつかないものであることの確認-1"><a href="#B-ゲートウェイの-SKU-は末尾に-AZ-がつかないものであることの確認-1" class="headerlink" title="B. ゲートウェイの SKU は末尾に AZ がつかないものであることの確認"></a>B. ゲートウェイの SKU は末尾に AZ がつかないものであることの確認</h3><p>(確認不要) クラシックでは、必ず AZ がつかない SKU となりますので、本手順は割愛します。</p><h3 id="C-サイト間-VPN-を利用していることの確認-1"><a href="#C-サイト間-VPN-を利用していることの確認-1" class="headerlink" title="C. サイト間 VPN を利用していることの確認"></a>C. サイト間 VPN を利用していることの確認</h3><p>(確認不要) 下記 E. の手順に包含されるため、本手順は割愛します。</p><h3 id="D-BGP-でデフォルト-ルートを-0-0-0-0-0-を受信していないことの確認-1"><a href="#D-BGP-でデフォルト-ルートを-0-0-0-0-0-を受信していないことの確認-1" class="headerlink" title="D. BGP でデフォルト ルートを 0.0.0.0/0 を受信していないことの確認"></a>D. BGP でデフォルト ルートを 0.0.0.0/0 を受信していないことの確認</h3><p>(確認不要) クラシックでは BGP は利用できないため、本手順は割愛します。</p><h3 id="E-DefaultSiteの設定がされていることの確認-1"><a href="#E-DefaultSiteの設定がされていることの確認-1" class="headerlink" title="E. DefaultSiteの設定がされていることの確認"></a>E. DefaultSiteの設定がされていることの確認</h3><ol><li><p><b>Azure PowerShell で以下のコマンドを実行します。</b><br><br>Get-AzureVirtualNetworkGateway</p></li><li><p><b>表示されたゲートウェイの一覧から、以下のように DefaultSite に値が入っているものがあれば、合致しています。</b><br></p><blockquote><p>GatewayId            : xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx<br><br>GatewayName          : Default<br><br>LastEventData        :<br><br>GatewayType          : DynamicRouting<br><br>LastEventTimeStamp   : xx/xx/xxxx xx:xx:xx<br><br>LastEventMessage     : Successfully updated the gateway for the following virtual network: xxxx <b>← 通常、ここに対象の仮想ネットワーク名が入ります。</b><br><br>LastEventID          : xxxxx<br><br>State                : Provisioned<br><br>VIPAddress           : x.x.x.x<br><br>DefaultSite          : Site01 <b>← ここにサイト名が入っていれば該当しています。該当しない場合空欄です。</b><br><br>GatewaySKU           : Standard<br><br>Location             : Japan East<br><br>VnetId               : xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx<br><br>SubnetId             :<br><br>EnableBgp            : False<br><br>Asn                  : xxxxx<br><br>BgpPeeringAddress    : x.x.x.x<br><br>PeerWeight           : 0<br><br>OperationDescription :<br><br>OperationId          :<br><br>OperationStatus      :<br></p></blockquote></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームです。&lt;/p&gt;
&lt;p&gt;Azure の仮想ネットワーク ゲートウェイ (以下「ゲートウェイ」) を用いたサイト間 VPN 接続について、2022 年 2 月 24 日以降に、強制トンネリングに関する一部の動作の変更が行われることがアナウンスされました。&lt;/p&gt;
&lt;p&gt;影響が生じる可能性のあるお客様には通知がすでに送信されているか、近日中に送信されることが想定されます。しかしながら、通知に含まれる説明は要点のみとなっているため、本記事にてその補足をさせていただきます。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;※追記&lt;/strong&gt;&lt;br&gt;2023 年 5 月 再度、強制トンネリング利用時の仮想ネットワーク ゲートウェイの動作変更のアナウンス (Tracking ID:VK3J-580)が通知されました。&lt;br&gt;これは、2022 年に通知されたアナウンス (Tracking ID:ZTPX-19Z)と同様の内容となりますが、動作変更の延期により今回あらためて仮想ネットワーク ゲートウェイ は、2023/6/12 ~ 6/16 の間に動作変更が実施されるという旨のアナウンスとなります。&lt;br&gt;2022 年に通知を受け取ったお客様の中で、下記の対応を行っていない環境については、動作変更の影響を受ける条件や合致確認の方法、動作変更の内容および変更の影響を受けないようにする対処方法をご確認の上、2023/6/12 より前にご対応いただけますと幸いでございます。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Network" scheme="https://jpaztech.github.io/blog/tags/Network/"/>
    
    <category term="VPN Gateway" scheme="https://jpaztech.github.io/blog/tags/VPN-Gateway/"/>
    
  </entry>
  
  <entry>
    <title>Azure VM のディスクパフォーマンス状況の確認方法について</title>
    <link href="https://jpaztech.github.io/blog/vm/disk-metrics/"/>
    <id>https://jpaztech.github.io/blog/vm/disk-metrics/</id>
    <published>2023-05-10T08:30:00.000Z</published>
    <updated>2023-08-18T00:59:11.470Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの富田です。<br>期待したディスクパフォーマンスが得られないといったお問い合わせをいただくことがあります。<br>そのため、今回この記事以下の内容について解説をさせていただきます。  </p><ol><li>Azure 側にて VM サイズとディスクサイズ毎に設定されている上限について解説</li><li>ディスクに関するメトリックでパフォーマンスを確認する方法</li><li>VM サイズとディスクサイズを変更する方法</li></ol><div class="alert is-info"><p class="alert-title">Note</p><p>本記事では各種の上限について数値を交えて解説しておりますが、こちらは理論値となっており実際の計測では OS レイヤ以上の影響等もございますので、必ずしも記載の理論値が計測可能であることを保証するものではございません点について予めご了承くださいませ。</p></div><hr><h2 id="1-1-VM-サイズとディスクサイズ毎に設定されている上限について解説"><a href="#1-1-VM-サイズとディスクサイズ毎に設定されている上限について解説" class="headerlink" title="1-1.VM サイズとディスクサイズ毎に設定されている上限について解説"></a>1-1.VM サイズとディスクサイズ毎に設定されている上限について解説</h2><p>まずは、Azure VM におけるディスクのパフォーマンスの上限値について解説させていただきます。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p>ディスク性能の上限はオンプレミス上の物理ディスクでも勿論あるものであり、OS から高負荷な I/O 要求が発生し、ディスク性能の上限に達した場合、 I/O に遅延等が発生することはご理解いただけるかと存じます。</p><p>Azure のディスク性能も同じような考え方となります。上限に達した場合は、オンプレミス環境と同様に I/O の遅延等が発生しますが、これは Azure 特有のものでは無く、オンプレミス環境と同じように発生するものであると考えていただけますと幸いです。</p></div><p>オンプレミス環境のサーバーや私たちが普段使用しているパソコンと同様に、Azure VM でもディスクアクセスが行われます。<br>Azure ではこの VM とディスク間のディスクアクセスについて、「VMサイズ」と「ディスクサイズ」のそれぞれ両方で「MBps」と「IOPS」の上限値を設定しています。  </p><p>なお、この上限は Read / Write の合計で適用されます。<br>つまり Read が 100 MBps、Write が 50 MBps 同時に発生していたら、150 MBps のディスクアクセスとして合算されます。  </p><p>重要な点として、ディスクアクセスの上限は「VMサイズ」と「ディスクサイズ」に設定されている低い方の上限値が適用されます。<br>ホストキャッシュやバーストは無効と考えて、VM とデータディスク間の通信について以下に例を記載します。  </p><p><img src="/blog/vm/disk-metrics/bisk-base.png"></p><p>上記の例では Standard_D2s_v5 の VM サイズに P20 のデータディスクのサイズを組み合わせています。</p><ul><li>Standard_D2s_v5 の VM サイズでの上限：85 MBps / 3750 IOSP</li><li>P20 のディスクサイズでの上限：150 MBps / 2300 IOPS</li></ul><p>という設定がございます。<br>先に解説した通り低い値の方（赤字）が適用されますので、実際に想定される速度の上限値としては「85 MBps / 2300 IOPS」となります。</p><p>なお、この「Standard_D2s_v5 の VM サイズでの上限：85 MBps / 3750 IOSP」という VM の上限値については、ディスク 1 つごとでは無く、ホストキャッシュ無効な全てのデータディスク全体で共有されます。<br>すなわち、複数のホストキャッシュ無効なデータディスク合算で 85 MBps / 3750 IOSP が上限となります。 </p><p>ホストキャッシュの有効なディスク・無効なディスクで上限値が別に設定されている VM サイズもございます。<br>各 VM サイズおよびディスクサイズにおけるディスクアクセスの上限値は、公式ドキュメントをご確認くださいませ。  </p><blockquote><p>■ご参考：Azure の仮想マシンのサイズ<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/sizes">https://learn.microsoft.com/ja-jp/azure/virtual-machines/sizes</a></p></blockquote><blockquote><p>■ご参考：Azure マネージド ディスクの種類<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/disks-types">https://learn.microsoft.com/ja-jp/azure/virtual-machines/disks-types</a></p></blockquote><hr><h2 id="1-2-一時的に通信の上限を上げる「ディスクバースト」という機能がございます"><a href="#1-2-一時的に通信の上限を上げる「ディスクバースト」という機能がございます" class="headerlink" title="1-2.一時的に通信の上限を上げる「ディスクバースト」という機能がございます"></a>1-2.一時的に通信の上限を上げる「ディスクバースト」という機能がございます</h2><p>先に記載した通り、「VMサイズ」と「ディスクサイズ」それぞれにディスクアクセスの上限が設定されています。<br>しかしながら、特定の「VMサイズ」と「ディスクサイズ」には、このディスクアクセスの上限を一時的に上げられる「ディスクバースト」という機能がございます。</p><ul><li>VM サイズに設定されているディスクアクセスの上限値が一時的に上がること = VM レベルのバースト</li><li>ディスクサイズに設定されているディスクアクセスの上限値が一時的に上がること = ディスクレベルのバースト</li></ul><p>ディスクバーストの詳細については公式ドキュメントをご参照くださいませ。</p><blockquote><p>■ご参考：マネージド ディスクのバースト<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/disk-bursting">https://learn.microsoft.com/ja-jp/azure/virtual-machines/disk-bursting</a></p></blockquote><p>なお、クレジットベースのバーストの場合、VM レベルのバーストとディスクレベルのバーストは独立しており、<br>以下のように 6 種類のクレジットが独立している点、ご留意くださいませ。</p><ul><li>VM レベルに関する MBps のバーストクレジット（キャッシュ無し）</li><li>VM レベルに関する IOPS のバーストクレジット（キャッシュ無し）</li><li>VM レベルに関する MBps のバーストクレジット（キャッシュあり）</li><li>VM レベルに関する IOPS のバーストクレジット（キャッシュあり）</li><li>ディスクレベルに関する MBps のバーストクレジット</li><li>ディスクレベルに関する IOPS のバーストクレジット</li></ul><p>では、ホストキャッシュは無しとして、バーストが発生した際の例を見てみましょう。</p><p><img src="/blog/vm/disk-metrics/disk-burst.png"></p><p>上記は、Standard_D2s_v5 の VM サイズに P20 のデータディスクのサイズを組み合わせて、VM レベルのバースト・ディスクレベルのバースト両方が働いた場合の例です。<br>一時的に「170 MBps / 3500 IPOS」までバースト可能なことが分かりましたね。</p><hr><h2 id="2-1-ディスクに関するメトリックでパフォーマンスを確認する方法"><a href="#2-1-ディスクに関するメトリックでパフォーマンスを確認する方法" class="headerlink" title="2-1.ディスクに関するメトリックでパフォーマンスを確認する方法"></a>2-1.ディスクに関するメトリックでパフォーマンスを確認する方法</h2><p>Azure では、ディスクアクセスに関してどの程度のパフォーマンスが出ているかといったことを記録しており、メトリックとして確認を行うことが可能です。<br>パフォーマンスが上限で頭打ちしている場合は、スペックアップが必要である可能性があるといったことを確認することができます。</p><p>パフォーマンスが上限で頭打ちしていないにも関わらず、期待したパフォーマンスを得られていない場合は、<br>OS やアプリケーションが適切なディスクアクセスを発生させていない可能性がございます。<br>ディスクパフォーマンスの詳細については以下の記事もご参照くださいませ。  </p><blockquote><p>■ご参考：Azure Premium Storage: 高パフォーマンス用に設計する<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/premium-storage-performance">https://learn.microsoft.com/ja-jp/azure/virtual-machines/premium-storage-performance</a></p></blockquote><p>Azure ではこの調査に役立つ多くのディスクに関するメトリックがございますので、一覧形式でご紹介させていただきます。</p><div class="alert is-info"><p class="alert-title">Note</p><p>これらの記録された値については Azure 基盤上で観測された値となりますため、OS 上で観測した値と差異がある可能性がございます点、予めご了承ください。</p><p>また、メトリック表示の最小の粒度は 1 分でございますため、瞬間的な状況等は確認が叶いません点、ご留意ください。</p></div><h3 id="OS-ディスクの-Read-Write-に関して何-MBps-IOPS-が記録されたか確認する"><a href="#OS-ディスクの-Read-Write-に関して何-MBps-IOPS-が記録されたか確認する" class="headerlink" title="OS ディスクの Read / Write に関して何 MBps / IOPS が記録されたか確認する"></a>OS ディスクの Read / Write に関して何 MBps / IOPS が記録されたか確認する</h3><table><thead><tr><th align="left">確認できる内容</th><th align="left">メトリック名</th></tr></thead><tbody><tr><td align="left">OS ディスクの Read が何 MBps 記録されたか確認</td><td align="left">OS Disk Read Bytes/Sec</td></tr><tr><td align="left">OS ディスクの Write が何 MBps 記録されたか確認</td><td align="left">OS Disk Write Bytes/Sec</td></tr><tr><td align="left">OS ディスクの Read が何 IOPS 記録されたか確認</td><td align="left">OS Disk Read Operations/Sec</td></tr><tr><td align="left">OS ディスクの Write が何 IOPS 記録されたか確認</td><td align="left">OS Disk Write Operations/Sec</td></tr></tbody></table><h3 id="データディスクの-Read-Write-に関して何-MBps-IOPS-が記録されたか確認する"><a href="#データディスクの-Read-Write-に関して何-MBps-IOPS-が記録されたか確認する" class="headerlink" title="データディスクの Read / Write に関して何 MBps / IOPS が記録されたか確認する"></a>データディスクの Read / Write に関して何 MBps / IOPS が記録されたか確認する</h3><table><thead><tr><th align="left">確認できる内容</th><th align="left">メトリック名</th></tr></thead><tbody><tr><td align="left">データディスクの Read が何 MBps 記録されたか確認</td><td align="left">Data Disk Read Bytes/Sec</td></tr><tr><td align="left">データディスクの Write が何 MBps 記録されたか確認</td><td align="left">Data Disk Write Bytes/Sec</td></tr><tr><td align="left">データディスクの Read が何 IOPS 記録されたか確認</td><td align="left">Data Disk Read Operations/Sec</td></tr><tr><td align="left">データディスクの Write が何 IOPS 記録されたか確認</td><td align="left">Data Disk Write Operations/Sec</td></tr><tr><td align="left"></td><td align="left"></td></tr></tbody></table><h3 id="VM-レベルのディスクバーストのクレジットの残りがどれくらいか確認する"><a href="#VM-レベルのディスクバーストのクレジットの残りがどれくらいか確認する" class="headerlink" title="VM レベルのディスクバーストのクレジットの残りがどれくらいか確認する"></a>VM レベルのディスクバーストのクレジットの残りがどれくらいか確認する</h3><table><thead><tr><th align="left">確認できる内容</th><th align="left">メトリック名</th></tr></thead><tbody><tr><td align="left">VM レベルの MBps の残バーストクレジット量（キャッシュ有効であるディスク）</td><td align="left">VM Cached Used Burst BPS Credits Percentage</td></tr><tr><td align="left">VM レベルの IOPS の残バーストクレジット量（キャッシュ有効であるディスク）</td><td align="left">VM Cached Used Burst IO Credits Percentage</td></tr><tr><td align="left">VM レベルの MBps の残バーストクレジット量（キャッシュ<strong>無効</strong>なディスク）</td><td align="left">VM Uncached Used Burst BPS Credits Percentage</td></tr><tr><td align="left">VM レベルの IOPS の残バーストクレジット量（キャッシュ<strong>無効</strong>なディスク）</td><td align="left">VM Uncached Used Burst IO Credits Percentage</td></tr><tr><td align="left"></td><td align="left"></td></tr></tbody></table><h3 id="ディスクレベルのディスクバーストのクレジットの残りがどれくらいか確認する"><a href="#ディスクレベルのディスクバーストのクレジットの残りがどれくらいか確認する" class="headerlink" title="ディスクレベルのディスクバーストのクレジットの残りがどれくらいか確認する"></a>ディスクレベルのディスクバーストのクレジットの残りがどれくらいか確認する</h3><table><thead><tr><th align="left">確認できる内容</th><th align="left">メトリック名</th></tr></thead><tbody><tr><td align="left">ディスクレベルの MBps の残バーストクレジット量（OS ディスク）</td><td align="left">OS Disk Used Burst BPS Credits Percentage</td></tr><tr><td align="left">ディスクレベルの IOPS の残バーストクレジット量（OS ディスク）</td><td align="left">OS Disk Used Burst IO Credits Percentage</td></tr><tr><td align="left">ディスクレベルの MBps の残バーストクレジット量（データディスク）</td><td align="left">Data Disk Used Burst BPS Credits Percentage</td></tr><tr><td align="left">ディスクレベルの IOPS の残バーストクレジット量（データディスク）</td><td align="left">Data Disk Used Burst IO Credits Percentage</td></tr></tbody></table><h3 id="ディスクレベルのベースパフォーマンスに対して何-のパフォーマンスが記録されたか確認する"><a href="#ディスクレベルのベースパフォーマンスに対して何-のパフォーマンスが記録されたか確認する" class="headerlink" title="ディスクレベルのベースパフォーマンスに対して何 % のパフォーマンスが記録されたか確認する"></a>ディスクレベルのベースパフォーマンスに対して何 % のパフォーマンスが記録されたか確認する</h3><table><thead><tr><th align="left">確認できる内容</th><th align="left">メトリック名</th></tr></thead><tbody><tr><td align="left">ディスクレベルのベースパフォーマンスに対して計測された MBps のパーセント表示（OS ディスク）</td><td align="left">OS Disk Bandwidth Consumed Percentage</td></tr><tr><td align="left">ディスクレベルのベースパフォーマンスに対して計測された IOPS のパーセント表示（OS ディスク）</td><td align="left">OS Disk IOPS Consumed Percentage</td></tr><tr><td align="left">ディスクレベルのベースパフォーマンスに対して計測された MBps のパーセント表示（データディスク）</td><td align="left">Data Disk Bandwidth Consumed Percentage</td></tr><tr><td align="left">ディスクレベルのベースパフォーマンスに対して計測された IOPS のパーセント表示（データディスク）</td><td align="left">Data Disk IOPS Consumed Percentage</td></tr></tbody></table><div class="alert is-info"><p class="alert-title">Note</p><p>※Premium ストレージをサポートする VM シリーズ上でのみ使用できます。</p><p>※バースト時の上限ではなくベースパフォーマンスを 100 % として記録されます。バーストしている場合も 100 % で記録されます。</p></div><h3 id="VM-レベルのベースパフォーマンスに対して何-のパフォーマンスが記録されたか確認する"><a href="#VM-レベルのベースパフォーマンスに対して何-のパフォーマンスが記録されたか確認する" class="headerlink" title="VM レベルのベースパフォーマンスに対して何 % のパフォーマンスが記録されたか確認する"></a>VM レベルのベースパフォーマンスに対して何 % のパフォーマンスが記録されたか確認する</h3><table><thead><tr><th align="left">確認できる内容</th><th align="left">メトリック名</th></tr></thead><tbody><tr><td align="left">VMレベルのベースパフォーマンスに対して計測された MBps のパーセント表示（キャッシュ有効であるディスク）</td><td align="left">VM Cached Bandwidth Consumed Percentage</td></tr><tr><td align="left">VMレベルのベースパフォーマンスに対して計測された IOPS のパーセント表示（キャッシュ有効であるディスク）</td><td align="left">VM Cached IOPS Consumed Percentage</td></tr><tr><td align="left">VMレベルのベースパフォーマンスに対して計測された MBps のパーセント表示（キャッシュ<strong>無効</strong>なディスク）</td><td align="left">VM Uncached Bandwidth Consumed Percentage</td></tr><tr><td align="left">VMレベルのベースパフォーマンスに対して計測された IOPS のパーセント表示（キャッシュ<strong>無効</strong>なディスク）</td><td align="left">VM Uncached IOPS Consumed Percentage</td></tr></tbody></table><div class="alert is-info"><p class="alert-title">Note</p><p>※Premium ストレージをサポートする VM シリーズ上でのみ使用できます。</p><p>※バースト時の上限ではなくベースパフォーマンスを 100 % として記録されます。バーストしている場合も 100 % で記録されます。</p></div><h3 id="ディスクのキューの深さを確認する"><a href="#ディスクのキューの深さを確認する" class="headerlink" title="ディスクのキューの深さを確認する"></a>ディスクのキューの深さを確認する</h3><table><thead><tr><th align="left">確認できる内容</th><th align="left">メトリック名</th></tr></thead><tbody><tr><td align="left">OS ディスクのキューの深さを確認</td><td align="left">OS Disk Queue Depth</td></tr><tr><td align="left">データ ディスクのキューの深さを確認</td><td align="left">Data Disk Queue Depth</td></tr></tbody></table><p>ディスク パフォーマンス メトリックについては公式ドキュメントもございますので、合わせてご参照くださいませ。</p><blockquote><p>■ご参考：ディスク パフォーマンス メトリック<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/disks-metrics">https://learn.microsoft.com/ja-jp/azure/virtual-machines/disks-metrics</a></p></blockquote><hr><h2 id="2-2-実際に-Azure-ポータルでメトリックを確認する（データディスク毎に確認する方法）"><a href="#2-2-実際に-Azure-ポータルでメトリックを確認する（データディスク毎に確認する方法）" class="headerlink" title="2-2.実際に Azure ポータルでメトリックを確認する（データディスク毎に確認する方法）"></a>2-2.実際に Azure ポータルでメトリックを確認する（データディスク毎に確認する方法）</h2><p>メトリックを見る際は以下のように、Azure ポータルで対象の VM の画面より「メトリック」のブレードを選択いただくことでメトリック表示画面になります。</p><p><img src="/blog/vm/disk-metrics/disk-metric.png"></p><p>メトリックの表示自体の詳細を確認したい場合は、以下の公開ドキュメントをご参照ください。</p><blockquote><p>■ご参考: Azure Monitor メトリックの概要<br><a href="https://docs.microsoft.com/ja-jp/azure/azure-monitor/essentials/data-platform-metrics">https://docs.microsoft.com/ja-jp/azure/azure-monitor/essentials/data-platform-metrics</a></p></blockquote><blockquote><p>■ご参考：Azure Monitor のサポートされるメトリック<br><a href="https://docs.microsoft.com/ja-jp/azure/azure-monitor/essentials/metrics-supported">https://docs.microsoft.com/ja-jp/azure/azure-monitor/essentials/metrics-supported</a></p></blockquote><p>データディスクのメトリックでは、既定の表示では全データディスクの値が合算されたりした状態で表示されてしまいます。<br>各データディスク毎にメトリックを確認したい場合は、以下の手順に沿う必要がございます。<br>まず、以下のように VM のディスクブレードからデータディスクの LUN 番号を確認しましょう。  </p><p><img src="/blog/vm/disk-metrics/disk-lun.png"></p><p>以下のようにメトリック画面でディメンションを LUN で分割すると、各データディスク毎のメトリックの表示が可能になります。<br>下図では 2 つのデータディスクの情報がそれぞれ表示されていますね。</p><p><img src="/blog/vm/disk-metrics/disk-metric-lun.png"></p><p>また、LUN でフィルターをすることで、特定のデータディスクのみ表示することも可能です。</p><p><img src="/blog/vm/disk-metrics/disk-metric-filter.png"></p><hr><h2 id="3-VM-サイズ-ディスクサイズを変更する"><a href="#3-VM-サイズ-ディスクサイズを変更する" class="headerlink" title="3.VM サイズ / ディスクサイズを変更する"></a>3.VM サイズ / ディスクサイズを変更する</h2><p>上記のメトリックなどを確認の上、更に高パフォーマンスなディスクアクセスが必要となった場合は、VM サイズ / ディスクサイズを変更することが可能です。<br>オンプレミス環境の場合は新しいハードウェアの調達などが必要でしたが Azure では簡単に変更をすることが可能です。<br>手順については以下のドキュメントをご確認いただけますと幸いです。  </p><blockquote><p>■ご参考：仮想マシンのサイズの変更<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/resize-vm">https://learn.microsoft.com/ja-jp/azure/virtual-machines/resize-vm</a></p></blockquote><blockquote><p>■ご参考：マネージド ディスクをある特定のディスクの種類から別のものに切り替える<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/convert-disk-storage#switch-managed-disks-from-one-disk-type-to-another">https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/convert-disk-storage#switch-managed-disks-from-one-disk-type-to-another</a></p></blockquote><p>VM サイズ / ディスクサイズ変更には VM 停止が必要となります点、ご留意くださいませ。</p><hr><p>以上の通り、ディスクのディスクメトリックの確認について解説をさせていただきました。<br>お客様の調査等の一助となれば幸いでございます。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの富田です。&lt;br&gt;期待したディスクパフォーマンスが得られないといったお問い合わせをいただくことがあります。&lt;br&gt;そのため、今回この記事以下の内容について解説をさせていただきます。  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Azur</summary>
      
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="Linux" scheme="https://jpaztech.github.io/blog/tags/Linux/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
    <category term="Disk" scheme="https://jpaztech.github.io/blog/tags/Disk/"/>
    
  </entry>
  
  <entry>
    <title>yum/dnf update に失敗する場合の原因と解決方法</title>
    <link href="https://jpaztech.github.io/blog/vm/rhui-yum-update/"/>
    <id>https://jpaztech.github.io/blog/vm/rhui-yum-update/</id>
    <published>2023-05-02T02:00:00.000Z</published>
    <updated>2023-08-18T00:59:11.698Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは！Azure テクニカル サポート チームの高橋です。<br>今回はよく、お問い合わせを頂く<br>Azure Marketplace から作成した Red Hat Enterprise Linux (RHEL) の仮想マシンにおいて<br>yum / dnf update やパッケージのインストールに失敗する場合の<br>よくある原因とその解決方法についてご紹介いたします。</p><span id="more"></span><hr><h2 id="Azure-RHUI-リポジトリ-とは？"><a href="#Azure-RHUI-リポジトリ-とは？" class="headerlink" title="Azure RHUI (リポジトリ) とは？"></a>Azure RHUI (リポジトリ) とは？</h2><p>Azure RHUI  (Red Hat Update Infrastructure) は、Azure Marketplace にある<br>Red Hat Enterprise Linux (RHEL) の従量課金 (PAYG) イメージから作成した VM を更新するために<br>提供されているリポジトリサーバーです。</p><p>Azure Marketplace から 作成した RHEL VM は、規定で Azure RHUI へのアクセスする構成が設定されているため<br>追加の設定は不要となります。</p><p>VM から、Azure RHUI にアクセスするためには、下記の IP アドレスに対する送信規則の 443 ポートの通信許可を設定する必要があります。<br>Azure RHUI の IP アドレスは下記公開ドキュメントにおまとめしておりますのでご確認ください。<br>RHEL 7、RHEL 8 は RHUI 3、RHEL 9 は RHUI 4 が利用されております。</p><blockquote><p> □ 参考 : RHUI コンテンツ配信サーバーの IP アドレス<br>   <a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/workloads/redhat/redhat-rhui#the-ips-for-the-rhui-content-delivery-servers">https://learn.microsoft.com/ja-jp/azure/virtual-machines/workloads/redhat/redhat-rhui#the-ips-for-the-rhui-content-delivery-servers</a></p></blockquote><div class="alert is-important"><p class="alert-title">重要</p><p>※Azure RHUI へのアクセスは、弊社バックボーンネットワーク経由にて接続されており、</p><p>Azure VM から、オンプレミスのネットワークインフラストラクチャや、プロキシ、NVA (仮想アプライアンス) 経由でのアクセスはサポートされておらず、</p><p>Azure VM から直接、Azure RHUI に接続する必要がある点に注意してください。</p></div><hr><h2 id="Azure-RHUI-への接続確認"><a href="#Azure-RHUI-への接続確認" class="headerlink" title="Azure RHUI への接続確認"></a>Azure RHUI への接続確認</h2><p>yum / dnf update やパッケージのインストールに失敗する場合、<br>Azure RHUI への接続ができていない可能性がございます。<br>Azure VM 内から、curl コマンド等を使うことで、Azure RHUI への接続状況を確認することができます。<br>下記のコマンドをお試しください。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl -v https://rhui-1.microsoft.com:443</span></span><br><span class="line"><span class="comment"># curl -v https://rhui-2.microsoft.com:443</span></span><br><span class="line"><span class="comment"># curl -v https://rhui-3.microsoft.com:443</span></span><br></pre></td></tr></table></figure><p>&lt; 実行結果例 (成功時) &gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@rheltest ~]# curl -v https://rhui-1.microsoft.com:443</span><br><span class="line">* Rebuilt URL to: https://rhui-1.microsoft.com:443/</span><br><span class="line">*   Trying 52.187.75.218...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* Connected to rhui-1.microsoft.com (52.187.75.218) port 443 (#0)</span><br><span class="line">* ALPN, offering h2</span><br><span class="line">* ALPN, offering http/1.1</span><br><span class="line">* successfully set certificate verify locations:</span><br><span class="line">*   CAfile: /etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">CApath: none</span><br><span class="line">* TLSv1.3 (OUT), TLS handshake, Client hello (1):</span><br><span class="line">* TLSv1.3 (IN), TLS handshake, Server hello (2):</span><br><span class="line">* TLSv1.2 (IN), TLS handshake, Certificate (11):</span><br><span class="line">* TLSv1.2 (IN), TLS handshake, Server key exchange (12):</span><br><span class="line">* TLSv1.2 (IN), TLS handshake, Server finished (14):</span><br><span class="line">* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):</span><br><span class="line">* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):</span><br><span class="line">* TLSv1.2 (OUT), TLS handshake, Finished (20):</span><br><span class="line">* TLSv1.2 (IN), TLS handshake, Finished (20):</span><br><span class="line">* SSL connection using TLSv1.2 / ECDHE-RSA-AES256-GCM-SHA384</span><br><span class="line">* ALPN, server did not agree to a protocol</span><br><span class="line">* Server certificate:</span><br><span class="line">*  subject: C=US; ST=WA; L=Redmond; O=Microsoft Corporation; CN=rhui-1.microsoft.com</span><br><span class="line">*  start date: Dec  7 11:14:49 2021 GMT</span><br><span class="line">*  expire date: Dec  2 11:14:49 2022 GMT</span><br><span class="line">*  subjectAltName: host &quot;rhui-1.microsoft.com&quot; matched cert&#x27;s &quot;rhui-1.microsoft.com&quot;</span><br><span class="line">*  issuer: C=US; O=Microsoft Corporation; CN=Microsoft Azure TLS Issuing CA 01</span><br><span class="line">*  SSL certificate verify ok.</span><br><span class="line">&gt; GET / HTTP/1.1</span><br><span class="line">&gt; Host: rhui-1.microsoft.com</span><br><span class="line">&gt; User-Agent: curl/7.61.1</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Date: Mon, 24 Jan 2022 06:51:00 GMT</span><br><span class="line">&lt; Server: Apache/2.4.6 (Red Hat Enterprise Linux)</span><br><span class="line">&lt; X-Served-By: southeastasia-cds0</span><br><span class="line">&lt; X-Content-Type-Options: nosniff</span><br><span class="line">&lt; Last-Modified: Thu, 20 Jun 2019 06:37:48 GMT</span><br><span class="line">&lt; ETag: &quot;0-58bbb9592306b&quot;</span><br><span class="line">&lt; Accept-Ranges: bytes</span><br><span class="line">&lt; Content-Length: 0</span><br><span class="line">&lt; Connection: close</span><br><span class="line">&lt; Content-Type: text/html</span><br><span class="line">&lt;</span><br><span class="line">* Closing connection 0</span><br><span class="line">* TLSv1.2 (OUT), TLS alert, close notify (256):</span><br></pre></td></tr></table></figure><p>&lt; 実行結果例 (失敗時) &gt; </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@rhelvm ~]# curl -v https://rhui-1.microsoft.com:443</span><br><span class="line">* Rebuilt URL to: https://rhui-1.microsoft.com:443/</span><br><span class="line">*   Trying 52.187.75.218...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* connect to 52.187.75.218 port 443 failed: Connection timed out</span><br><span class="line">* Failed to connect to rhui-1.microsoft.com port 443: Connection timed out</span><br><span class="line">* Closing connection 0</span><br><span class="line">curl: (7) Failed to connect to rhui-1.microsoft.com port 443: Connection timed out</span><br></pre></td></tr></table></figure><p>Azure RHUI への接続確認が失敗する場合には、NSG やプロキシ等のネットワーク設定を確認する必要がございます。<br>よくお問い合わせを頂くエラー原因と解決方法は、以下のようになります。</p><hr><h2 id="エラーの原因その-1-Azure-RHUI-への接続ができない-NSG"><a href="#エラーの原因その-1-Azure-RHUI-への接続ができない-NSG" class="headerlink" title="エラーの原因その 1 : Azure RHUI への接続ができない (NSG)"></a>エラーの原因その 1 : Azure RHUI への接続ができない (NSG)</h2><p>セキュリティ上の理由から、Network Security Group (NSG) を利用して、<br>Azure VM からインターネットへのアクセスを制限を設定している場合があるかと存じます。<br>Azure portal から対象の仮想マシンを選択後、[ネットワーク] から確認することができます。<br>下記画像の例では、送信ポートの規則で、インターネットへの接続を拒否しています。</p><p><img src="/blog/vm/rhui-yum-update/01.png"></p><p>本設定がある場合には、Azure RHUI への接続確認は、失敗することが想定され、<br>yum update を実施した際や、パッケージのインストール時にはタイムアウトエラーが発生します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@rhelvm ~]# yum update</span><br><span class="line">Red Hat Enterprise Linux 8 for x86_64 - BaseOS - Extended Update Support from RHUI (RPMs)                                                              0.0  B/s |   0  B     01:30</span><br><span class="line">Failed to download metadata for repo &#x27;rhel-8-for-x86_64-baseos-eus-rhui-rpms&#x27;</span><br><span class="line">Error: Failed to download metadata for repo &#x27;rhel-8-for-x86_64-baseos-eus-rhui-rpms&#x27;</span><br></pre></td></tr></table></figure><p><img src="/blog/vm/rhui-yum-update/02.png"></p><p>この場合の解決方法としては、Azure RHUI へアクセスできるように、<br>Azure RHUI サーバーの IP アドレスに対する送信規則の 443 ポートの通信許可を設定する必要があります。<br>下記画像の通り、”送信セキュリティ規則の追加” から、通信許可の設定を追加する必要があります。<br>また、優先度は、DenyInternet (インターネットへの制限規則) より高くする必要がある点にご注意ください。</p><p><img src="/blog/vm/rhui-yum-update/03.png"></p><hr><h2 id="エラーの原因その-2-Azure-RHUI-への接続ができない-Proxy-等"><a href="#エラーの原因その-2-Azure-RHUI-への接続ができない-Proxy-等" class="headerlink" title="エラーの原因その 2 : Azure RHUI への接続ができない (Proxy 等)"></a>エラーの原因その 2 : Azure RHUI への接続ができない (Proxy 等)</h2><p>Azure VM から、オンプレミスのネットワークインフラストラクチャや、プロキシ、NVA (仮想アプライアンス) 経由での Azure RHUI へのアクセスはサポートされていないため、<br>Azure RHUI へのアクセスは、Azure 内の IP アドレス範囲内の VM から直接アクセスする必要がございます。<br>Azure Firewall をご利用の場合には、適切に Azure RHUI に対してアクセスできるよう設定頂くことで、アクセス可能となります。</p><p>この場合の解決方法としては、Azure VM が Azure RHUI の IP アドレスに直接接続できるようユーザー定義のルートテーブル UDR (User Defined Route) を作成する必要があります。<br>下記画像のように、RHUI コンテンツ配信サーバーの IP アドレス全てに対して、<br>次ホップ (Next hops) の種類に “Internet” を指定した UDR を作成頂く必要があります。</p><p><img src="/blog/vm/rhui-yum-update/04.png"></p><p>Azure VM のルートテーブルの作成手順については、下記公開ドキュメントをご確認ください。</p><blockquote><p>  □ 参考 : ルート テーブルの作成、変更、削除 | ルートの作成<br>   <a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/manage-route-table#create-a-route-table">https://learn.microsoft.com/ja-jp/azure/virtual-network/manage-route-table#create-a-route-table</a></p></blockquote><div class="alert is-success"><p class="alert-title">ヒント</p><p>※プロキシの設定を実施している場合は、/etc/yum.conf 内の “proxy=” のプロキシ設定がないかご確認ください。</p><p>  プロキシ設定があった場合、コメントアウト等で無効にしてください。</p></div><hr><h2 id="エラーの原因その-3-Azure-RHUI-への接続ができない-外部接続不可の構成"><a href="#エラーの原因その-3-Azure-RHUI-への接続ができない-外部接続不可の構成" class="headerlink" title="エラーの原因その 3 : Azure RHUI への接続ができない (外部接続不可の構成)"></a>エラーの原因その 3 : Azure RHUI への接続ができない (外部接続不可の構成)</h2><p>ご利用の環境によっては、Standard SKU の内部ロードバランサーのバックエンドにAzure VM を配置し、外部へのインターネット接続を制限している場合もあるかと思います。<br>外部接続不可の環境では、yum update を実施した際や、パッケージのインストール時にタイムアウトエラーが発生します。<br>Azure RHUI に接続するためには、NAT Gateway または VM にパブリック IP アドレスを関連付けいただくといった構成に変更する必要があります。</p><p>ご利用の VM が外部接続不可な構成であるかについての確認手順については、<br>以下の弊社ブログにもお纏めしておりますのでご参照ください。</p><blockquote><p>  □ 参考 : Azure VM の外部接続 (SNAT) オプション まとめ<br>   <a href="https://jpaztech.github.io/blog/network/snat-options-for-azure-vm/">https://jpaztech.github.io/blog/network/snat-options-for-azure-vm/</a></p></blockquote><div class="alert is-important"><p class="alert-title">重要</p><p>※内部ロードバランサーのバックエンドに VM がない場合でも、可用性セット内の VM が内部ロードバランサーのバックエンドに配置されている場合、</p><p>可用性セット内の VM は全て外部接続ができなくなり、RHUI に繋がらない事象が発生するのでご注意ください。可用性セットの構成変更等ご検討頂ければと思います。</p></div><hr><h2 id="エラーの原因その-4-クライアント証明書の期限切れ"><a href="#エラーの原因その-4-クライアント証明書の期限切れ" class="headerlink" title="エラーの原因その 4 : クライアント証明書の期限切れ"></a>エラーの原因その 4 : クライアント証明書の期限切れ</h2><p>古い RHEL VM イメージを利用している際には、 TLS/SSL クライアント証明書の期限が切れているために、<br>Azure RHUI に接続できない問題が発生することがあります。<br>クライアント証明書の期限が切れた際には、yum update を実施した際に下記のようなエラーが出力されることがあります。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@rhelvm ~]# yum update</span><br><span class="line">Loaded plugins: langpacks, product-id, search-disabled-repos</span><br><span class="line">rhui-microsoft-azure-rhel7-eus                                                                   | 2.1 kB  00:00:00</span><br><span class="line">https://rhui-1.microsoft.com/pulp/repos//content/dist/rhel/rhui/server/7/7Server/x86_64/dotnet/1/os/repodata/repomd.xml: [Errno 14] curl#58 - &quot;SSL peer rejected your certificate as expired.&quot;</span><br><span class="line">Trying other mirror.</span><br><span class="line">https://rhui-2.microsoft.com/pulp/repos//content/dist/rhel/rhui/server/7/7Server/x86_64/dotnet/1/os/repodata/repomd.xml: [Errno 14] curl#58 - &quot;SSL peer rejected your certificate as expired.&quot;</span><br><span class="line">Trying other mirror.</span><br><span class="line">https://rhui-3.microsoft.com/pulp/repos//content/dist/rhel/rhui/server/7/7Server/x86_64/dotnet/1/os/repodata/repomd.xml: [Errno 14] curl#58 - &quot;SSL peer rejected your certificate as expired.&quot;</span><br><span class="line">Trying other mirror.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@rhel82 ~]# yum update</span><br><span class="line">Red Hat Enterprise Linux 8 for x86_64 - BaseOS - Extended Update Support from RHUI (RPM 0.0  B/s |   0  B     00:02</span><br><span class="line">Errors during downloading metadata for repository &#x27;rhel-8-for-x86_64-baseos-eus-rhui-rpms&#x27;:</span><br><span class="line">  - Curl error (56): Failure when receiving data from the peer for https://rhui-3.microsoft.com/pulp/repos/content/eus/rhel8/rhui/8.2/x86_64/baseos/os/repodata/repomd.xml [OpenSSL SSL_read: error:14094415:SSL routines:ssl3_read_bytes:sslv3 alert certificate expired, errno 0]</span><br><span class="line">  - Curl error (56): Failure when receiving data from the peer for https://rhui-1.microsoft.com/pulp/repos/content/eus/rhel8/rhui/8.2/x86_64/baseos/os/repodata/repomd.xml [OpenSSL SSL_read: error:14094415:SSL routines:ssl3_read_bytes:sslv3 alert certificate expired, errno 0]</span><br><span class="line">  - Curl error (56): Failure when receiving data from the peer for https://rhui-2.microsoft.com/pulp/repos/content/eus/rhel8/rhui/8.2/x86_64/baseos/os/repodata/repomd.xml [OpenSSL SSL_read: error:14094415:SSL routines:ssl3_read_bytes:sslv3 alert certificate expired, errno 0]</span><br><span class="line">Error: Failed to download metadata for repo &#x27;rhel-8-for-x86_64-baseos-eus-rhui-rpms&#x27;: Cannot download repomd.xml: Cannot download repodata/repomd.xml: All mirrors were tried</span><br></pre></td></tr></table></figure><p>この場合の解決方法としては、下記コマンドを実施頂き、<br>クライアント証明書を更新頂くことで、Azure RHUI へのアクセスができるようになることが想定されます。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update -y --disablerepo=<span class="string">&#x27;*&#x27;</span> --enablerepo=<span class="string">&#x27;*microsoft*&#x27;</span></span><br></pre></td></tr></table></figure><p>※本コマンドは、rhui の rpm のみを更新するコマンドとなります。<br>本事象については、以下の公開ドキュメントにもお纏めしております。</p><blockquote><p>□ 参考 : Azure での RHUI 証明書の問題のトラブルシューティング<br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-linux-rhui-certificate-issues?tabs=rhel7-eus,rhel7-noneus,rhel7-rhel-sap-apps">https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-linux-rhui-certificate-issues?tabs=rhel7-eus%2Crhel7-noneus%2Crhel7-rhel-sap-apps</a></p></blockquote><div class="alert is-success"><p class="alert-title">ヒント</p><p>解消しない場合には、下記コマンドも併せてお試しください</p><p>#キャッシュデータの削除し、キャッシュの更新</p><p>sudo yum clean all</p><p>sudo yum makecache</p></div><hr><h2 id="補足情報"><a href="#補足情報" class="headerlink" title="補足情報"></a>補足情報</h2><p>今回ご紹介した方法でも、事象が解消しない場合には、<br>yum repolist all コマンドを実行頂き、有効なリポジトリをご確認頂ければと思います。</p><p>カスタムイメージや、ゴールドイメージの BYOS イメージをご利用されている場合には、<br>RHSM や サテライトに接続する必要があります。</p><blockquote><p>□ 参考 : Azure のオンデマンド Red Hat Enterprise Linux VM 用 Red Hat Update Infrastructure<br>   <a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/workloads/redhat/redhat-rhui">https://learn.microsoft.com/ja-jp/azure/virtual-machines/workloads/redhat/redhat-rhui</a></p></blockquote><p>本稿が皆様のお役に立てれば幸いです。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは！Azure テクニカル サポート チームの高橋です。&lt;br&gt;今回はよく、お問い合わせを頂く&lt;br&gt;Azure Marketplace から作成した Red Hat Enterprise Linux (RHEL) の仮想マシンにおいて&lt;br&gt;yum / dnf update やパッケージのインストールに失敗する場合の&lt;br&gt;よくある原因とその解決方法についてご紹介いたします。&lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Linux" scheme="https://jpaztech.github.io/blog/tags/Linux/"/>
    
    <category term="RHEL" scheme="https://jpaztech.github.io/blog/tags/RHEL/"/>
    
    <category term="RHUI" scheme="https://jpaztech.github.io/blog/tags/RHUI/"/>
    
  </entry>
  
  <entry>
    <title>Azure VM のシステムリソース高騰の原因調査について</title>
    <link href="https://jpaztech.github.io/blog/vm/vm-highusage/"/>
    <id>https://jpaztech.github.io/blog/vm/vm-highusage/</id>
    <published>2023-04-28T03:00:00.000Z</published>
    <updated>2023-08-18T00:59:11.778Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカルサポートの橋本です。</p><p>Azure VM の CPU 、メモリの使用率およびディスクビジー率が高騰し、原因調査のお問合せをいただくことがございます。<br>システムリソース高騰のトラブルシューティングでは事象発生中の OS のログが必要なことから、<br>事後対応による原因究明はほぼ不可能なため、発生中に OS にログインしてログを取得する、または事象発生に備えて定期的なログ取得設定を実施しておく必要があります。</p><p>本ブログ記事では、複数ございます公式ドキュメントのシステムリソース高騰のトラブルシューティングのご案内をお纏めしつつ、よくあるお問合せとトラブルシューティングの共通事項などを踏まえまして以下をご案内させていただきます。</p><span id="more"></span><p>　・Azure VM システムリソース高騰の一般的な要因<br>　・原因調査の流れ<br>　・問題のプロセスを追跡する</p><p>関連ドキュメント</p><blockquote><p>ご参考：Linux でのパフォーマンスのトラブルシューティングとボトルネックの分離<br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-performance-bottlenecks-linux">https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-performance-bottlenecks-linux</a></p></blockquote><blockquote><p>ご参考：Azure Windows 仮想マシンでの CPU 使用率の高い問題のトラブルシューティング<br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-high-cpu-issues-azure-windows-vm">https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-high-cpu-issues-azure-windows-vm</a></p></blockquote><blockquote><p>ご参考：Azure Windows 仮想マシンでのメモリの高い問題のトラブルシューティング<br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/azure-windows-vm-memory-issue">https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/azure-windows-vm-memory-issue</a></p></blockquote><hr><h2 id="■-Azure-VM-システムリソース高騰の一般的な要因"><a href="#■-Azure-VM-システムリソース高騰の一般的な要因" class="headerlink" title="■ Azure VM システムリソース高騰の一般的な要因"></a>■ Azure VM システムリソース高騰の一般的な要因</h2><p>システムリソース高騰要因の多くはご利用のアプリケーションのワークロードに依存したものとなり、<br>まれにご利用の OS 、アプリケーションのプログラムのエラー又はバグ等の不具合による原因もございます。<br>システムリソースを多く利用するプロセスを特定することがトラブルシューティングにおいて必須の作業となります。</p><p>プロセスが特定できましたら、アプリケーションログなどから、該当プロセスの観点から当時の接続数などの負荷状況を確認、<br>エラーなどによるリトライや処理滞留がリソースひっ迫を起こしていないか、<br>ご利用バージョンより既知不具合発生報告の事例確認等を行います。</p><p>なお、 Microsoft から提供されていない、 OS プロセス以外のサードパーティ製品や、<br>又はお客様作成の業務アプリケーションのプロセスが問題を引き起こしているケースですと、<br>プロセス機能の提供元へ原因調査をお願いさせていただいております。<br>これは、プロセスがなぜ多くのシステムリソースを利用しているか、<br>その妥当性については該当プロセス側の解析調査が必要となり、<br>弊社より  判断することができないためとなります。</p><blockquote><p>ご参考：Azure Windows 仮想マシンでの CPU 使用率の高い問題のトラブルシューティング - 一般的な要因<br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-high-cpu-issues-azure-windows-vm#common-factors">https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-high-cpu-issues-azure-windows-vm#common-factors</a></p></blockquote><hr><h2 id="■-原因調査の流れ"><a href="#■-原因調査の流れ" class="headerlink" title="■ 原因調査の流れ"></a>■ 原因調査の流れ</h2><p>お客様環境の Azure VM は監視ソフトウェアや Azure のメトリックのアラート設定によって<br>OS レベルのリソース状況を監視しているかと思います。<br>しかしながら、OS 上のプロセスレベルでのシステムリソース利用状況は Azure メトリックではログ取得できず、<br>監視ソフトウェアなどでもプロセスレベルの情報を取得しているケースはそれほど多くないと思います。</p><p>プロセスレベルでのシステムリソースの利用状況を別途取得しておりませんと、<br>事後に問題のプロセスを特定することがほぼ不可能となります。<br>この点を踏まえまして、一般的に Azure VM のシステムリソース高騰の原因調査は以下のような流れとなります。</p><p>  <strong>(1) 事前のログ取得設定</strong><br>  <strong>(2) システムリソース高騰が発生</strong><br>  <strong>(3) (1) で取得設定していたログを回収し、稼働プロセス毎のリソース使用状況を解析</strong><br>  <strong>(4) 特定したプロセスの観点から原因を究明</strong></p><hr><h2 id="■-問題のプロセスを追跡する"><a href="#■-問題のプロセスを追跡する" class="headerlink" title="■ 問題のプロセスを追跡する"></a>■ 問題のプロセスを追跡する</h2><p>ご利用の OS によって問題となっているプロセスの追跡に利用するツールが異なりますため、<br>Windows 、 Linux それぞれのシナリオ毎に記載させていただきます。</p><h4 id="【Windows-環境で問題のプロセスを追跡する】"><a href="#【Windows-環境で問題のプロセスを追跡する】" class="headerlink" title="【Windows 環境で問題のプロセスを追跡する】"></a>【Windows 環境で問題のプロセスを追跡する】</h4><p>Windows 環境では、標準機能のパフォーマンスモニターを利用してプロセスレベルの情報を含む、<br>各システムリソースの利用状況を取得することが可能となります。<br>パフォーマンスモニターでのログ収集方法と、問題プロセスを追跡する方法についてはこちらの記事をご参照ください。</p><blockquote><p>ご参考：パフォーマンス ログ収集<br><a href="https://jpwinsup.github.io/blog/2021/06/07/Performance/SystemResource/PerformanceLogging/">https://jpwinsup.github.io/blog/2021/06/07/Performance/SystemResource/PerformanceLogging/</a></p></blockquote><blockquote><p>ご参考：Azure Windows 仮想マシンでの CPU 使用率の高い問題のトラブルシューティング - プロセスを特定する<br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-high-cpu-issues-azure-windows-vm#identify-the-process">https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-high-cpu-issues-azure-windows-vm#identify-the-process</a></p></blockquote><h4 id="【Linux-環境で問題のプロセスを追跡する】"><a href="#【Linux-環境で問題のプロセスを追跡する】" class="headerlink" title="【Linux 環境で問題のプロセスを追跡する】"></a>【Linux 環境で問題のプロセスを追跡する】</h4><p>Linux 環境では、プロセスレベルのリソース利用状況を確認するコマンドはありますが、<br>Windows のパフォーマンスモニターのようにスケジュール機能などが組み込まれたものがございません。</p><p>このため、 cron などの機能と組み合わせてコマンドでプロセス利用状況を定期的に取得する形となりますが、<br>公式ドキュメントには ps や top コマンドの説明のみでしたので、cron と合わせてご利用する際のサンプルを<br>以下にご用意させていただきます。</p><p>なお、記事内のサンプルスクリプトは、Microsoft の標準サポートプログラムまたはサービスではサポートされません。<br>サンプル スクリプトは現状有姿で提供され、いかなる保証も行いません。<br>この点についてはご了承のうえでご利用をお願いいたします。</p><p><strong>————————————————————————-</strong><br><strong>統計情報の取得</strong><br><strong>————————————————————————-</strong><br>プロセス毎のシステムリソース利用状況について事象発生前後の傾向を確認するため<br>cron にてプロセス情報の確認コマンドを定期実行します。</p><ul><li>ログ出力先ディレクトリの名前は以下を想定しています。<br>/var/osperf<br>こちらは空き容量の十分にある任意のディレクトリに変更いただいて問題ございません。<br>出力ログのサイズは環境に依存いたしますが検証環境では 1 回あたり 60 KB 程度でございました。</li></ul><ol><li><p>root ユーザにスイッチします。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su -</span><br></pre></td></tr></table></figure></li><li><p>ログ取得のスクリプトを作成します</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/osperf</span><br><span class="line">touch /var/osperf/osperf.sh</span><br><span class="line">chmod 700 /var/osperf/osperf.sh</span><br><span class="line">vi /var/osperf/osperf.sh</span><br><span class="line">===</span><br><span class="line">date &gt;&gt; /var/osperf/`date +%y%m%d`.free.out ; /usr/bin/free &gt;&gt; /var/osperf/`date +%y%m%d`.free.out</span><br><span class="line">date &gt;&gt; /var/osperf/`date +%y%m%d`.meminfo.out ; /usr/bin/cat /proc/meminfo &gt;&gt; /var/osperf/`date +%y%m%d`.meminfo.out</span><br><span class="line">date &gt;&gt; /var/osperf/`date +%y%m%d`.slabtop.out ; /usr/bin/slabtop -o &gt;&gt; /var/osperf/`date +%y%m%d`.slabtop.out</span><br><span class="line">date &gt;&gt; /var/osperf/`date +%y%m%d`.psaux.out ; /usr/bin/ps aux --sort -rss &gt;&gt; /var/osperf/`date +%y%m%d`.psaux.out</span><br><span class="line">date &gt;&gt; /var/osperf/`date +%y%m%d`.top.out ; /usr/bin/top -b -n 1 &gt;&gt; /var/osperf/`date +%y%m%d`.top.out</span><br><span class="line">===</span><br><span class="line">※osperf.sh ファイルにこちらの五行を記載</span><br></pre></td></tr></table></figure></li><li><p>root 権限で以下コマンドより root ユーザの crontab を修正します</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">crontab -e -u root</span><br><span class="line">===</span><br><span class="line">*/10 * * * * sh /var/osperf/osperf.sh</span><br><span class="line">===</span><br><span class="line">※こちら、10 分毎に一度実行される形としております。</span><br></pre></td></tr></table></figure></li><li><p>システムリソースの高騰の事象が再現しましたら<br>/var/osperf ディレクトリの情報の取得をお願いいたします。</p></li></ol><p>今回ご案内させていただきました内容が、皆様のお役に立てますと幸いでございます。</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカルサポートの橋本です。&lt;/p&gt;
&lt;p&gt;Azure VM の CPU 、メモリの使用率およびディスクビジー率が高騰し、原因調査のお問合せをいただくことがございます。&lt;br&gt;システムリソース高騰のトラブルシューティングでは事象発生中の OS のログが必要なことから、&lt;br&gt;事後対応による原因究明はほぼ不可能なため、発生中に OS にログインしてログを取得する、または事象発生に備えて定期的なログ取得設定を実施しておく必要があります。&lt;/p&gt;
&lt;p&gt;本ブログ記事では、複数ございます公式ドキュメントのシステムリソース高騰のトラブルシューティングのご案内をお纏めしつつ、よくあるお問合せとトラブルシューティングの共通事項などを踏まえまして以下をご案内させていただきます。&lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="CPU" scheme="https://jpaztech.github.io/blog/tags/CPU/"/>
    
    <category term="Memory" scheme="https://jpaztech.github.io/blog/tags/Memory/"/>
    
  </entry>
  
  <entry>
    <title>サービス エンドポイントとプライベート エンドポイントの違い</title>
    <link href="https://jpaztech.github.io/blog/network/pe-difference-se/"/>
    <id>https://jpaztech.github.io/blog/network/pe-difference-se/</id>
    <published>2023-04-21T03:00:00.000Z</published>
    <updated>2023-08-18T00:59:11.326Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの箕輪です。</p><p>今回はお問い合わせを多くいただくサービス エンドポイントとプライベート エンドポイントの違いについてご紹介します。</p><span id="more"></span><h2 id="機能の違いについて"><a href="#機能の違いについて" class="headerlink" title="機能の違いについて"></a>機能の違いについて</h2><p>サービス エンドポイントとプライベートエンドポイントを端的に紹介すると、サービス エンドポイントは「Azure PaaS のパブリック IP アドレスに対する接続を最適化する」機能であり、プライベート エンドポイントは「プライベート IP アドレスで Azure PaaS に接続する」機能です。<br>サービス エンドポイントとプライベート エンドポイントの機能差分については下記の通りです。</p><table><thead><tr><th align="center"></th><th align="left">サービス エンドポイント (SE)</th><th align="left">プライベート エンドポイント (PE)</th></tr></thead><tbody><tr><td align="center">接続対象のリソース</td><td align="left">Azure PaaS</td><td align="left">Azure PaaS と PLS (*1)</td></tr><tr><td align="center">構成方法</td><td align="left">サブネット単位で有効化</td><td align="left">PE リソースの構成</td></tr><tr><td align="center">利用可能な送信元リソース</td><td align="left">SE を有効化したサブネット上のリソース</td><td align="left">PE に IP 疎通性があるリソース</td></tr><tr><td align="center">接続先の IP アドレス</td><td align="left">Azure PaaS のパブリック IP アドレス</td><td align="left">PE のプライベート IP アドレス</td></tr><tr><td align="center">接続制限</td><td align="left">Azure PaaS の設定でサブネット単位の指定 (*2)</td><td align="left">PE のサブネットの NSG で指定 (*3)</td></tr><tr><td align="center">接続元の IP アドレス(*4)</td><td align="left">サブネット上のリソースのプライベート IP アドレス</td><td align="left">PE に接続するリソースの IP アドレス</td></tr></tbody></table><p>※ 上記の表にあるサブネットは、Azure の仮想ネットワーク上のサブネットを指します。</p><p>(*1)PLS は <a href="https://learn.microsoft.com/ja-jp/azure/private-link/private-link-service-overview">Private Link Service</a> を指す。Azure 内部ロードバランサーに対して関連付けする機能。<br><br>(*2)接続制限の設定については、接続先の Azure PaaS に依存する。<br><br>(*3)PE が構成された VNet のサブネット上における<a href="https://learn.microsoft.com/ja-jp/azure/private-link/disable-private-endpoint-network-policy?tabs=network-policy-portal">ネットワーク ポリシー設定</a>が必要。<br><br>(*4)接続先の Azure PaaS によって出力されるログの形態によって異なります。</p><h2 id="接続構成について"><a href="#接続構成について" class="headerlink" title="接続構成について"></a>接続構成について</h2><p>サービス エンドポイントとプライベート エンドポイントは、Azure PaaS に対する接続を提供する機能であり、どちらのエンドポイントを利用するかは接続元のリソース (クライアント) の動作に依存します。<br>今回は Storage Account の Azure Blob (contoso.blob.windows.net) に対して接続する構成における、3 つのシナリオにおける接続イメージについてご紹介します。</p><p><br><u><strong>シナリオ 1 : サービス エンドポイントとプライベート エンドポイントが構成されていない</strong></u><br><br>この構成では、仮想マシンから Blob に対して、インターネット経由で接続します。<br>接続元のクライアントは、接続先の FQDN に対して名前解決の結果として Azure Blob のパブリック IP アドレスが応答されます。<br>接続元のクライアントは、Azure Blob のパブリック IP アドレスに対して、Azure の既定の経路 (0.0.0.0/0) に従って、インターネット経由で接続します。</p><p>下記の図は説明の便宜上インターネットに接続している構成図としていますが、<a href="https://learn.microsoft.com/ja-jp/azure/networking/microsoft-global-network">Azure の仮想マシンから Azure PaaS へ接続は Microsoft バックボーン ネットワークを経由して接続する</a>ため、実際の通信はパブリック インターネットを経由しません。</p><p><img src="/blog/network/pe-difference-se/01.png"><br><br></p><p><br><u><strong>シナリオ 2 : サービス エンドポイントを有効化</strong></u><br><br>この構成では、仮想マシンから Blob に対して、サービス エンドポイントを介して接続します。<br>接続元のクライアントは、接続先の FQDN に対して名前解決の結果として Azure Blob のパブリック IP アドレスが応答されます。<br>接続元のクライアントは、Azure Blob のパブリック IP アドレスに対して、サービス エンドポイントで追加された内部経路情報 (VirtualNetworkServiceEndpoint) に従って、Azure 内部で最適化された経路で接続します。<br>この時の接続経路は、Microsoft バックボーン ネットワーク内で完結します。</p><p><img src="/blog/network/pe-difference-se/02a.png"><br><br></p><p><br><u><strong>シナリオ 3 : プライベート エンドポイントを有効化</strong></u><br><br>この構成では、仮想マシンから Azure Blob に対して、プライベート エンドポイントを介して接続します。<br>接続元のクライアントは、接続先の FQDN に対して名前解決の結果として Blob 接続用のプライベート エンドポイントの IP アドレス (プライベート IP アドレス) が応答されます。<br>接続元のクライアントは、プライベート エンドポイントの IP アドレスに対して Blob に接続します。</p><p>なお、下記の図では便宜上、簡略していますが、プライベート DNS ゾーンを利用している構成を前提としています。</p><p><img src="/blog/network/pe-difference-se/03.png"><br><br></p><h2 id="使い分けについて"><a href="#使い分けについて" class="headerlink" title="使い分けについて"></a>使い分けについて</h2><p>上記の通り、サービス エンドポイントとプライベート エンドポイントでは、接続元のクライアントからの接続先 IP アドレスが異なるため、DNS 構成により使い分けが可能です。<br>つまり、サービス エンドポイントとプライベート エンドポイントを同時に構成することは可能で、接続先 IP アドレスを DNS レイヤーで切り替えることで接続を切り替えます。<br>サービス エンドポイントとプライベート エンドポイントの使い分けの一例としては、下記の点をご参考にしていただければ幸いです。</p><p>サービス エンドポイントは対象の仮想ネットワークのサブネットに対してのみ適用可能な機能となるため、ExpressRoute や VPN で接続されたオンプレミスのリソースはサービス エンドポイントを利用できません。しかし、強制トンネリング構成において特定の Azure PaaS に対してのパブリック エンドポイントへのアクセスを構成できることや、Azure PaaS 側でサービス エンドポイントを有効化した仮想ネットワーク上のサブネットからの接続に制限できること、これらの機能が追加費用なくご利用いただくことが特徴として挙げられます。</p><p>プライベートエンドポイントでは、プライベート エンドポイントのプライベート IP アドレスに接続性があれば利用可能なため、ExpressRoute や VPN で接続されたオンプレミスのリソースから Azure PaaS に接続するシナリオでご利用いただくことが可能です。なお、サービス エンドポイントとは異なり、<a href="https://azure.microsoft.com/ja-jp/pricing/details/private-link/">プライベート エンドポイントは費用が発生する点</a>にはご留意ください。</p><h2 id="公開情報について"><a href="#公開情報について" class="headerlink" title="公開情報について"></a>公開情報について</h2><p>サービス エンドポイントとプライベート エンドポイントの概要や、構成の手順などについては下記の公開情報に記載がございますので併せてご確認ください。</p><p>仮想ネットワーク サービス エンドポイント<br><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/virtual-network-service-endpoints-overview">https://learn.microsoft.com/ja-jp/azure/virtual-network/virtual-network-service-endpoints-overview</a></p><p>Azure Private Link とは<br><br><a href="https://learn.microsoft.com/ja-jp/azure/private-link/private-link-overview?toc=/azure/virtual-network/toc.json">https://learn.microsoft.com/ja-jp/azure/private-link/private-link-overview?toc=%2Fazure%2Fvirtual-network%2Ftoc.json</a></p><p>クイックスタート: Azure portal を使用してプライベート エンドポイントを作成する<br><br><a href="https://learn.microsoft.com/ja-jp/azure/private-link/create-private-endpoint-portal?tabs=dynamic-ip">https://learn.microsoft.com/ja-jp/azure/private-link/create-private-endpoint-portal?tabs=dynamic-ip</a></p><h2 id="よくいただくご質問"><a href="#よくいただくご質問" class="headerlink" title="よくいただくご質問"></a>よくいただくご質問</h2><p><strong>・プライベート エンドポイントに対してプライベート IP アドレスでアクセスしても接続できません</strong></p><p>Azure PaaS はホスト名を用いて通信を識別しています。プライベート エンドポイントは Azure PaaS への接続経路を提供する機能のみであり、実際のリクエストにはホスト名を含めた FQDN が必要です。</p><p><strong>・サービス エンドポイントとプライベート エンドポイントのどちらを選択しているかわかりません</strong></p><p>Azure の機能では明確に確認することはできませんが、接続元のクライアント上で、対象の FQDN に対する名前解決を実行し、パブリック IP アドレスが応答されればサービス エンドポイント、プライベート IP アドレスが応答されればプライベート エンドポイント経由で接続していると判断できます。</p><p><strong>・Azure PaaS から仮想ネットワークへの接続にサービス エンドポイントやプライベート エンドポイントは使えますか</strong></p><p>いいえ、ご利用いただけません。サービス エンドポイントとプライベート エンドポイントは、仮想ネットワークから Azure PaaS への接続時に利用可能なサービスです。Azure PaaS から仮想ネットワークの接続については、各サービスによって機能の有無がありますが、VNet 統合等の機能で利用できます。</p><p>以上、ご参考になれば幸いです。</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの箕輪です。&lt;/p&gt;
&lt;p&gt;今回はお問い合わせを多くいただくサービス エンドポイントとプライベート エンドポイントの違いについてご紹介します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Network" scheme="https://jpaztech.github.io/blog/tags/Network/"/>
    
    <category term="Private Endpoint" scheme="https://jpaztech.github.io/blog/tags/Private-Endpoint/"/>
    
    <category term="Service Endpoint" scheme="https://jpaztech.github.io/blog/tags/Service-Endpoint/"/>
    
  </entry>
  
  <entry>
    <title>Firewall からインターネットに SNAT して通信する時のパブリック IP の使われ方</title>
    <link href="https://jpaztech.github.io/blog/network/fw-snat/"/>
    <id>https://jpaztech.github.io/blog/network/fw-snat/</id>
    <published>2023-04-16T05:30:00.000Z</published>
    <updated>2023-08-18T00:59:11.326Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの薄井です。<br>今回は Azure Firewall に関連付けたパブリック IP の SNAT 時の使われ方について紹介します。</p><span id="more"></span><h2 id="Azure-Firewall-のパブリック-IP-による-SNAT-について"><a href="#Azure-Firewall-のパブリック-IP-による-SNAT-について" class="headerlink" title="Azure Firewall のパブリック IP による SNAT について"></a>Azure Firewall のパブリック IP による SNAT について</h2><p>Azure Firewall を経由してインターネット宛に通信するときは、関連付けられているパブリック IP へ送信元のアドレス変換（SNAT）が行われます。パブリック IP が 1 つしかない時はそのパブリック IP のアドレスしか使用されませんが、複数のパブリック IP アドレスが Azure Firewall に関連付けられている場合の動作について、以下のドキュメントではランダムに選択する旨の記載がございます。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/firewall/deploy-multi-public-ip-powershell">Azure PowerShell を使用して複数のパブリック IP アドレスを使用する Azure Firewall をデプロイする</a></p><blockquote><p>SNAT -送信 SNAT 接続に追加のポートを使用できるので、SNAT ポートが不足する可能性が低減されます。 Azure Firewall では、<em><strong>接続に使用する送信元パブリック IP アドレスがランダムに選択されます。</strong></em> ネットワークにダウンストリーム フィルターがある場合、ファイアウォールに関連付けられているすべてのパブリック IP アドレスを許可する必要があります。 この構成を簡略化するには、パブリック IP アドレス プレフィックスを使用することを検討してください。</p></blockquote><p>この記載は通信ごとにランダムにパブリック IP が使用される、つまり確率的に関連付けられている全てのパブリック IP が均等に使用されるかのように読み取れますが、<strong>実際のパブリック IP の使われ方は、基本的にプライマリのパブリック IP から使用されることが多く、そのパブリック IP が継続して使用される傾向があります。つまり、全てのパブリック IP が均等に使用されるようなふるまいではありません。</strong></p><p>通信先への送信元 IP アドレスを分散させたい場合には NAT ゲートウェイが必要となります。</p><h2 id="NAT-ゲートウェイ-による-SNAT-について"><a href="#NAT-ゲートウェイ-による-SNAT-について" class="headerlink" title="NAT ゲートウェイ による SNAT について"></a>NAT ゲートウェイ による SNAT について</h2><p>Azure Firewall Subnet に NAT ゲートウェイを関連付けることにより、Azure Firewall のパブリック IP ではなく、NAT ゲートウェイで SNAT を行うことができるようになります。NAT ゲートウェイによる SNAT では関連付けられているパブリック IP がランダムかつほぼ均等に使用されます。<br>注意点として、NAT ゲートウェイはゾーン冗長をサポートしていないため、利用する場合は Azure Firewall をゾーン冗長しないようにデプロイする必要があります。<br>Azure Firewall と NAT ゲートウェイを組み合わせて使用する方法については以下のドキュメントをご参照ください。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/firewall/integrate-with-nat-gateway">Azure Virtual Network NAT を使用した SNAT ポートのスケーリング | Microsoft Learn</a></p><p><a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/nat-gateway/tutorial-hub-spoke-nat-firewall">チュートリアル： ハブ アンド スポーク ネットワークで NAT ゲートウェイと Azure Firewall を統合する - Azure Virtual Network NAT | Microsoft Learn</a></p><h2 id="Azure-Firewall-と-NAT-Gateway-の比較表"><a href="#Azure-Firewall-と-NAT-Gateway-の比較表" class="headerlink" title="Azure Firewall と NAT Gateway の比較表"></a>Azure Firewall と NAT Gateway の比較表</h2><p>以下の表は Azure Firewall のパブリック IP による SNAT と NAT Gateway の機能比較表です。</p><table><thead><tr><th align="left">機能</th><th align="center">Firewall のパブリック IP</th><th align="center">NAT ゲートウェイ</th></tr></thead><tbody><tr><td align="left">SNAT ポート数（パブリック IP 1 つにつき）</td><td align="center">2,496 * FW 内部インスタンス数 ※1</td><td align="center">64,512</td></tr><tr><td align="left">関連付けられる パブリック IP の数</td><td align="center">250</td><td align="center">16</td></tr><tr><td align="left">パブリック IP が使用される順番</td><td align="center">基本的にプライマリから使用され、ポートが枯渇すると次が使用される</td><td align="center">ランダムかつほぼ均等に使用される</td></tr><tr><td align="left">ゾーン冗長のサポート</td><td align="center">○</td><td align="center">×</td></tr><tr><td align="left">価格</td><td align="center">FW と FW のパブリック IP の価格</td><td align="center">FW と FW のパブリック IP, NAT ゲートウェイと NAT ゲートウェイ のパブリック IP の価格</td></tr></tbody></table><p>※1 Azure Firewall の内部インスタンス数は最低 2 となり、負荷に応じてスケールアウトします。</p><p>以上、ご参考になれば幸いです。</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの薄井です。&lt;br&gt;今回は Azure Firewall に関連付けたパブリック IP の SNAT 時の使われ方について紹介します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Network" scheme="https://jpaztech.github.io/blog/tags/Network/"/>
    
    <category term="Public IP Address" scheme="https://jpaztech.github.io/blog/tags/Public-IP-Address/"/>
    
    <category term="Azure Firewall" scheme="https://jpaztech.github.io/blog/tags/Azure-Firewall/"/>
    
    <category term="NAT Gateway" scheme="https://jpaztech.github.io/blog/tags/NAT-Gateway/"/>
    
  </entry>
  
  <entry>
    <title>Azure VM の CPU コア数 / CPU の種類 / ターボブーストについての解説</title>
    <link href="https://jpaztech.github.io/blog/vm/azure-vm-cpu-htt-turbo/"/>
    <id>https://jpaztech.github.io/blog/vm/azure-vm-cpu-htt-turbo/</id>
    <published>2023-04-11T08:30:00.000Z</published>
    <updated>2023-08-18T00:59:11.430Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの富田です。<br>今回はお問い合わせいただくことの多い Azure VM の CPU に関する以下の点を解説させていただきます。  </p><ul><li>CPU の vCPU 数 / 物理コア数 / 論理スレッド数について</li><li>制約付き vCPU 対応の VM サイズについて</li><li>CPU の種類について</li><li>ターボブースト機能について</li></ul><p>まず Azure VM ではそのスペックについて VM サイズとして、<br>搭載 CPU / vCPU 数 / メモリの量 / ディスクやネットワークの帯域などの組み合わせより選んでいただくこととなります。<br>各 VM サイズの情報については、以下の資料をご参照いただけますと幸いでございます。  </p><blockquote><p>■ご参考：Azure の仮想マシンのサイズ<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/sizes">https://learn.microsoft.com/ja-jp/azure/virtual-machines/sizes</a></p></blockquote><hr><h2 id="CPU-の-vCPU-数-物理コア数-論理スレッド数について"><a href="#CPU-の-vCPU-数-物理コア数-論理スレッド数について" class="headerlink" title="CPU の vCPU 数 / 物理コア数 / 論理スレッド数について"></a>CPU の vCPU 数 / 物理コア数 / 論理スレッド数について</h2><p>ソフトウェア ライセンスの観点等により、Azure VM における vCPU 数 / 物理コア数 / 論理スレッド数についてお問い合わせをいただくことがございます。  </p><p>Azure VM では VM サイズとして vCPU 数をお客様に選んでいただくことになります。<br>では、8 vCPU の VM サイズを選んだ として、「4 物理コア / 8 論理スレッド」なのか、「8 物理コア / 8 論理スレッド」なのかという点が気になりますね。  </p><p>1 つの物理コアを 2 論理スレッドとして扱う技術として、  </p><ul><li>Intel ハイパースレッディング テクノロジ</li><li>AMD 同時実行マルチスレッド技術</li></ul><p>といった技術がございます。<br> ※ 以下「ハイパースレッド / マルチスレッド化」と記載させていたせていただきます。  </p><p>そのため、8 vCPU の VM サイズ については、  </p><ul><li>ハイパースレッド / マルチスレッド化されている VM サイズの場合は「4 物理コア / 8 論理スレッド」</li><li>ハイパースレッド / マルチスレッド化されて<strong>いない</strong> VM サイズの場合は「8 物理コア / 8 論理スレッド」</li></ul><p>となります。  </p><p>どの VM サイズがハイパースレッド / マルチスレッド化されているのかといった点は、<br>以下の Azure コンピューティング ユニット (ACU) のドキュメントより確認可能です。<br>「vCPU: コア」の表記が「2:1***」「2:1****」になっているものは、<br>ハイパースレッド / マルチスレッド化されており、1 つの物理コアを 2 論理スレッドとして扱われております。  </p><blockquote><p>■ご参考：Azure コンピューティング ユニット (ACU)<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/acu">https://learn.microsoft.com/ja-jp/azure/virtual-machines/acu</a></p></blockquote><blockquote><p>ーーーーーー抜粋ーーーーーー<br>*** ハイパースレッド化されており、入れ子になった仮想化を実行できます。<br>****AMD 同時実行マルチスレッド技術<br>ーーーーーーーーーーーーーー  </p></blockquote><p>なお、ACU に表記のない VM サイズにつきましては、各 VM サイズにおけるドキュメント等にハイパースレッド / マルチスレッド化されているかという旨が記載されておりますので、それらをご確認いただけますと幸いです。  </p><blockquote><p>■ ハイパースレッド化が有効である場合の表記の例（Dv5 および Dsv5 シリーズ）<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/dv5-dsv5-series">https://learn.microsoft.com/ja-jp/azure/virtual-machines/dv5-dsv5-series</a>  </p></blockquote><blockquote><p>ーーーーーー抜粋ーーーーーー<br>Dv5 および Dsv5 シリーズの仮想マシンは、<strong>ハイパースレッド構成の</strong>第 3 世代 Intel® Xeon® Platinum 8370C (Ice Lake) プロセッサ上で実行されます。<br>ーーーーーーーーーーーーーー</p></blockquote><blockquote><p>■ マルチスレッド化が有効である場合の表記の例（Dasv5 および Dadsv5 シリーズ）<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/dv5-dsv5-series">https://learn.microsoft.com/ja-jp/azure/virtual-machines/dv5-dsv5-series</a>  </p></blockquote><blockquote><p>ーーーーーー抜粋ーーーーーー<br>Dasv5 シリーズおよび Dadsv5 シリーズは、AMD の第 3 世代 EPYCTM 7763v プロセッサを、最大 256 MB の L3 キャッシュを備えた<strong>マルチスレッド構成で</strong>利用し、汎用ワークロードを実行するための顧客オプションを増やします。<br>ーーーーーーーーーーーーーー</p></blockquote><p>また、恐縮ながら物理ホスト サーバー 1 台に搭載された合計物理コア数やソケット数はお客様に公開が叶いません点ご理解賜りますと幸いでございます。  </p><div class="alert is-info"><p class="alert-title">Note</p><p>ソフトウェアについてはパブリック クラウド環境の場合はオンプレミスの物理サーバーと違ったライセンス ルールがある場合がございます。</p><p>「ライセンス上どのように CPU 数などをカウントするか？」「パブリッククラウドとオンプレミス環境でのライセンスの違いはあるか？」など、各ソフトウェア ライセンスの観点については、そのソフトウェア ライセンスを取り扱っている会社様にご確認をお願いいたします。  </p></div><hr><h2 id="制約付き-vCPU-対応の-VM-サイズについて"><a href="#制約付き-vCPU-対応の-VM-サイズについて" class="headerlink" title="制約付き vCPU 対応の VM サイズについて"></a>制約付き vCPU 対応の VM サイズについて</h2><p>ソフトウェアによっては vCPU の数によって、ライセンス料金が決定されるものがございます。<br>例えばその際に、  </p><blockquote><p>「メモリは 256 GB 欲しいので Standard_E32d_v5 サイズ（32 vCPU / 256 GB）が良さそうだけど、32 vCPU もあるとライセンス料金が高くなってしまう。」  </p></blockquote><p>ということがあるかと存じます。  </p><p>このようなご要望にお応えするため、Standard_E32d_v5 サイズ（32 vCPU / 256 GB）から、vCPU の数のみを減らした、<br>Standard_E32-8ds_v5 サイズ（8 vCPU / 256 GB）というサイズのご用意がございます。<br>このように vCPU 数のみを元の VM サイズから減らしているものを <strong>「制約付き vCPU 対応の VM サイズ」</strong> と定義しております。  </p><p>制約付き vCPU 対応の VM サイズには以下のような特徴がございます。  </p><ul><li>元の VM サイズから 1/2 または 1/4 に vCPU 数を減らしています。  </li><li>vCPU 数以外のスペック（メモリ容量・ディスクの仕様・NIC 数・ネットワーク帯域など）は元の VM サイズと同じ仕様です。  </li><li>全ての VM サイズに対し「制約付き vCPU 対応の VM サイズ」がご用意されているわけではございません。  </li><li>命名規則としては vCPU 数の部分が「元のvCPU数-実際のvCPU数」といった表記になっております。  </li></ul><p>制約付き vCPU 対応の VM サイズの一覧・仕様・価格などに関しては以下のドキュメントをご参照ください。  </p><blockquote><p>■ご参考：制約付き vCPU 対応の VM サイズ<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/constrained-vcpu">https://learn.microsoft.com/ja-jp/azure/virtual-machines/constrained-vcpu</a></p></blockquote><blockquote><p>■ご参考：Windows Virtual Machines の料金<br><a href="https://azure.microsoft.com/ja-jp/pricing/details/virtual-machines/windows/">https://azure.microsoft.com/ja-jp/pricing/details/virtual-machines/windows/</a></p></blockquote><hr><h2 id="CPU-の種類について"><a href="#CPU-の種類について" class="headerlink" title="CPU の種類について"></a>CPU の種類について</h2><p>同じ VM サイズでも物理ホスト サーバーに搭載された CPU の種類が異なるため、VM の実行される CPU の種類が変わるといったことがございます。<br>例えば、以下のように Dv4 および Dsv4 シリーズは、ブログ執筆の 2023 年 4 月時点では、以下 2 種類の CPU でご提供をさせていただいております。  </p><blockquote><p>■ご参考：Dv4 および Dsv4 シリーズ<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/dv4-dsv4-series">https://learn.microsoft.com/ja-jp/azure/virtual-machines/dv4-dsv4-series</a></p></blockquote><blockquote><p>ーーーーーー抜粋ーーーーーー<br>Dv4 および Dsv4 シリーズは、ハイパースレッド構成の第 3 世代 Intel® Xeon® Platinum 8370C (Ice Lake) プロセッサまたは Intel® Xeon® Platinum 8272CL (Cascade Lake) プロセッサ上で実行されます。<br>ーーーーーーーーーーーーーー</p></blockquote><p>そのため、ご利用者様から見ると、  </p><ul><li>VM を割り当て解除 / 起動したら CPU の種類が変わった。</li><li>同じ VM サイズの VM を何台が使っているが、それぞれ別の種類の CPU で実行されている。</li></ul><p> ということが発生します。  </p><p>また、「特定の CPU の種類を選んで使いたい。」といったご要望も頂くことがございます。<br>恐縮ながら、後述の Azure Dedicated Host を利用する場合の除き、特定の CPU の種類を選んでご使用いただくことは叶いません.。 </p><p>なお、異なる CPU の種類で実行された場合も大きな性能差が出ないよう、目安として以下の ACU の範囲内での性能差となるように設計されております。  </p><blockquote><p>■ご参考：Azure コンピューティング ユニット (ACU)<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/acu">https://learn.microsoft.com/ja-jp/azure/virtual-machines/acu</a></p></blockquote><div class="alert is-info"><p class="alert-title">Note</p><p>VM を割り当て解除および再デプロイしない場合は、原則 CPU の種類が変更されませんが、</p><p>予期せぬ物理ホストサーバーの不具合等で、別の CPU の種類の物理ホストサーバーに VM が移動される場合がございます。  </p></div><hr><h2 id="Azure-Dedicated-Host-で-CPU-の種類を選ぶ"><a href="#Azure-Dedicated-Host-で-CPU-の種類を選ぶ" class="headerlink" title="Azure Dedicated Host で CPU の種類を選ぶ"></a>Azure Dedicated Host で CPU の種類を選ぶ</h2><p>Azure Dedicated Host をご利用いただく場合に限り、CPU の種類を選ぶことが可能となります。<br>Azure Dedicated Host は物理ホストサーバー 1 台丸ごとをお客様に占有いただくサービスとなります。<br>物理ホストサーバーを選ぶ際に SKU として、VM ファミリと特定のハードウェア仕様の組み合わせを選択することとなり、この際にハードウェアに搭載される CPU の種類を選択することが可能です。  </p><p>例えば、Dsv4 シリーズを搭載できる Azure Dedicated Host SKU として、ブログ執筆の 2023 年 4 月時点では、以下の 2 種類があることが確認できます。  　</p><ul><li>Dsv4_Type1：Intel® Xeon® Platinum 8272CL (Cascade Lake)</li><li>Dsv4_Type2：Intel® Xeon® Platinum 8370C (Ice Lake) </li></ul><p>この占有されたホストサーバー上で稼働させれば、CPU が変更されることはないものとなります。<br>しかしながら、Azure Dedicated Host は物理ホストサーバー 1 台丸ごとをお客様に占有いただくため、通常の VM より高い利用料金が設定されております。<br>Azure Dedicated Host の概要や価格等については、以下の記事をご参照ください。  </p><blockquote><p>■ご参考：Azure 専用ホスト<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/dedicated-hosts">https://learn.microsoft.com/ja-jp/azure/virtual-machines/dedicated-hosts</a></p></blockquote><blockquote><p>■ご参考：Azure Dedicated Host の価格<br><a href="https://azure.microsoft.com/ja-jp/pricing/details/virtual-machines/dedicated-host/">https://azure.microsoft.com/ja-jp/pricing/details/virtual-machines/dedicated-host/</a></p></blockquote><blockquote><p>■ご参考：汎用 Azure Dedicated Host SKU<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/dedicated-host-general-purpose-skus">https://learn.microsoft.com/ja-jp/azure/virtual-machines/dedicated-host-general-purpose-skus</a></p></blockquote><hr><h2 id="ターボブースト機能について"><a href="#ターボブースト機能について" class="headerlink" title="ターボブースト機能について"></a>ターボブースト機能について</h2><p>一時的に CPU クロックを向上させる技術として、  </p><ul><li>Intel® Turbo テクノロジ</li><li>AMD® Boost テクノロジ</li></ul><p>といった技術がございます。<br> ※ 以下「ターボブースト機能」と記載させていたせていただきます。  </p><p>多くの VM サイズではこのターボブースト機能が有効となっております。<br>しかしながら、ターボブースト機能によって実際に CPU クロックが向上している際も、お客様のゲスト OS からは CPU クロックは固定で表示されます。<br>これは、物理ホストサーバー側にて制御が行われ、ゲスト OS は HW レジスタを直接参照できないためとなります。  </p><p>そのため恐れ入りますが、ターボブースト機能によってどの程度クロックが向上しているかについては、恐縮ながら確認が叶いません点ご理解賜りますと幸いです。<br>なお、ターボブースト機能は、あくまで余裕がある際にベースクロックよりパフォーマンスを向上させるものでございますので、ターボブースト機能が動作していない場合に性能が低下するものではなく、通常よりも性能が向上するといった機能でございます。  </p><blockquote><p>■ご参考：Azure コンピューティング ユニット (ACU)<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/acu">https://learn.microsoft.com/ja-jp/azure/virtual-machines/acu</a></p></blockquote><blockquote><p>ーーーーーー抜粋ーーーーーー<br>*ACU は、Intel® Turbo テクノロジを使用して CPU 周波数を上げ、パフォーマンスを向上させます。 パフォーマンス向上の量は、VM のサイズ、ワークロードのほか、同じホストで実行されている他のワークロードによって変動する場合があります。  </p><p>**ACU は、AMD® Boost テクノロジを使用して CPU 周波数を上げ、パフォーマンスを向上させます。 パフォーマンス向上の量は、VM のサイズ、ワークロードのほか、同じホストで実行されている他のワークロードによって変動する場合があります。<br>ーーーーーーーーーーーーーー  </p></blockquote><hr><p>以上の通り今回は Azure VM の CPU についてよくあるご質問の内容を解説させていただきました。<br>上記内容が皆様のお役に立てますと幸いでございます。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの富田です。&lt;br&gt;今回はお問い合わせいただくことの多い Azure VM の CPU に関する以下の点を解説させていただきます。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU の vCPU 数 / 物理コア数 / 論理スレッド数</summary>
      
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="Linux" scheme="https://jpaztech.github.io/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Azure から OS にコマンドを発行する実行コマンド (RunCommand) 拡張機能について解説</title>
    <link href="https://jpaztech.github.io/blog/vm/runcommand/"/>
    <id>https://jpaztech.github.io/blog/vm/runcommand/</id>
    <published>2023-03-30T04:00:00.000Z</published>
    <updated>2023-08-18T00:59:11.702Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポートチームの井上です。 </p><p>本記事では、Azure VM の拡張機能の一つである実行コマンド (RunCommand) について、<br>利用方法やアクション実行コマンドとマネージド実行コマンドの違い等を解説させていただきます。</p><span id="more"></span> <hr><h2 id="実行コマンドとは"><a href="#実行コマンドとは" class="headerlink" title="実行コマンドとは"></a>実行コマンドとは</h2><p>実行コマンドは、Azure VM の拡張機能の一つで、仮想マシン エージェントを使用して、<br>Windows または Linux の Azure VM 内でコマンドやスクリプトをリモートで実行することができる機能です。<br>特定のコマンドだけでなく、Windows の場合は PowerShell スクリプト、Linux の場合はシェル スクリプトで、<br>任意のカスタム スクリプトを指定して実行することが可能です。</p><p>例えば、接続不調となった VM に対して、疎通の状態等を確認するコマンドをリモートで実行するといったことや、<br>複数の VM に対してメンテナンス用のスクリプトを実行するといった用途にご活用いただけます。</p><blockquote><p><em><strong>実行コマンドを使用してお使いの VM でスクリプトを実行する</strong></em><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/run-command-overview">https://learn.microsoft.com/ja-jp/azure/virtual-machines/run-command-overview</a></p></blockquote><hr><h2 id="アクション実行コマンドとマネージド実行コマンド"><a href="#アクション実行コマンドとマネージド実行コマンド" class="headerlink" title="アクション実行コマンドとマネージド実行コマンド"></a>アクション実行コマンドとマネージド実行コマンド</h2><p>実行コマンドには、現在、アクション実行コマンドとマネージド実行コマンドの 2 種類があります。<br>マネージド実行コマンドは、2023 年 2 月に General Availability (GA) となっており、<br>アクション実行コマンドと比較し、以下の観点で機能が強化されています。<br>今後、実行コマンドの利用を予定されている場合は、まずはマネージド実行コマンドをご利用いただくことをご検討ください。</p><ul><li>ARM デプロイ テンプレートを介して更新された実行コマンドをサポート</li><li>複数のスクリプトの並列実行</li><li>スクリプトの順次実行</li><li>ユーザーが指定したスクリプトのタイムアウト</li><li>実行時間が長い (時間または日単位) のスクリプトをサポート</li><li>安全な方法でシークレット (パラメーター、パスワード) を渡す</li></ul><blockquote><p><em><strong>General Availability: Managed Run Command – Execute PowerShell or shell scripts on Virtual Machines and Scale Sets</strong></em><br><a href="https://azure.microsoft.com/en-us/updates/general-availability-run-command-execute-powershell-or-shell-scripts-on-virtual-machines-and-scale-sets/">https://azure.microsoft.com/en-us/updates/general-availability-run-command-execute-powershell-or-shell-scripts-on-virtual-machines-and-scale-sets/</a></p></blockquote><blockquote><p><em><strong>実行コマンドを使用してお使いの VM でスクリプトを実行する</strong></em><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/run-command-overview#compare-feature-support">https://learn.microsoft.com/ja-jp/azure/virtual-machines/run-command-overview#compare-feature-support</a></p></blockquote><div class="alert is-info"><p class="alert-title">Note</p><p>マネージド実行コマンドは、2023 年 3 月現在、Azure CLI、Azure PowerShell、REST API で使用できます。</p></div><p>基本的な利用方法につきましては、こちらの公開ドキュメントも併せてご確認ください。</p><blockquote><p><em><strong>実行コマンド アクションを使用して Linux VM でスクリプトを実行する</strong></em><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/run-command">https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/run-command</a></p><p><em><strong>アクション実行コマンドを使用して、Windows VM でスクリプトを実行する</strong></em><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command">https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command</a></p><p><em><strong>マネージド実行コマンドを使用して Linux VM でスクリプトを実行する</strong></em><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/run-command-managed">https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/run-command-managed</a></p><p><em><strong>マネージド実行コマンドを使用して Windows VM でスクリプトを実行する</strong></em><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed">https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed</a></p></blockquote><hr><h2 id="実行コマンドをデプロイする"><a href="#実行コマンドをデプロイする" class="headerlink" title="実行コマンドをデプロイする"></a>実行コマンドをデプロイする</h2><h3 id="仮想マシンで実行する"><a href="#仮想マシンで実行する" class="headerlink" title="仮想マシンで実行する"></a>仮想マシンで実行する</h3><p>マネージド実行コマンドとアクション実行コマンドでは、Azure PowerShell/CLI のコマンドに違いがあり、<br>それぞれのコマンドをご利用いただくことで使い分けることができます。<br>仮想マシンで実行コマンドを利用する際のコマンドについては、こちらの比較表をご参照ください。</p><h4 id="Azure-PowerShell"><a href="#Azure-PowerShell" class="headerlink" title="Azure PowerShell"></a>Azure PowerShell</h4><table><thead><tr><th align="left">操作</th><th align="left">アクション実行コマンド</th><th align="left">マネージド実行コマンド</th></tr></thead><tbody><tr><td align="left">実行<br>作成・更新 ※1</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command#powershell"><strong>Invoke</strong>-AzVMRunCommand</a> ※2</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#execute-a-script-with-the-vm-1"><strong>Set</strong>-AzVMRunCommand</a></td></tr><tr><td align="left">削除</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command#action-run-command-removal"><strong>Invoke</strong>-AzVMRunCommand</a> ※2</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#delete-runcommand-resource-from-the-vm-1"><strong>Remove</strong>-AzVMRunCommand</a></td></tr><tr><td align="left">一覧表示 ※1</td><td align="left">-</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#list-all-deployed-runcommand-resources-on-a-vm-1"><strong>Get</strong>-AzVMRunCommand</a> ※2</td></tr><tr><td align="left">実行状態と結果の取得 ※1</td><td align="left">-</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#get-execution-status-and-results-1"><strong>Get</strong>-AzVMRunCommand</a> ※2</td></tr></tbody></table><h4 id="Azure-CLI"><a href="#Azure-CLI" class="headerlink" title="Azure CLI"></a>Azure CLI</h4><table><thead><tr><th align="left">操作</th><th align="left">アクション実行コマンド</th><th align="left">マネージド実行コマンド</th></tr></thead><tbody><tr><td align="left">実行<br>作成・更新 ※1</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command#azure-cli">az vm run-command <strong>invoke</strong></a> ※2</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#execute-a-script-with-the-vm">az vm run-command <strong>create</strong></a><br><a href="https://learn.microsoft.com/ja-jp/cli/azure/vm/run-command?view=azure-cli-latest#az-vm-run-command-update">az vm run-command <strong>update</strong></a></td></tr><tr><td align="left">削除</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command#action-run-command-removal">az vm run-command <strong>invoke</strong></a> ※2</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#delete-runcommand-resource-from-the-vm">az vm run-command <strong>delete</strong></a></td></tr><tr><td align="left">一覧表示 ※1</td><td align="left">-</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#list-all-deployed-runcommand-resources-on-a-vm">az vm run-command <strong>list</strong></a></td></tr><tr><td align="left">実行状態と結果の取得 ※1</td><td align="left">-</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#get-execution-status-and-results">az vm run-command <strong>show</strong></a></td></tr></tbody></table><p>※1 : マネージド実行コマンドのみで実行可能な操作です。<br>※2 : パラメータで操作を使い分けます。詳細につきましては、リンク先の公開ドキュメントをご確認ください。</p><p>アクション実行コマンドで、仮想マシン上でカスタム スクリプトを実行する際のコマンド例は、以下のとおりとなります。</p><figure class="highlight powershell"><figcaption><span>Windows 仮想マシンの場合</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-AzVMRunCommand</span> `</span><br><span class="line">  <span class="literal">-ResourceGroupName</span> &lt;リソース グループ名&gt; `</span><br><span class="line">  <span class="literal">-Name</span> &lt;仮想マシン リソース名&gt; `</span><br><span class="line">  <span class="literal">-CommandId</span> <span class="string">&#x27;RunPowerShellScript&#x27;</span> `</span><br><span class="line">  <span class="literal">-ScriptPath</span> <span class="string">&#x27;&lt;実行するスクリプトのパス&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>また、アクション実行コマンドは、Azure Portal 上で実行することができます。<br>VM の <strong>[実行コマンド]</strong> ブレードから、カスタム スクリプトや組み込みのスクリプトを実行できます。</p><p><img src="/blog/vm/runcommand/001.png"></p><p>マネージド実行コマンドで、仮想マシン上でカスタム スクリプトを実行する際のコマンド例は、以下のとおりとなります。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-AzVMRunCommand</span> `</span><br><span class="line">  <span class="literal">-ResourceGroupName</span> &lt;リソース グループ名&gt; `</span><br><span class="line">  <span class="literal">-VMName</span> &lt;仮想マシン リソース名&gt; `</span><br><span class="line">  <span class="literal">-Location</span> &lt;リージョン名&gt; `</span><br><span class="line">  <span class="literal">-RunCommandName</span> &lt;任意の実行コマンド名&gt; `</span><br><span class="line">  <span class="literal">-ScriptLocalPath</span> <span class="string">&#x27;&lt;実行するスクリプトのパス&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>なお、実行コマンドをご利用いただく際は、仮想マシンが実行中の状態であることをご確認ください。</p><p>アクション実行コマンドは、一度実行すると、最終的なスクリプトの実行結果が出力されるのみでした。<br>マネージド実行コマンドでは、初回の実行時に実行コマンドが仮想マシンに登録され、<br>実行の進行状況 (最新の出力、開始/終了時刻、終了コード、および実行の終了状態など) を確認することができます。<br>また、登録された実行コマンドは更新して再実行することができ、不要になり次第、削除することができます。</p><p><img src="/blog/vm/runcommand/002.png"></p><h2 id="仮想マシン-スケール-セット-VMSS-で実行する"><a href="#仮想マシン-スケール-セット-VMSS-で実行する" class="headerlink" title="仮想マシン スケール セット (VMSS) で実行する"></a>仮想マシン スケール セット (VMSS) で実行する</h2><p>実行コマンドは、仮想マシン スケール セット (VMSS) で利用することができます。<br>仮想マシンで実行する場合と同様に、アクション実行コマンドとマネージド実行コマンドで、<br>Azure PowerShell/CLI のコマンドに違いがあります。こちらの比較表をご参照ください。</p><h4 id="Azure-PowerShell-1"><a href="#Azure-PowerShell-1" class="headerlink" title="Azure PowerShell"></a>Azure PowerShell</h4><table><thead><tr><th align="left">操作</th><th align="left">アクション実行コマンド</th><th align="left">マネージド実行コマンド</th></tr></thead><tbody><tr><td align="left">実行<br>作成・更新・追加 ※1</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/powershell/module/az.compute/invoke-azvmssvmruncommand"><strong>Invoke</strong>-AzVmssVMRunCommand</a> ※2</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/powershell/module/az.compute/set-azvmssvmruncommand"><strong>Set</strong>-AzVmssVMRunCommand</a><br><a href="https://learn.microsoft.com/ja-jp/powershell/module/az.compute/add-azvmssruncommand"><strong>Add</strong>-AzVmssRunCommand</a></td></tr><tr><td align="left">削除</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/powershell/module/az.compute/invoke-azvmssvmruncommand"><strong>Invoke</strong>-AzVmssVMRunCommand</a> ※2</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/powershell/module/az.compute/remove-azvmssvmruncommand"><strong>Remove</strong>-AzVmssVMRunCommand</a><br><a href="https://learn.microsoft.com/ja-jp/powershell/module/az.compute/remove-azvmssruncommand"><strong>Remove</strong>-AzVmssRunCommand</a></td></tr><tr><td align="left">一覧表示 ※1</td><td align="left">-</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/powershell/module/az.compute/get-azvmssvmruncommand"><strong>Get</strong>-AzVmssVMRunCommand</a> ※2</td></tr><tr><td align="left">実行状態と結果の取得 ※1</td><td align="left">-</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/powershell/module/az.compute/get-azvmssvmruncommand"><strong>Get</strong>-AzVmssVMRunCommand</a> ※2</td></tr></tbody></table><h4 id="Azure-CLI-1"><a href="#Azure-CLI-1" class="headerlink" title="Azure CLI"></a>Azure CLI</h4><table><thead><tr><th align="left">操作</th><th align="left">アクション実行コマンド</th><th align="left">マネージド実行コマンド</th></tr></thead><tbody><tr><td align="left">実行<br>作成・更新 ※1</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/cli/azure/vmss/run-command?view=azure-cli-latest#az-vmss-run-command-invoke">az vmss run-command <strong>invoke</strong></a> ※2</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/cli/azure/vmss/run-command?view=azure-cli-latest#az-vmss-run-command-create">az vmss run-command <strong>create</strong></a><br><a href="https://learn.microsoft.com/ja-jp/cli/azure/vmss/run-command?view=azure-cli-latest#az-vmss-run-command-update">az vmss run-command <strong>update</strong></a></td></tr><tr><td align="left">削除</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/cli/azure/vmss/run-command?view=azure-cli-latest#az-vmss-run-command-invoke">az vmss run-command <strong>invoke</strong></a> ※2</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/cli/azure/vmss/run-command?view=azure-cli-latest#az-vmss-run-command-delete">az vmss run-command <strong>delete</strong></a></td></tr><tr><td align="left">一覧表示 ※1</td><td align="left">-</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/cli/azure/vmss/run-command?view=azure-cli-latest#az-vmss-run-command-list">az vmss run-command <strong>list</strong></a></td></tr><tr><td align="left">実行状態と結果の取得 ※1</td><td align="left">-</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/cli/azure/vmss/run-command?view=azure-cli-latest#az-vmss-run-command-show">az vmss run-command <strong>show</strong></a></td></tr></tbody></table><p>※1 : マネージド実行コマンドのみで実行可能な操作です。<br>※2 : パラメータで操作を使い分けます。詳細につきましては、リンク先の公開ドキュメントをご確認ください。</p><p>アクション実行コマンドで、VMSS 内の仮想マシン (インスタンス ID が <code>0</code> ) 上で、<br>カスタム スクリプトを実行する際のコマンド例は、以下のとおりとなります。</p><figure class="highlight powershell"><figcaption><span>Windows 仮想マシンの場合</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-AzVmssVMRunCommand</span> `</span><br><span class="line">  <span class="literal">-ResourceGroupName</span> &lt;リソース グループ名&gt; `</span><br><span class="line">  <span class="literal">-VMScaleSetName</span> &lt;VMSS リソース名&gt; `</span><br><span class="line">  <span class="literal">-InstanceId</span> <span class="number">0</span> `</span><br><span class="line">  <span class="literal">-CommandId</span> <span class="string">&#x27;RunPowerShellScript&#x27;</span> `</span><br><span class="line">  <span class="literal">-ScriptPath</span> <span class="string">&#x27;&lt;実行するスクリプトのパス&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>マネージド実行コマンドで、VMSS 内の仮想マシン (インスタンス ID が <code>0</code> ) 上で、<br>カスタム スクリプトを実行する際のコマンド例は、以下のとおりとなります。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-AzVmssVMRunCommand</span> `</span><br><span class="line">  <span class="literal">-ResourceGroupName</span> &lt;リソース グループ名&gt; `</span><br><span class="line">  <span class="literal">-VMScaleSetName</span> &lt;VMSS リソース名&gt; `</span><br><span class="line">  <span class="literal">-Location</span> &lt;リージョン名&gt; `</span><br><span class="line">  <span class="literal">-InstanceId</span> <span class="number">0</span> `</span><br><span class="line">  <span class="literal">-RunCommandName</span> &lt;任意の実行コマンド名&gt; `</span><br><span class="line">  <span class="literal">-ScriptLocalPath</span> <span class="string">&#x27;&lt;実行するスクリプトのパス&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>また、マネージド実行コマンドでは、VMSS 内の全ての仮想マシンに実行コマンドを追加する<br><code>Add-AzVmssRunCommand</code> が利用できます。<br><code>Remove-AzVmssRunCommand</code> で実行コマンドを削除することも可能です。</p><p>なお、実行コマンドをご利用いただく際は、VMSS 内の仮想マシンが実行中の状態であることをご確認ください。</p><div class="alert is-info"><p class="alert-title">Note</p><p>仮想マシン スケール セット (VMSS) のオーケストレーション モードが Uniform の場合に、VMSS のコマンド (<code>Set-AzVmssVMRunCommand</code> 等) が利用できます。</p><p>Flexible の場合は、VMSS 内の各仮想マシンに対して、仮想マシンのコマンド (<code>Set-AzVMRunCommand</code> 等) を実行する必要があります。</p></div><hr><h2 id="実行するスクリプトを指定する"><a href="#実行するスクリプトを指定する" class="headerlink" title="実行するスクリプトを指定する"></a>実行するスクリプトを指定する</h2><p>実行コマンドでは、実行するコマンドをパラメータで直接指定することができます。<br>また、カスタム スクリプトを指定する場合は、<br>アクション実行コマンドとマネージド実行コマンドで指定可能なソースに違いがあり、<br>マネージド実行コマンドでは、BLOB ストレージの SAS URL が指定可能となっています。</p><p>アクション実行コマンドの場合は、<code>Invoke-AzVMRunCommand</code> の以下のいずれかのパラメータで指定します。</p><ul><li><code>-ScriptString</code> : 実行するコマンド<br>例 : ping 10.0.0.1</li><li><code>-ScriptPath</code> : <code>Invoke-AzVMRunCommand</code> を実行する環境のローカル ファイル パス<br>例 : C:\work\test.ps1</li></ul><p>マネージド実行コマンドの場合は、<code>Set-AzVMRunCommand / Set-AzVmssVMRunCommand</code> の以下のいずれかのパラメータで指定します。</p><ul><li><code>-SourceScript</code> : 実行するコマンド<br>例 : ping 10.0.0.1</li><li><code>-ScriptLocalPath</code> : <code>Set-AzVMRunCommand / Set-AzVmssVMRunCommand</code> を実行する環境のローカル ファイル パス<br>例 : C:\work\test.ps1</li><li><code>-SourceScriptUri</code> : スクリプトを配置した BLOB ストレージ の SAS URL<br>例 : https://{ストレージ アカウント名}.blob.core.windows.net/{BLOB コンテナ名}/test.ps1?{SAS}</li></ul><hr><h2 id="スクリプトの出力内容を確認する"><a href="#スクリプトの出力内容を確認する" class="headerlink" title="スクリプトの出力内容を確認する"></a>スクリプトの出力内容を確認する</h2><p>Azure テクニカル サポートチームでは、実行コマンドの拡張機能を有効または無効とされた際のエラーや<br>拡張機能のアップデート時のエラー等につきまして、調査をご支援させていただくことが可能です。<br>その一方で、お客様にて作成されたスクリプトにつきましては、<br>お客様がご自身でトラブルシューティングを実施していただくことが必要となります。</p><p>トラブルシューティングの際に、コマンドの実行結果やエラー等を確認したい場合は、<br>アクション実行コマンドでは実行時の出力結果をご確認いただきます。<br>マネージド実行コマンドでは、状態を取得した上で、InstanceView からご確認いただけます。<br>ただし、これらの出力結果は、実際の出力内容の最後の 4 KB のみとなります。</p><p>マネージド実行コマンドで出力結果を確認する際のコマンド例は以下のとおりとなります。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">Get-AzVMRunCommand</span> <span class="literal">-ResourceGroupName</span> &lt;リソース グループ名&gt; <span class="literal">-VMName</span> &lt;仮想マシン リソース名&gt; <span class="literal">-RunCommandName</span> &lt;実行コマンド名&gt; <span class="literal">-Expand</span> InstanceView).InstanceView</span><br></pre></td></tr></table></figure><p>InstanceView の出力例はこちらになります。<br><code>ExecutionState</code> にスクリプトの実行が成功したかどうかが表示されます。<br><code>Output</code> でスクリプトが正常に終了した場合の出力結果、<br><code>Error</code> でスクリプトの途中でエラーとなった場合の出力結果が確認できます。<br><code>StartTime/EndTime</code> でスクリプトの実行開始時刻および終了時刻が確認できます。</p><p><img src="/blog/vm/runcommand/003.png" alt="デスクトップにファイルを生成するスクリプトを実行した場合の出力例"></p><blockquote><p><em><strong>実行コマンドの作成または更新後に VM の実行コマンド インスタンス ビューを取得する</strong></em><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#get-a-run-command-instance-view-for-a-vm-after-creating-or-updating-run-command">https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#get-a-run-command-instance-view-for-a-vm-after-creating-or-updating-run-command</a></p></blockquote><p>4 KB を超える出力内容をご確認いただく方法として、マネージド実行コマンドでは、<br>標準出力と標準エラー メッセージを追加 BLOB にストリーミングして、ご確認いただくことが可能です。<br>ストリーミング先の追加 BLOB は、BLOB の SAS URL を指定することができます。<br>コマンド例は、以下のとおりとなります。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-AzVMRunCommand</span> `</span><br><span class="line">  <span class="literal">-ResourceGroupName</span> &lt;リソース グループ名&gt; `</span><br><span class="line">  <span class="literal">-VMName</span> &lt;仮想マシン リソース名&gt; `</span><br><span class="line">  <span class="literal">-Location</span> &lt;リージョン名&gt; `</span><br><span class="line">  <span class="literal">-RunCommandName</span> &lt;実行コマンド名&gt; `</span><br><span class="line">  <span class="literal">-ScriptLocalPath</span> <span class="string">&quot;&lt;実行するスクリプトのパス&gt;&quot;</span> `</span><br><span class="line">  <span class="literal">-OutputBlobUri</span> <span class="string">&quot;https://&#123;出力先のストレージ アカウント名&#125;.blob.core.windows.net/&#123;BLOB コンテナ名&#125;/output.txt?&#123;SAS&#125;&quot;</span> `</span><br><span class="line">  <span class="literal">-ErrorBlobUri</span> <span class="string">&quot;https://&#123;出力先のストレージ アカウント名&#125;.blob.core.windows.net/&#123;BLOB コンテナ名&#125;/error.txt?&#123;SAS&#125;&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p><em><strong>OutputBlobUri、ErrorBlobUri を使用して VM で実行コマンドを作成または更新し、標準出力と標準エラー メッセージを出力およびエラー追加 BLOB にストリーミングする</strong></em><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#create-or-update-run-command-on-a-vm-using-outputbloburi-errorbloburi-to-stream-standard-output-and-standard-error-messages-to-output-and-error-append-blobs">https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#create-or-update-run-command-on-a-vm-using-outputbloburi-errorbloburi-to-stream-standard-output-and-standard-error-messages-to-output-and-error-append-blobs</a></p></blockquote><hr><h2 id="スクリプトを実行するユーザについて"><a href="#スクリプトを実行するユーザについて" class="headerlink" title="スクリプトを実行するユーザについて"></a>スクリプトを実行するユーザについて</h2><p>アクション実行コマンドでは、Windows の場合はシステム アカウント、Linux の場合はルート ユーザで実行されます。</p><p>マネージド実行コマンドでは、実行するユーザを指定することができます。<br>ユーザを指定しない場合は、アクション実行コマンドと同様に、<br>Windows の場合はシステム アカウント、Linux の場合はルート ユーザで実行されます。<br>実行するユーザを指定する際のコマンド例は、以下のとおりとなります。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-AzVMRunCommand</span> `</span><br><span class="line">  <span class="literal">-ResourceGroupName</span> &lt;リソース グループ名&gt; `</span><br><span class="line">  <span class="literal">-VMName</span> &lt;仮想マシン リソース名&gt; `</span><br><span class="line">  <span class="literal">-Location</span> &lt;リージョン名&gt; `</span><br><span class="line">  <span class="literal">-RunCommandName</span> &lt;任意の実行コマンド名&gt; `</span><br><span class="line">  <span class="literal">-ScriptLocalPath</span> <span class="string">&quot;&lt;実行するスクリプトのパス&gt;&quot;</span> `</span><br><span class="line">  <span class="literal">-RunAsUser</span> &lt;実行ユーザ名&gt; `</span><br><span class="line">  <span class="literal">-RunAsPassword</span> &lt;実行ユーザのパスワード&gt;</span><br></pre></td></tr></table></figure><blockquote><p><em><strong>RunAsUser および RunAsPassword パラメーターを使用して別のユーザーとして VM で実行コマンドを作成または更新する</strong></em><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#create-or-update-run-command-on-a-vm-as-a-different-user-using-runasuser-and-runaspassword-parameters">https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#create-or-update-run-command-on-a-vm-as-a-different-user-using-runasuser-and-runaspassword-parameters</a></p></blockquote><hr><h2 id="複数の仮想マシンでスクリプトを実行する"><a href="#複数の仮想マシンでスクリプトを実行する" class="headerlink" title="複数の仮想マシンでスクリプトを実行する"></a>複数の仮想マシンでスクリプトを実行する</h2><p>複数の仮想マシンで同じスクリプトを実行したい場合は、スクリプトを実行する仮想マシンのリストを取得して、<br>Azure CLI または Azure PowerShell のコマンドを繰り返し実行することで実現できます。<br>REST API をご利用いただく場合も同様に実現可能です。</p><p>例えば、<code>testtag</code> というタグの値が <code>y</code> となっている全ての仮想マシンでスクリプトを実行したい場合、<br>コマンド例は以下のとおりとなります。</p><figure class="highlight powershell"><figcaption><span>マネージド実行コマンド コマンド例 (Azure PowerShell/PowerShell 7)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$VMList</span> = <span class="selector-tag">@</span>(<span class="built_in">Get-AzResource</span> <span class="literal">-Tag</span> <span class="selector-tag">@</span>&#123;<span class="string">&#x27;testtag&#x27;</span>=<span class="string">&#x27;y&#x27;</span>&#125;) </span><br><span class="line"><span class="variable">$VMList</span> | <span class="built_in">Foreach-Object</span> <span class="literal">-Parallel</span> &#123;<span class="built_in">Set-AzVMRunCommand</span> <span class="literal">-ResourceGroupName</span> <span class="variable">$_</span>.ResourceGroupName <span class="literal">-VMName</span> <span class="variable">$_</span>.name <span class="literal">-Location</span> &lt;リージョン名&gt; <span class="literal">-RunCommandName</span> <span class="string">&#x27;&lt;任意の実行コマンド名&gt;&#x27;</span> <span class="literal">-ScriptLocalPath</span> <span class="string">&#x27;&lt;実行するスクリプトのパス&gt;&#x27;</span>&#125;  </span><br></pre></td></tr></table></figure><div class="alert is-info"><p class="alert-title">Note</p><p>実行コマンドを繰り返し実行する際、Azure Resource Manager (ARM) の要求スロットルの上限に達して、要求がエラーとなる可能性があります。</p><p>複数の VM でスクリプトをリモート実行される要件がある場合は、検証等を実施していただき、問題なくスクリプトが実行できることを予めご確認いただくことを推奨します。</p><p>&emsp;</p><p><em><strong>Resource Manager の要求のスロットル</strong></em></p><p><a href="https://learn.microsoft.com/ja-jp/azure/azure-resource-manager/management/request-limits-and-throttling#error-code">https://learn.microsoft.com/ja-jp/azure/azure-resource-manager/management/request-limits-and-throttling#error-code</a></p><p><em><strong>API の調整エラーのトラブルシューティング</strong></em></p><p><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshooting-throttling-errors">https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshooting-throttling-errors</a></p></div><hr><h2 id="長時間のスクリプトを実行する"><a href="#長時間のスクリプトを実行する" class="headerlink" title="長時間のスクリプトを実行する"></a>長時間のスクリプトを実行する</h2><p>アクション実行コマンドでは、スクリプトを実行可能な最大時間が 90 分という制約がありましたが、<br>マネージド実行コマンドでは、実行時間が 90 分を超えるスクリプトの実行が可能です。<br>マネージド実行コマンドにおいて、長時間のスクリプトを実行する際には、<br>Azure PowerShell の場合は、以下のパラメータを指定する必要があります。</p><ul><li><code>timeoutInSeconds</code> パラメータを予測される実行時間よりも大きく指定する。</li><li><code>asyncExecution</code> パラメータを <code>true</code> とする。</li></ul><div class="alert is-info"><p class="alert-title">Note</p><p><code>timeoutInSeconds</code> パラメータでは、スクリプトのタイムアウト値を秒で指定します。</p><p><code>asyncExecution</code> パラメータは、デフォルトでは false となっており、スクリプトが完了するまでプロビジョニングが待機する設定となっていますので、90 分でプロビジョニングのタイムアウトが発生します。回避するためには、<code>true</code> を指定します。</p></div><p>タイムアウト値を 5 時間に指定する際のコマンド例は以下のとおりです。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-AzVMRunCommand</span> `</span><br><span class="line">  <span class="literal">-ResourceGroupName</span> &lt;リソース グループ名&gt; `</span><br><span class="line">  <span class="literal">-VMName</span> &lt;仮想マシン リソース名&gt; `</span><br><span class="line">  <span class="literal">-Location</span> &lt;リージョン名&gt; `</span><br><span class="line">  <span class="literal">-RunCommandName</span> &lt;任意の実行コマンド名&gt; `</span><br><span class="line">  <span class="literal">-ScriptLocalPath</span> <span class="string">&quot;&lt;実行するスクリプトのパス&gt;&quot;</span> `</span><br><span class="line">  <span class="literal">-TimeoutInSecond</span> <span class="number">18000</span> `</span><br><span class="line">  <span class="literal">-AsyncExecution</span> true</span><br></pre></td></tr></table></figure><hr><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>この記事では、 実行コマンドの利用方法について解説しました。<br>Azure VM にてスクリプトをリモートで実行されるご要件がある場合や、<br>アクション実行コマンドからマネージド実行コマンドに運用を移行される際のご参考としていただけますと幸いでございます。 </p><p>マネージド実行コマンドでは、本記事で解説した機能に加え、<br>1 台の VM で複数のスクリプトを同時実行する機能 (ARM テンプレート利用)やギャラリー機能等がご利用いただけます。<br>記事内でご案内いたしました公開ドキュメントも併せてご確認ください。</p><p>上記の解説内容が、皆様のお役に立てますと幸いでございます。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポートチームの井上です。 &lt;/p&gt;
&lt;p&gt;本記事では、Azure VM の拡張機能の一つである実行コマンド (RunCommand) について、&lt;br&gt;利用方法やアクション実行コマンドとマネージド実行コマンドの違い等を解説させていただきます。&lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="Linux" scheme="https://jpaztech.github.io/blog/tags/Linux/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
  </entry>
  
  <entry>
    <title>Azure マーケットプレイスのイメージの OS ディスクサイズの確認・拡張・縮小について</title>
    <link href="https://jpaztech.github.io/blog/vm/os-disk-size-of-image/"/>
    <id>https://jpaztech.github.io/blog/vm/os-disk-size-of-image/</id>
    <published>2023-02-22T08:30:00.000Z</published>
    <updated>2023-08-18T00:59:11.666Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポート チームの富田です。<br>今回はお問い合わせいただくことの多い、Azure マーケットプレイスのイメージの OS ディスクサイズについて、<br>確認方法・拡張方法・縮小不可などの点について解説させていただきます。  </p><span id="more"></span><hr><h2 id="1-イメージの-URN-を把握する"><a href="#1-イメージの-URN-を把握する" class="headerlink" title="1.イメージの URN を把握する"></a>1.イメージの URN を把握する</h2><p>イメージの OS ディスクサイズを確認や、コマンドベースでイメージを指定してデプロイを行う場合は、<br>まずは当該イメージの URN（Uniform Resource Name）を把握する必要があります。<br>イメージの URN は以下のような 4 つの情報の組み合わせで構成されています。  </p><ul><li>Publisher</li><li>Offer</li><li>Sku</li><li>Version</li></ul><p>この 4 つの情報を組み合わせることで、特定のイメージが指定できるということになります。<br>例えば、Azure マーケットプレイス に公開されている 2022/12/29 時点で最新の Windows Server 2022 Datacenter: Azure Edition の URN 以下のようになります。 </p><ul><li>Publisher : microsoftwindowsserver</li><li>Offer : windowsserver</li><li>Sku : 2022-datacenter-azure-edition</li><li>Version : 20348.1366.221207</li></ul><p>ここでひとつ注意したい点は、Azure マーケットプレイスのイメージにおける Version は、あくまでイメージの Version であって、<br>「Windows Server 2012」「Windows Server 2019」といった OS の違いは、Sku の方で定義されているということです。  </p><p>同じ Windows Server 2022 Datacenter: Azure Edition でも、イメージの Version が古いものはビルド等が古いといったこととなります。  </p><p>では、実際にこの URN をどうやって確認するのか、「Azure ポータル」「Azure PowerShell」「Azure CLI」それぞれで確認する方法から見ていきましょう。  </p><hr><h2 id="1-1-Azure-ポータルでイメージの-URN-を把握する"><a href="#1-1-Azure-ポータルでイメージの-URN-を把握する" class="headerlink" title="1-1.Azure ポータルでイメージの URN を把握する"></a>1-1.Azure ポータルでイメージの URN を把握する</h2><p>Azure ポータルにログインし、「リソースの作成」を選択します。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-11-32-56.png"></p><p>「リソースの作成」画面の検索ボックスより、Azure マーケットプレイスのイメージを検索します。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-11-33-57.png"></p><p>対象のイメージを選択します。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-11-34-57.png"></p><p>対象のイメージの画面上で、「プラン」を選択の上、「使用状況確認とサポート」タブを選択します。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-11-43-09.png"></p><p>上記のように、URN が表示されます。<br>恐縮ながら Azure ポータルでは Version の一覧の確認は叶いませんため、Version について確認が必要な場合は、後述のコマンドベースでのご確認をお願いいたします。</p><hr><h2 id="1-2-Azure-PowerShell-でイメージの-URN-を把握する"><a href="#1-2-Azure-PowerShell-でイメージの-URN-を把握する" class="headerlink" title="1-2.Azure PowerShell でイメージの URN を把握する"></a>1-2.Azure PowerShell でイメージの URN を把握する</h2><p>基本的に以下の公式ドキュメントの方法となりますが、実際にコマンドの実行結果と共に見ていきましょう。<br>Publisher → Offer → Sku → Version の順で絞り込んで検索していくような形となります。</p><blockquote><p>■ご参考：Azure PowerShell を使用して Azure Marketplace VM イメージを検索して使用する<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/cli-ps-findimage">https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/cli-ps-findimage</a></p></blockquote><p>まずは、リージョンを指定して Publisher の一覧を取得します。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p>リージョン名は下記コマンドで Location として表示されるものを使います。</p><p>Get-AzLocation | select Location, DisplayName</p></div><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$locName = &quot;リージョン名&quot;</span><br><span class="line">Get-AzVMImagePublisher -Location $locName | Select PublisherName</span><br></pre></td></tr></table></figure><p>以下が実際に実行した結果の一部です。Publisher の一覧が表示されていますね。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-12-20-08.png"></p><p>次に、確認した Publisher を指定してその Publisher が公開している Offer の一覧を表示しましょう。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$locName = &quot;リージョン名&quot;</span><br><span class="line">$pubName = &quot;パブリッシャー名&quot;</span><br><span class="line">Get-AzVMImageOffer -Location $locName -PublisherName $pubName | Select Offer</span><br></pre></td></tr></table></figure><p>以下が実際に実行した結果の一部です。Publisher が公開している Offer の一覧が表示されました。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-12-04-16.png"></p><p>次に、確認した Offer を指定してその Offer 内の Sku の一覧を表示しましょう。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$locName = &quot;リージョン名&quot;</span><br><span class="line">$pubName=&quot;パブリッシャー名&quot;</span><br><span class="line">$offerName = &quot;オファー名&quot;</span><br><span class="line">Get-AzVMImageSku -Location $locName -PublisherName $pubName -Offer $offerName | Select Skus</span><br></pre></td></tr></table></figure><p>以下が実際に実行した結果の一部です。指定した Offer 内の Sku の一覧が表示されました。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-12-06-44.png"></p><p>最後に、Sku を指定してその Sku 内の Version の一覧を調べましょう。  </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$locName = &quot;リージョン名&quot;</span><br><span class="line">$pubName=&quot;パブリッシャー名&quot;</span><br><span class="line">$offerName = &quot;オファー名&quot;</span><br><span class="line">$skuName = &quot;SKU 名&quot;</span><br><span class="line">Get-AzVMImage -Location $locName -PublisherName $pubName -Offer $offerName -Sku $skuName | Select PublisherName, Offer, Skus, Version</span><br></pre></td></tr></table></figure><p>以下が実際に実行した結果の一部です。<br>無事に Version 一覧も取得でき、Publisher, Offer, Sku, Version の組み合わせでイメージの URN が把握できました。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-12-11-28.png"></p><hr><h2 id="1-3-Azure-CLI-でイメージの-URN-を把握する"><a href="#1-3-Azure-CLI-でイメージの-URN-を把握する" class="headerlink" title="1-3.Azure CLI でイメージの URN を把握する"></a>1-3.Azure CLI でイメージの URN を把握する</h2><p>基本的に以下の公式ドキュメントの方法となりますが、実際にコマンドの実行結果と共に見ていきましょう。<br>Publisher → Offer → Sku → Version の順で絞り込んで検索していくような形となります。</p><blockquote><p>■ご参考：Azure CLI を使用して Azure Marketplace イメージ情報を検索する<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/cli-ps-findimage">https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/cli-ps-findimage</a></p></blockquote><p>まずは、リージョンを指定して Publisher の一覧を取得します。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p>リージョン名は下記コマンドで name として表示されるものを使います。</p><p>az account list-locations</p></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az vm image list-publishers --location ＜リージョン名＞ --output table</span><br></pre></td></tr></table></figure><p>以下が実際に実行した結果の一部です。Publisher の一覧が表示されていますね。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-13-38-26.png"></p><p>次に、確認した Publisher を指定してその Publisher が公開している Offer の一覧を表示しましょう。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az vm image list-offers --location ＜リージョン名＞ --publisher ＜パブリッシャー名＞ --output table</span><br></pre></td></tr></table></figure><p>以下が実際に実行した結果の一部です。Publisher が公開している Offer の一覧が表示されました。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-13-39-16.png"></p><p>次に、確認した Offer を指定してその Offer 内の Sku の一覧を表示しましょう。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az vm image list-skus --location ＜リージョン名＞ --publisher ＜パブリッシャー名＞ --offer ＜オファー名＞ --output table</span><br></pre></td></tr></table></figure><p>以下が実際に実行した結果の一部です。指定した Offer 内の Sku の一覧が表示されました。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-13-40-26.png"></p><p>最後に、Sku を指定してその Sku 内の Version の一覧を調べましょう。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">az vm image list \</span><br><span class="line">    --location ＜リージョン名＞ \</span><br><span class="line">    --publisher ＜パブリッシャー名＞ \</span><br><span class="line">    --offer ＜オファー名＞  \</span><br><span class="line">    --sku ＜SKU 名＞ \</span><br><span class="line">    --all --output table</span><br></pre></td></tr></table></figure><p>以下が実際に実行した結果の一部です。<br>無事に Version 一覧も取得でき、Publisher, Offer, Sku, Version の組み合わせでイメージの URN が把握できました。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-13-43-57.png"></p><hr><h2 id="2-イメージの-OS-ディスクサイズを確認する"><a href="#2-イメージの-OS-ディスクサイズを確認する" class="headerlink" title="2.イメージの OS ディスクサイズを確認する"></a>2.イメージの OS ディスクサイズを確認する</h2><p>上述の方法でイメージ URN を把握すれば、 Azure CLI の下記コマンド使用することで、そのイメージの OS ディスクサイズを確認することが可能です。<br>なお恐縮ながら Azure PowerShell では確認が叶いませんものと存じます。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az vm image show --location ＜リージョン名＞ --urn ＜パブリッシャー名＞:＜オファー名＞:＜SKU 名＞:＜バージョン番号＞</span><br></pre></td></tr></table></figure><div class="alert is-success"><p class="alert-title">ヒント</p><p>最新のバージョンとして ＜バージョン番号＞ に latest という文字列を使用することが可能です。</p></div><p>コマンドの実行結果を見ると以下の通り、OS ディスクサイズに関する表記が確認できます。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-14-03-40.png"></p><hr><h2 id="3-Windows-のイメージの既定-OS-ディスクサイズについて"><a href="#3-Windows-のイメージの既定-OS-ディスクサイズについて" class="headerlink" title="3.Windows のイメージの既定 OS ディスクサイズについて"></a>3.Windows のイメージの既定 OS ディスクサイズについて</h2><p>2023 年 1 月時点で、Azure マーケットプレイスで Microsoft より公開されている Windows のイメージについては、<br>OS ディスクサイズは既定で 127 GB となっております。  </p><p>しかしながら、これよりも小さな OS ディスクが必要なお客様のために、Windows Server については、<br>smalldisk というプラン（Offer）で OS ディスクが 30 GB となっているイメージをご用意しております。<br>基本的にディスクサイズが違う点以外、イメージの内容は通常版と差異は無いものと存じますため、<br>Windows Server で小さな OS ディスクが必要な場合は smalldisk のイメージをご利用くださいませ。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-14-32-25.png"></p><blockquote><p>■ご参考：New smaller Windows Server IaaS Image<br><a href="https://azure.microsoft.com/ja-jp/blog/new-smaller-windows-server-iaas-image/">https://azure.microsoft.com/ja-jp/blog/new-smaller-windows-server-iaas-image/</a></p></blockquote><hr><h2 id="4-OS-ディスクサイズの拡張について"><a href="#4-OS-ディスクサイズの拡張について" class="headerlink" title="4.OS ディスクサイズの拡張について"></a>4.OS ディスクサイズの拡張について</h2><p>OS ディスクサイズは以下の通り、VM デプロイ後に後から拡張することが可能です。</p><blockquote><p>■ご参考：Windows 仮想マシンに接続されている仮想ハード ディスクを拡張する方法<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/expand-os-disk">https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/expand-os-disk</a></p></blockquote><blockquote><p>■ご参考：Linux VM の仮想ハード ディスクを拡張する<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/expand-disks">https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/expand-disks</a></p></blockquote><p>また、Azure CLI を用いた場合、 az vm create コマンドで新規 VM をデプロイする際に、<br>–os-disk-size-gb オプションに数値を指定いただくと、指定いただいた GB のサイズで OS ディスクが作成されます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az vm create --resource-group ＜リソースグループ名＞ --name ＜VM 名＞ --image ＜パブリッシャー名＞:＜オファー名＞:＜SKU 名＞:＜バージョン番号＞ --os-disk-size-gb ＜OS ディスクサイズ GB の数値＞ </span><br></pre></td></tr></table></figure><blockquote><p>■ご参考：az vm create<br><a href="https://learn.microsoft.com/ja-jp/cli/azure/vm?view=azure-cli-latest#az-vm-create">https://learn.microsoft.com/ja-jp/cli/azure/vm?view=azure-cli-latest#az-vm-create</a></p></blockquote><div class="alert is-info"><p class="alert-title">Note</p><p>既定の OS ディスクサイズより小さな値を指定することはできません。</p><p>また、サードパーティ様のイメージでは OS ディスクの拡張がサポートされない可能性もございます点、ご了承くださいませ。</p></div><p>例としてこちらのコマンドで以下のように、300 GB の OS ディスクを持つ Windows Server がデプロイできました。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-15-07-19.png"></p><p>なお恐縮ながら Azure PowerShell ではこのような VM デプロイ時の OS ディスクサイズ指定が叶いませんものと存じますため、<br>Azure PowerShell の場合はデプロイ後に OS ディスクサイズをご変更いただけますと幸いです。</p><hr><h2 id="5-OS-ディスクサイズの縮小について"><a href="#5-OS-ディスクサイズの縮小について" class="headerlink" title="5.OS ディスクサイズの縮小について"></a>5.OS ディスクサイズの縮小について</h2><p>恐縮ではございますが、OS ディスク・データディスク共に、<br>現在 Azure マネージドディスクの縮小はサポートされておりませんものとなります。</p><blockquote><p>■ご参考：マネージド ディスクを縮小またはダウンサイズできますか?<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/faq-for-disks#----------------------------">https://learn.microsoft.com/ja-jp/azure/virtual-machines/faq-for-disks#—————————-</a></p></blockquote><p>そのため小さな OS ディスクが必要なときは、Windows Server の場合は先述の smalldisk を使用することや、<br>Linux の場合オンプレミス環境等で任意の VHD のサイズをご用意いただき、Azure へアップロードしてご利用いただくといったことをご検討いただけますと幸いです。</p><p>上記の解説内容が、皆様のお役に立てますと幸いでございます。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポート チームの富田です。&lt;br&gt;今回はお問い合わせいただくことの多い、Azure マーケットプレイスのイメージの OS ディスクサイズについて、&lt;br&gt;確認方法・拡張方法・縮小不可などの点について解説させていただきます。  &lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="Linux" scheme="https://jpaztech.github.io/blog/tags/Linux/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
    <category term="Disk" scheme="https://jpaztech.github.io/blog/tags/Disk/"/>
    
  </entry>
  
  <entry>
    <title>AKS 1.24 アップグレード時にAzure Load Balancer の正常性プローブプロトコルが変更される</title>
    <link href="https://jpaztech.github.io/blog/containers/aks-lb-probe-failed-after-upgraded-to-k8s-1.24/"/>
    <id>https://jpaztech.github.io/blog/containers/aks-lb-probe-failed-after-upgraded-to-k8s-1.24/</id>
    <published>2023-02-02T04:00:00.000Z</published>
    <updated>2023-08-18T00:59:11.278Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポートチームの小沢です。 </p><p>AKS の Kubernetes バージョンを 1.24 へアップグレードをした際に、Azure Load Balancer の正常性プローブがTCPプロ―ブから HTTP/HTTPS プローブに変更されることがあります。<br>本記事では、プローブの構成が変更された理由と影響、および対応方法について紹介します。 </p><span id="more"></span> <hr><h2 id="Azure-Load-Balancer正常性プローブ"><a href="#Azure-Load-Balancer正常性プローブ" class="headerlink" title="Azure Load Balancer正常性プローブ"></a>Azure Load Balancer正常性プローブ</h2><p>AKS クラスターに Type LoadBalancer の Service を作成すると、自動的に Azure Load Balancer に負荷分散規則が構成され、バックエンドには AKS ノードが割り当てられます。<br>また、Load Balancer のヘルスチェック機能である正常性プローブが構成されます。 </p><p>正常性プローブは、一定の間隔でバックエンドの VM インスタンスに対してヘルスチェック用のアクセスをします。<br>ヘルスチェックのアクセスが、プローブに設定された回数成功しなかった場合は、バックエンドが異常とみなされ、異常なバックエンドにはリクエストが送信されなくなります。<br>正常性プローブで利用できるプロトコルには、TCP、HTTP、HTTPSの3つがあります (Load Balancer の SKU が Standardの場合)。<br>正常性プローブで利用可能なプロトコルの種類や動作につきましては、以下のドキュメントをご参照ください。 </p><blockquote><p>ご参考) Azure Load Balancer の正常性プローブ<br><a href="https://learn.microsoft.com/ja-jp/azure/load-balancer/load-balancer-custom-probe-overview">https://learn.microsoft.com/ja-jp/azure/load-balancer/load-balancer-custom-probe-overview</a> </p></blockquote><h2 id="Service-Type-LoadBalancer-に設定される正常性プローブ"><a href="#Service-Type-LoadBalancer-に設定される正常性プローブ" class="headerlink" title="Service (Type LoadBalancer) に設定される正常性プローブ"></a>Service (Type LoadBalancer) に設定される正常性プローブ</h2><p>AKS 上で Service (Type LoadBalancer) を作成した場合には、Service オブジェクトに設定された値に基づいて、Azure Load Balancer の正常性プローブが自動的に構成されます。 </p><p>正常性プローブで使用するプロトコルは、Service の <code>spec.ports.appProtocol</code> フィールドの設定値 (tcp, http, https) が使用されます。<br>また、プロトコルが http/https の場合、<code>service.beta.kubernetes.io/azure-load-balancer-health-probe-request-path</code> アノテーションで指定されたパスに対して、正常性プローブのリクエストが送信されます。<br><code>spec.ports.appProtocol</code> が設定されていない場合は、アノテーションによるリクエスト パスの指定は無視され、tcp プロトコルを使用する正常性プローブが構成されます。</p><p>Kubernetes バージョン 1.24以降では、Service のアノテーション <code>service.beta.kubernetes.io/azure-load-balancer-health-probe-request-path</code> が設定されて<strong>いない場合</strong>に、正常性プローブの既定の構成が変更されました。<br>Kubernetes バージョン 1.23 以前と 1.24 以降では、次のような違いがあります。 </p><ul><li>Kubernetes バージョン &lt;= 1.23 の場合 <ul><li>Service のアノテーションが設定されていない場合、<strong>プローブのプロトコルに TCP が使用されます</strong> </li><li>アノテーションが設定されている場合は、プロトコルは <code>spec.ports.appProtocol</code> (http/https) が使用され、アノテーションで指定されたパスにプローブのリクエストが送信されます </li></ul></li><li>Kubernetes バージョン &gt; 1.24 の場合 <ul><li>Service のアノテーションが設定されていない場合、<strong>プローブのプロトコルに <code>spec.ports.appProtocol</code> (http/https) が使用され、リクエスト パスには <code>/</code> が使用されます</strong> </li><li>アノテーションが設定されている場合は、プロトコルは <code>spec.ports.appProtocol</code> (http/https) が使用され、アノテーションで指定されたパスにプローブのリクエストが送信されます </li></ul></li></ul><p>Load Balancer の正常性プローブで、どのプロトコルとリクエスト パスが使用されるかについては、Cloud Provider Azure のドキュメントで確認できます。 </p><blockquote><p>ご参考) Cloud Provider Azure - Custom Load Balancer health probe<br><a href="https://cloud-provider-azure.sigs.k8s.io/topics/loadbalancer/#custom-load-balancer-health-probe">https://cloud-provider-azure.sigs.k8s.io/topics/loadbalancer/#custom-load-balancer-health-probe</a> </p></blockquote><h2 id="正常性プローブの構成が変更された場合の影響"><a href="#正常性プローブの構成が変更された場合の影響" class="headerlink" title="正常性プローブの構成が変更された場合の影響"></a>正常性プローブの構成が変更された場合の影響</h2><p>Service (type: LoadBalancer) の YAML マニフェストにおいて、Service のアノテーション <code>service.beta.kubernetes.io/azure-load-balancer-health-probe-request-path</code> を記述せずに、<code>spec.ports.appProtocol</code> のみを記述している場合に、Kubernetes バージョンをアップグレードしたあとにアプリケーションへアクセスできない事象が発生する可能性があります。 </p><p>Kubernetes &lt;= 1.23 では、<code>spec.ports.appProtocol</code> にプロトコル名が記述されている場合でも、正常性プローブのプロトコルには TCP が使用されます。<br>TCP プローブでは、対象の TCP ポートへの疎通性のみをチェックします。<br>HTTP/HTTPS のリクエスト/レスポンスの成否や、レスポンスの内容 (エラーステータスであるかどうか) は、プローブの結果に影響をしません。 </p><p>一方 Kubernetes &gt; 1.24 では、<code>spec.ports.appProtocol</code> に <code>http (または　https)</code>が記述されていると、正常性プローブのプロトコルは <code>http (または https)</code> に設定されます。<br>また、アノテーションでプローブのリクエスト パスが設定されていない場合には、既定で <code>/</code> が使用されます。<br>AKS クラスターで稼働しているアプリケーションが、<code>/</code> のパスでリクエストを受け付けていない場合や、<code>/</code> にアクセスした結果、エラーステータスの HTTP レスポンスを返した場合には、正常性プローブが失敗します。 </p><p>このように、Kubernetes バージョンによって、正常性プローブで使用されるプロトコルとパスが異なります。 </p><p>Kubernetes 1.23 では、TCP プロトコルによる疎通チェックによって正常性プローブが成功していたものの、Kubernetes 1.24 にアップグレードしたあとに正常性プローブが HTTP(S) によるチェックに切り替わり、プローブの条件を満たさなくなったことでバックエンドから切り離され、Load Balancer を介したアプリケーションへのアクセスが成功しない事象が発生します。 </p><h2 id="事例-NGINX-Ingress-Controller-にアクセスできなくなる"><a href="#事例-NGINX-Ingress-Controller-にアクセスできなくなる" class="headerlink" title="事例: NGINX Ingress Controller にアクセスできなくなる"></a>事例: NGINX Ingress Controller にアクセスできなくなる</h2><p>NGINX Ingress Controller を使用しているクラスターで、Kubernetes バージョンのアップグレードを実施したあとに、本事象の影響を受ける場合があります。 </p><p>NGINX Ingress Controller では、Ingress でマッピングされていないリクエストは、全て default backend で処理されます。<br>default backend は2つのパスを公開しており、<code>/healthz</code> では HTTP 200 ステータスを返し、<code>/</code> は HTTP 404 ステータスを返します。 </p><blockquote><p>ご参考) NGINX Ingress Controller - Default backend<br><a href="https://kubernetes.github.io/ingress-nginx/user-guide/default-backend/">https://kubernetes.github.io/ingress-nginx/user-guide/default-backend/</a> </p></blockquote><p>Kubernetes 1.23 では、正常性プローブは TCP プロトコルによる疎通チェックのみを行います。<br>そのため、Ingress Controller に用意されているパスや、そのレスポンス内容にかかわらず、TCP ポートに到達できる状態であれば、正常性プローブが成功します。<br>しかし、Kubernetes 1.24 では、<code>spec.ports.appProtocol</code> が <code>http/https</code> の場合、正常性プローブは既定で <code>/</code> へリクエストを送信し、その HTTP レスポンスの結果によってプローブの結果を決定します。<br>default backend の <code>/</code> は HTTP 404 ステータスを返すために、正常性プローブは失敗の状態となり、Load Balancer からバックエンドの AKS ノードにトラフィックが流されなくなるために、アプリケーションへアクセスできなくなる事象が発生します。 </p><p>NGINX Ingress Controller の Helm Chart では、既定で Service の <code>spec.ports.appProtocol</code> を出力するように values.yaml が構成されています。<br>一方、Service のアノテーションは <code>annotations: &#123;&#125;</code> のように、値が空となっていいます。 </p><blockquote><p>ご参考) Helm Chart の該当箇所<br>values.yaml<br><a href="https://github.com/kubernetes/ingress-nginx/blob/f90f37bed66d343e6c57ea981d6c4e90e4955975/charts/ingress-nginx/values.yaml#L460-L468">https://github.com/kubernetes/ingress-nginx/blob/f90f37bed66d343e6c57ea981d6c4e90e4955975/charts/ingress-nginx/values.yaml#L460-L468</a><br>controller-service.yaml テンプレート<br><a href="https://github.com/kubernetes/ingress-nginx/blob/f90f37bed66d343e6c57ea981d6c4e90e4955975/charts/ingress-nginx/templates/controller-service.yaml#L53-L71">https://github.com/kubernetes/ingress-nginx/blob/f90f37bed66d343e6c57ea981d6c4e90e4955975/charts/ingress-nginx/templates/controller-service.yaml#L53-L71</a></p></blockquote><p>そのため、Kubernetes 1.23 以前に NGINX Ingress Controller をインストールしていた場合には、Kubernetes 1.24 にアップグレードする前に、Ingress Controller の Service に対して、プローブのリクエスト パスが <code>/heathz</code> になるように、事前にアノテーションを追加しておく必要があります。 </p><h2 id="NGINX-Ingress-Controller-にアクセスできない事象の再現"><a href="#NGINX-Ingress-Controller-にアクセスできない事象の再現" class="headerlink" title="NGINX Ingress Controller にアクセスできない事象の再現"></a>NGINX Ingress Controller にアクセスできない事象の再現</h2><p>実際に、Kubernetes 1.23 の AKS クラスターに NGINX Ingress Controller をインストールして、その後 Kubernetes 1.24 へアップグレードすることで、本事象の影響を確認します。 </p><p>まず ingress-nginx-controller Service の YAML マニフェストの内容を確認します。<br><code>metadata.annotations</code> に <code>service.beta.kubernetes.io/azure-load-balancer-health-probe-request-path</code> の設定がなく、<code>spec.ports.appProtocol</code> では <code>http/https</code> が使用されていることが確認できました。 </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">svc</span> <span class="string">ingress-nginx-controller</span> <span class="string">-o</span> <span class="string">yaml</span> <span class="string">-n</span> <span class="string">ingress-basic</span> </span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span> </span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">annotations:</span> </span><br><span class="line">    <span class="comment"># リクエスト パスのアノテーションがない </span></span><br><span class="line">    <span class="attr">meta.helm.sh/release-name:</span> <span class="string">ingress-nginx</span> </span><br><span class="line">    <span class="attr">meta.helm.sh/release-namespace:</span> <span class="string">ingress-basic</span> </span><br><span class="line">    <span class="string">…</span> </span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">　<span class="string">…</span> </span><br><span class="line">  <span class="attr">ports:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">appProtocol:</span> <span class="string">http</span>       <span class="comment"># http が指定されている </span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">http</span> </span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">32271</span> </span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span> </span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span> </span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">http</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">appProtocol:</span> <span class="string">https</span>      <span class="comment"># https が指定されている </span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">https</span> </span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30569</span> </span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span> </span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span> </span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">https</span> </span><br></pre></td></tr></table></figure><p>AKS クラスターで使用される Azure Load Balancer のリソースは、kubernetes という名前で、ノードリソースグループ (既定では MC_* という名前) に配置されています。<br>Azure Portal で Load Balancer を開き、左メニューの正常性プローブのページを開きます。<br>プローブの一覧を確認すると、プロトコル がTCP のプローブとなっていることがわかります。 </p><p><img src="/blog/containers/aks-lb-probe-failed-after-upgraded-to-k8s-1.24/aks-lb-probe-failed-after-upgraded-to-k8s-1.24-01.png"></p><p>また、左メニューの分析情報のページを開くと、ネットワーク構成の図が表示され、正常性プローブは成功していることが確認できます。 </p><p><img src="/blog/containers/aks-lb-probe-failed-after-upgraded-to-k8s-1.24/aks-lb-probe-failed-after-upgraded-to-k8s-1.24-02.png"></p><p>そのあと、対象の AKS クラスターの Kubernetes バージョンを 1.24 にアップグレードします。<br>アップグレードをした後に Azure Portal 画面から正常性プローブを確認すると、プロトコルが <code>HTTP/S</code> のプローブが作成されており、リクエスト パスが <code>/</code> に設定されていることが確認できました。<br>この場合、NGINX Ingress Controller の default Backend は、<code>/</code> に対するアクセスに HTTP 404 ステータスを返すため、正常性プローブが失敗してしまいます。 </p><p><img src="/blog/containers/aks-lb-probe-failed-after-upgraded-to-k8s-1.24/aks-lb-probe-failed-after-upgraded-to-k8s-1.24-03.png"></p><p>Azure Portal画面の分析情報の図からも、正常性プローブが失敗していることが確認できます。 </p><p><img src="/blog/containers/aks-lb-probe-failed-after-upgraded-to-k8s-1.24/aks-lb-probe-failed-after-upgraded-to-k8s-1.24-04.png"> </p><h2 id="対応方法"><a href="#対応方法" class="headerlink" title="対応方法"></a>対応方法</h2><p>Kubernetes 1.24 のクラスターで、正常性プローブの状態を回復させる対応方法について説明します。 </p><div class="alert is-important"><p class="alert-title">重要</p><p>AKS で使用される Load Balancer の正常性プローブは、 クラスター上に作成された Service の内容をもとに、自動的に構成される仕組みです。</p><p>そのため、Azure CLI や Azure Portal で Load Balancerを直接変更するのではなく、Service の設定値を変えます。 </p></div><p>Service にアノテーションを追加し、カスタム ヘルスプローブ パスを設定することで、Kubernetes 1.23 から 1.24 へアップグレードした際にも正常性プローブが成功します。 </p><figure class="highlight yaml"><figcaption><span>Service にアノテーションを設定する例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span> </span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">annotations:</span> </span><br><span class="line">    <span class="attr">service.beta.kubernetes.io/azure-load-balancer-health-probe-request-path:</span> <span class="string">/healthz</span>  <span class="comment"># HTTP 200 ステータスを返すパスを指定します </span></span><br><span class="line"><span class="string">…</span> </span><br></pre></td></tr></table></figure><p>Helm を使ってインストールした NGINX Ingress Controller は、<code>helm upgrade</code> コマンドで Service のアノテーションが設定できます。<br><code>helm ugprade</code> コマンドに <code>--set</code> オプションを付与し、<code>controller.service.annotations</code> value の値を <code>&quot;service.beta.kubernetes.io/azure-load-balancer-health-probe-request-path&quot;=/healthz</code> に設定します。 </p><p>すでに Kubernetes 1.24 にアップグレードしたクラスターや、これからアップグレードをするクラスターでは、<code>helm upgrade</code> コマンドでアノテーションを設定しましょう。<br>また、この <code>--set</code> オプションは、新規に Ingress Controller をインストールする際にも、<code>helm install</code> コマンドに付与することで利用できます。<br>今後新規に Ingress Controller をインストールする場合には、オプションでアノテーションの値を指定したうえで、インストールしましょう。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">helm upgrade ingress-nginx ingress-nginx/ingress-nginx \ </span><br><span class="line">  --create-namespace \ </span><br><span class="line">  --namespace <span class="variable">$NAMESPACE</span> \ </span><br><span class="line">  --<span class="built_in">set</span> controller.service.annotations.<span class="string">&quot;service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path&quot;</span>=/healthz </span><br><span class="line">Release <span class="string">&quot;ingress-nginx&quot;</span> has been upgraded. Happy Helming! </span><br><span class="line">NAME: ingress-nginx </span><br><span class="line">LAST DEPLOYED: Mon Jan 16 15:16:54 2023 </span><br><span class="line">NAMESPACE: ingress-basic </span><br><span class="line">STATUS: deployed </span><br><span class="line">REVISION: 2 </span><br><span class="line">TEST SUITE: None </span><br><span class="line">NOTES: </span><br><span class="line">The ingress-nginx controller has been installed. </span><br><span class="line">It may take a few minutes <span class="keyword">for</span> the LoadBalancer IP to be available. </span><br><span class="line">You can watch the status by running <span class="string">&#x27;kubectl --namespace ingress-basic get services -o wide -w ingress-nginx-controller&#x27;</span> </span><br></pre></td></tr></table></figure><p>Service の YAML マニフェストの内容を確認してみましょう。<br><code>metadata.annotations</code> フィールド内に、<code>service.beta.kubernetes.io/azure-load-balancer-health-probe-request-path: /healthz</code> が追加されたことを確認できました。 </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">svc</span> <span class="string">ingress-nginx-controller</span> <span class="string">-o</span> <span class="string">yaml</span> <span class="string">-n</span> <span class="string">ingress-basic</span> </span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span> </span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">annotations:</span> </span><br><span class="line">    <span class="attr">meta.helm.sh/release-name:</span> <span class="string">ingress-nginx</span> </span><br><span class="line">    <span class="attr">meta.helm.sh/release-namespace:</span> <span class="string">ingress-basic</span> </span><br><span class="line">    <span class="attr">service.beta.kubernetes.io/azure-load-balancer-health-probe-request-path:</span> <span class="string">/healthz</span> </span><br><span class="line">  <span class="string">...</span> </span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">　<span class="string">...</span> </span><br><span class="line">  <span class="attr">ports:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">appProtocol:</span> <span class="string">http</span> </span><br><span class="line">    <span class="attr">name:</span> <span class="string">http</span> </span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">32271</span> </span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span> </span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span> </span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">http</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">appProtocol:</span> <span class="string">https</span> </span><br><span class="line">    <span class="attr">name:</span> <span class="string">https</span> </span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30569</span> </span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span> </span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span> </span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">https</span> </span><br></pre></td></tr></table></figure><p>Azure Portal の画面上でも、プローブのリクエスト パスが <code>/</code> から <code>/healthz</code> に変わりました。 </p><p><img src="/blog/containers/aks-lb-probe-failed-after-upgraded-to-k8s-1.24/aks-lb-probe-failed-after-upgraded-to-k8s-1.24-05.png"> </p><p>また、分析情報の画面においても、正常性プローブも成功していることが確認できました。 </p><p><img src="/blog/containers/aks-lb-probe-failed-after-upgraded-to-k8s-1.24/aks-lb-probe-failed-after-upgraded-to-k8s-1.24-06.png"></p><p>このように、<code>HTTP/HTTPS</code> プローブのリクエスト先を、<code>/</code> (404 ステータスが返される) から、<code>/healthz</code> (200 ステータスが返される) に変更することで、正常性プローブの状態を回復させることが確認できました。 </p><p>今回は NGINX Ingress Controller を例に説明をしたため、リクエスト パスは <code>/healthz</code> を指定しました。<br>アプリケーションが用意するヘルスチェック用のエンドポイントは、アプリケーションの実装によってエンドポイントの有無や名称が異なる場合がございます。<br>トラブルシューティングの際は、対象のアプリケーションの仕様・実装をご確認いただき、リクエスト パスをご指定ください。 </p><h2 id="正常性プローブが失敗した時のトラブルシューティング"><a href="#正常性プローブが失敗した時のトラブルシューティング" class="headerlink" title="正常性プローブが失敗した時のトラブルシューティング"></a>正常性プローブが失敗した時のトラブルシューティング</h2><p>さいごに、正常性プローブが成功しない場合の、一般的なトラブルシューティング観点について紹介します。 </p><h3 id="1-ノードの-VM-インスタンスが起動しているか？"><a href="#1-ノードの-VM-インスタンスが起動しているか？" class="headerlink" title="1. ノードの VM インスタンスが起動しているか？"></a>1. ノードの VM インスタンスが起動しているか？</h3><p>Load Balancer の正常性プローブは、バックエンドプールのインスタンスの状態を監視しています。<br>インスタンスが起動していない場合にはヘルスチェックのリクエストが成功しないことが想定されますので、プローブの失敗を検知した際は、VM インスタンスが正常に起動しているかを確認します。<br>AKS では、ノードのステータスが NotReady となっていないかをあわせて確認しましょう。 </p><h3 id="2-NodePort-および正常性プローブのリクエスト-パス"><a href="#2-NodePort-および正常性プローブのリクエスト-パス" class="headerlink" title="2. NodePort および正常性プローブのリクエスト パス"></a>2. NodePort および正常性プローブのリクエスト パス</h3><p>Load Balancer の正常性プローブが、AKS に作成した Service の設定値と一致しているかを確認します。<br>本記事で上述したように、プローブで利用するプロトコルと、プローブのリクエスト パスが正しいかを確認しましょう。 </p><p>また、type LoadBalancer の Service を作成すると、各ノードに NodePort のポートが設定されます。ポート番号は既定で 30000-32767 の範囲となります。<br>Kubectl get svc コマンドで Service 名と NodePort のポート番号を確認し、プローブのリクエスト先と一致しているかを確認しましょう。 </p><h3 id="3-Service-の-Selector-と-Pod-の-label"><a href="#3-Service-の-Selector-と-Pod-の-label" class="headerlink" title="3. Service の Selector と Pod の label"></a>3. Service の Selector と Pod の label</h3><p>Service で指定している selector が、Pod に設定されている label と一致しているかを確認します。<br>また、selector/label が一致している場合は、Pod が正常に稼働しているかどうかを確認します。 </p><h3 id="4-Load-Balancer-からの正常性プローブの通信をブロックしていないかどうか"><a href="#4-Load-Balancer-からの正常性プローブの通信をブロックしていないかどうか" class="headerlink" title="4. Load Balancer からの正常性プローブの通信をブロックしていないかどうか"></a>4. Load Balancer からの正常性プローブの通信をブロックしていないかどうか</h3><p>正常性プローブの設定に問題がなく、ノードや Pod が起動しているにもかかわらず、正常性プローブが失敗している場合には、Load Balancer から送信された正常性プローブの通信がブロックされている可能性が考えられます。 </p><p>NetworkPolicyなどでネットワーク通信を制限している場合には、Load Balancer からの正常性プローブの通信 (送信元が 168.63.129.16) をブロックしていないか確認します。 </p><blockquote><p>ご参考) Azure Load Balancer の正常性プローブの状態に関するトラブルシューティング<br>「原因 3:ファイアウォール、またはネットワーク セキュリティ グループが Load Balancer バックエンド プール VM 上のポートをブロックしている」をご参照ください。<br><a href="https://learn.microsoft.com/ja-jp/azure/load-balancer/load-balancer-troubleshoot-health-probe-status">https://learn.microsoft.com/ja-jp/azure/load-balancer/load-balancer-troubleshoot-health-probe-status</a> </p></blockquote><p>また、Azure Portal の画面では、Load Balancerのメトリックで、正常性プローブの状態を確認できます。<br><code>Health Probe Status</code> メトリックの値から、過去の正常性プローブの状態を確認できますので、事象の発生や解消のタイミングを確認する際にご活用ください。 </p><p><img src="/blog/containers/aks-lb-probe-failed-after-upgraded-to-k8s-1.24/aks-lb-probe-failed-after-upgraded-to-k8s-1.24-07.png"></p><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>この記事では、AKS の Kubernetes バージョンを 1.24 にアップグレードした際に、Load Balancer Service の正常性プローブが成功しなくなる事象と、その対処方法について解説しました。<br>Kubernetes バージョンのアップグレード作業や、Load Balancer サービスへのアクセスが成功しない場合のトラブルシューティングのご参考にいただけますと幸いでございます。 </p><p>本稿が少しでも皆様のご参考となれば幸いです。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポートチームの小沢です。 &lt;/p&gt;
&lt;p&gt;AKS の Kubernetes バージョンを 1.24 へアップグレードをした際に、Azure Load Balancer の正常性プローブがTCPプロ―ブから HTTP/HTTPS プローブに変更されることがあります。&lt;br&gt;本記事では、プローブの構成が変更された理由と影響、および対応方法について紹介します。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="Containers" scheme="https://jpaztech.github.io/blog/tags/Containers/"/>
    
    <category term="Azure Kubernetes Service (AKS)" scheme="https://jpaztech.github.io/blog/tags/Azure-Kubernetes-Service-AKS/"/>
    
  </entry>
  
  <entry>
    <title>Project Flash : Azure 仮想マシンの可用性の監視を高める</title>
    <link href="https://jpaztech.github.io/blog/vm/vm-availability-monitoring-with-project-flash/"/>
    <id>https://jpaztech.github.io/blog/vm/vm-availability-monitoring-with-project-flash/</id>
    <published>2023-01-06T03:00:00.000Z</published>
    <updated>2023-08-18T00:59:11.766Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポート チームの鳥越です。</p><p>2022年に Azure 仮想マシンの可用性の監視を進化するプロジェクトである Project Flash について、以下のブログで紹介されました。</p><blockquote><p> <strong>Project Flash で Azure 仮想マシンの可用性の監視を進化させる</strong><br> <a href="https://azure.microsoft.com/ja-jp/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash/">https://azure.microsoft.com/ja-jp/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash/</a></p></blockquote><p>このプロジェクトは Azure 仮想マシンに対して、お客様の可用性監視ニーズを満たすために、次のようなことが行えるように進められております。</p><ul><li>VM の可用性障害 (VM のリブートや再起動のほか、ネットワーク ドライバーの更新によるアプリケーションのフリーズ、30 秒間のホスト OS の更新など) に関する正確で実用的なデータ、および障害の詳細 (プラットフォームのものかユーザー操作によるものか、リブートかフリーズか、計画的か非計画的かなど) を入手する。</li><li>VM の可用性の傾向を分析してアラートを生成し、迅速なデバッグと前月比のレポート作成を実現する。</li><li>データを定期的かつ大規模に監視し、カスタム ダッシュボードを作成して、すべてのリソースの最新の可用性状態について常に最新の情報を提供する。</li><li>影響を受けた VM、ダウンタイムの原因および期間、結果的な修正などの詳細を示す自動根本原因分析 (RCA) を受け取り、ターゲットを絞った調査および事後分析を行えるようにする。</li><li>VM の可用性に重大な変化があった場合、即座に通知を受け取り、迅速に修復アクションをトリガーし、エンドユーザーへの影響を防止する。</li><li>刻々と変化するワークロードの感度やフェールオーバーのニーズに基づき、プラットフォームの回復ポリシーを動的に調整し、自動化する。</li></ul><p>その中で、上記ブログではプレビューであった <a href="https://learn.microsoft.com/ja-jp/azure/governance/resource-graph/overview">Azure Resource Graph</a> を用いた VM の可用性情報の監視が GA として公開され、Azure Monitor による VM 可用性メトリックがパブリック プレビューとして公開されました。</p><blockquote><p> <strong>New Project Flash Update: Advancing Azure Virtual Machine availability monitoring</strong><br> <a href="https://azure.microsoft.com/en-us/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash-update/">https://azure.microsoft.com/en-us/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash-update/</a></p></blockquote><p>このブログでは、Azure Resource Graph を用いた VM の可用性情報がどのように利用できるのかを解説します。<br>本内容がお客様の VM の監視に少しでもお役に立てられれば幸いです。</p><span id="more"></span><hr><h2 id="Azure-Resource-Graph-を用いたVMの可用性情報の監視"><a href="#Azure-Resource-Graph-を用いたVMの可用性情報の監視" class="headerlink" title="Azure Resource Graph を用いたVMの可用性情報の監視"></a>Azure Resource Graph を用いたVMの可用性情報の監視</h2><p>Azure Portal より <a href="https://learn.microsoft.com/ja-jp/azure/governance/resource-graph/first-query-portal">Azure Resource Graph エクスプローラー</a>をご利用いただけます。<br>Azure Resource Graph エクスプローラーの画面を開き、テーブルから <code>healthresources</code> を選択します。</p><p><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-01.png"></p><p>たとえば、次のようなクエリで実行します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">healthresources</span><br><span class="line">| where id contains &quot;eda570ec&quot; //This is subscription id</span><br><span class="line">| project id, type, location, properties</span><br></pre></td></tr></table></figure><div class="alert is-success"><p class="alert-title">ヒント</p><p>Azure Resource Graph では、<a href="https://learn.microsoft.com/ja-jp/azure/data-explorer/kusto/query/">Kusto Query Language (KQL) クエリ</a>を用いて、情報を出力することが可能です。</p><p>上記は <a href="https://learn.microsoft.com/ja-jp/azure/data-explorer/kusto/query/whereoperator">where 演算子</a>で <code>id</code> の中に <code>&quot;eba570ec&quot;</code> があるものに限定して、<a href="https://learn.microsoft.com/ja-jp/azure/data-explorer/kusto/query/projectoperator">project 演算子</a>で表示される項目を記載しています。  </p></div><p>実行後、次のような結果を得ることができます。</p><p><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-02.png"></p><p>右側の詳細の表示を選択することで値を見やすく見ることが可能となります。</p><p><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-03.png"></p><p>この <code>healthresources</code> テーブルには次の項目が存在します。</p><ul><li><code>&quot;microsoft.resourcehealth/availabilitystatuses&quot;</code></li><li><code>&quot;microsoft.resourcehealth/resourceannotations&quot;</code></li></ul><p>それぞれについて紹介します。</p><p><code>&quot;microsoft.resourcehealth/availabilitystatuses&quot;</code> は、Azure プラットフォームによって実行された正常性チェックに基づいて、VM の最新の可用性状態を示します。<br>VM に対して現在出力されている可用性の状態を次に示します。</p><ul><li><strong>available</strong>: VM は期待どおりに稼働しています。</li><li><strong>unavailable</strong>: VM の正常な機能の中断が検出されたため、アプリケーションは期待どおりに実行されません。</li><li><strong>unknown</strong>: プラットフォームは VM の正常性を正確に検出できません。ユーザーは通常、数分後に更新された状態を確認できます。</li></ul><blockquote><p>ご参考情報:<br><strong>Resource Health の概要</strong><br><a href="https://learn.microsoft.com/ja-jp/azure/service-health/resource-health-overview">https://learn.microsoft.com/ja-jp/azure/service-health/resource-health-overview</a><br>　<br><strong>Microsoft.compute/virtualmachines</strong><br><a href="https://learn.microsoft.com/ja-jp/azure/service-health/resource-health-checks-resource-types#microsoftcomputevirtualmachines">https://learn.microsoft.com/ja-jp/azure/service-health/resource-health-checks-resource-types#microsoftcomputevirtualmachines</a></p></blockquote><p><code>&quot;microsoft.resourcehealth/resourceannotations&quot;</code>は、VM の可用性に変化があった場合、必要な障害属性を詳細に説明することで、ユーザーが必要に応じて状態を確認調査し、軽減できるようにします。</p><ul><li><strong>Downtime Annotations</strong>: プラットフォームが VM の可用性が Unavailable に遷移したことを検出すると発行されます。<ul><li>たとえば、予期しないホストのクラッシュ、リブートによる修復操作時など</li></ul></li><li><strong>Informational Annotations</strong>: VM の可用性に影響を与えない Azure 基盤に対する処理実施時に発行されます。<ul><li>VM の割り当て / 停止 / 削除 / 開始など</li><li>通常、これに対するお客様の追加アクションは必要ありません。</li></ul></li><li><strong>Degraded Annotations</strong>: VM の可用性が危険にさらされていることが検出されると発行されます。<ul><li>たとえば、故障予測モデルが、任意の時点で VM を再起動させる可能性のあるハードウェア・コンポーネントの劣化を予測した場合など</li><li>予期せぬデータ損失やダウンタイムを避けるため、アノテーション メッセージで指定された期限までに再デプロイするよう強く求めます。</li></ul></li></ul><blockquote><p>ご参考情報:<br><strong>Resource Health 仮想マシンの正常性に関する注釈</strong><br><a href="https://learn.microsoft.com/ja-jp/azure/service-health/resource-health-vm-annotation">https://learn.microsoft.com/ja-jp/azure/service-health/resource-health-vm-annotation</a></p></blockquote><p>なお、VM の停止 (割り当て解除) を行った場合には、次のような アノテーション イベントを検知することが可能となります。</p><p><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-04.png"></p><p>これらを用いることによりお客様の仮想マシンの可用性の状態を把握することが可能となります。</p><div class="alert is-info"><p class="alert-title">Note</p><p>将来的には、この HealthResources データセットに表示されるアノテーション・メタデータについて複数の機能強化が予定されています。</p><p>これらの機能強化により、ユーザーはより豊富な障害属性に確認することができるようになり、障害への対応策を決定的に準備することができるようになります。</p><p>これと並行して、履歴のルックバック期間を最低 30 日間に延長し、ユーザーが VM の可用性の過去の変化を包括的に追跡できるようにすることを目標としています。</p></div><h2 id="HealthResources-に対する便利な-クエリ"><a href="#HealthResources-に対する便利な-クエリ" class="headerlink" title="HealthResources に対する便利な クエリ"></a>HealthResources に対する便利な クエリ</h2><h3 id="可用性の状態とサブスクリプション-ID-別の仮想マシンの数"><a href="#可用性の状態とサブスクリプション-ID-別の仮想マシンの数" class="headerlink" title="可用性の状態とサブスクリプション ID 別の仮想マシンの数"></a>可用性の状態とサブスクリプション ID 別の仮想マシンの数</h3><p>各サブスクリプションの可用性の状態で集計された仮想マシン (種類 Microsoft.Compute/virtualMachines) の数を返します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type =~ &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">| summarize count() by subscriptionId, AvailabilityState = tostring(properties.availabilityState)</span><br></pre></td></tr></table></figure><p>実行結果:<br>Unknown の VM が1台あることが確認できます。<br><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-05.png"></p><h3 id="リソース-ID-別の仮想マシンおよび関連する可用性状態の一覧"><a href="#リソース-ID-別の仮想マシンおよび関連する可用性状態の一覧" class="headerlink" title="リソース ID 別の仮想マシンおよび関連する可用性状態の一覧"></a>リソース ID 別の仮想マシンおよび関連する可用性状態の一覧</h3><p>可用性の状態で集計された仮想マシン (種類 Microsoft.Compute/virtualMachines) の最新の一覧を返します。<br>また、このクエリでは、デバッグと軽減を容易にするため、properties.targetResourceId に基づいて関連付けられているリソース ID も提供されます。<br>可用性の状態は、4 つの値、Available、Unavailable、Degraded、Unknown のいずれかです。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type =~ &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">| summarize by ResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState)</span><br></pre></td></tr></table></figure><p>実行結果:<br>Unknown の対象 VM は先ほど停止を実施した VM であることが確認できました。<br><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-06.png"></p><h3 id="可用性状態と電源状態別の仮想マシンの一覧と、そのリソース-ID-およびリソース-グループ"><a href="#可用性状態と電源状態別の仮想マシンの一覧と、そのリソース-ID-およびリソース-グループ" class="headerlink" title="可用性状態と電源状態別の仮想マシンの一覧と、そのリソース ID およびリソース グループ"></a>可用性状態と電源状態別の仮想マシンの一覧と、そのリソース ID およびリソース グループ</h3><p>仮想マシンの正常性のまとまりのある状態を提供するために、電源状態と可用性状態で集計された仮想マシン (種類 Microsoft.Compute/virtualMachines) の一覧を返します。<br>また、このクエリでは、各エントリに関連付けられているリソース グループとリソース ID に関する詳細も提供され、リソースを詳細に表示できます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Resources</span><br><span class="line">| where type =~ &#x27;microsoft.compute/virtualmachines&#x27;</span><br><span class="line">| project resourceGroup, Id = tolower(id), PowerState = tostring( properties.extended.instanceView.powerState.code)</span><br><span class="line">| join kind=leftouter (</span><br><span class="line">    HealthResources</span><br><span class="line">    | where type =~ &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">    | where tostring(properties.targetResourceType) =~ &#x27;microsoft.compute/virtualmachines&#x27;</span><br><span class="line">    | project targetResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState))</span><br><span class="line">    on $left.Id == $right.targetResourceId</span><br><span class="line">| project-away targetResourceId</span><br><span class="line">| where PowerState != &#x27;PowerState/deallocated&#x27;</span><br></pre></td></tr></table></figure><p>実行結果:<br>停止 (割り当て解除) 状態の VM が除外され表示されます。<br><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-07.png"></p><h3 id="リソース-ID-別の使用できない仮想マシンの一覧"><a href="#リソース-ID-別の使用できない仮想マシンの一覧" class="headerlink" title="リソース ID 別の使用できない仮想マシンの一覧"></a>リソース ID 別の使用できない仮想マシンの一覧</h3><p>可用性の状態で集計された仮想マシン (種類 Microsoft.Compute/virtualMachines) の最新の一覧を返します。<br>表示された一覧では、可用性の状態が “Available” ではない仮想マシンだけが強調表示され、仮想マシンに関する状態すべてについて確実に認識できます。<br>すべての仮想マシンが使用可能な場合は、結果が表示されないことが想定できます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type =~ &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">| where tostring(properties.availabilityState) != &#x27;Available&#x27;</span><br><span class="line">| summarize by ResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState)</span><br></pre></td></tr></table></figure><p>実行結果:<br>Unavailable や Unknown ステータスの VM が表示されます。<br><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-08.png"></p><p>その他、次のようなクエリが利用可能です。</p><h3 id="プラットフォーム主導の計画外の正常性イベントによる影響を受けた可用性状態をもつリソースの一覧"><a href="#プラットフォーム主導の計画外の正常性イベントによる影響を受けた可用性状態をもつリソースの一覧" class="headerlink" title="プラットフォーム主導の計画外の正常性イベントによる影響を受けた可用性状態をもつリソースの一覧"></a>プラットフォーム主導の計画外の正常性イベントによる影響を受けた可用性状態をもつリソースの一覧</h3><p>Azure プラットフォームによって予期せず発生した計画外の中断の影響を受けた仮想マシンの最新の一覧を返します。<br>このクエリは、影響を受けたすべての仮想マシンを ID プロパティで集約し、対応する可用性状態と、特定の中断を要約した関連する注釈 (properties.reason) と共に返します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type == &quot;microsoft.resourcehealth/resourceannotations&quot;</span><br><span class="line">| where  properties.category == &#x27;Unplanned&#x27; and  properties.context != &#x27;Customer Initiated&#x27;</span><br><span class="line">| project ResourceId = tolower(tostring(properties.targetResourceId)), Annotation = tostring(properties.reason)</span><br><span class="line">| join (</span><br><span class="line">    HealthResources</span><br><span class="line">    | where type == &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">    | project ResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState))</span><br><span class="line">    on ResourceId</span><br><span class="line">| project ResourceId, AvailabilityState, Annotation</span><br></pre></td></tr></table></figure><h3 id="使用できないリソースとそれぞれの注釈詳細の一覧"><a href="#使用できないリソースとそれぞれの注釈詳細の一覧" class="headerlink" title="使用できないリソースとそれぞれの注釈詳細の一覧"></a>使用できないリソースとそれぞれの注釈詳細の一覧</h3><p>現在、使用可能な状態ではない仮想マシンの一覧を、ID プロパティで集約して返します。<br>また、このクエリによって、仮想マシンの実際の可用性状態と、使用できない理由を含む関連する詳細も示されます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type == &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">| where  properties.availabilityState != &#x27;Available&#x27;</span><br><span class="line">| project ResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState)</span><br><span class="line">| join ( </span><br><span class="line">     HealthResources</span><br><span class="line">    | where type == &quot;microsoft.resourcehealth/resourceannotations&quot;</span><br><span class="line">    | project ResourceId = tolower(tostring(properties.targetResourceId)), Reason = tostring(properties.reason), Context = tostring(properties.context), Category = tostring(properties.category))</span><br><span class="line">    on ResourceId</span><br><span class="line">| project ResourceId, AvailabilityState, Reason, Context, Category</span><br></pre></td></tr></table></figure><p>実行結果:<br><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-09.png"></p><h3 id="可用性の障害による影響を受けたリージョン内のリソースの数と、その影響の種類"><a href="#可用性の障害による影響を受けたリージョン内のリソースの数と、その影響の種類" class="headerlink" title="可用性の障害による影響を受けたリージョン内のリソースの数と、その影響の種類"></a>可用性の障害による影響を受けたリージョン内のリソースの数と、その影響の種類</h3><p>現在、使用可能な状態ではない仮想マシンの数を、ID プロパティで集約して返します。<br>また、クエリによって示される対応する場所と注釈の詳細には、VM が使用可能な状態ではない原因も含まれます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type == &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">| where  properties.availabilityState != &#x27;Available&#x27;</span><br><span class="line">| project ResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState), Location = location</span><br><span class="line">| join (</span><br><span class="line">    HealthResources</span><br><span class="line">    | where type == &quot;microsoft.resourcehealth/resourceannotations&quot;</span><br><span class="line">    | project ResourceId = tolower(tostring(properties.targetResourceId)), Context = tostring(properties.context), Category = tostring(properties.category), Location = location)</span><br><span class="line">    on ResourceId</span><br><span class="line">| summarize NumResources = count(ResourceId) by Location, Context, Category</span><br></pre></td></tr></table></figure><h3 id="特定の正常性イベントによる影響を受けるリソースの一覧と、影響時間、影響の詳細、可用性の状態、リージョン"><a href="#特定の正常性イベントによる影響を受けるリソースの一覧と、影響時間、影響の詳細、可用性の状態、リージョン" class="headerlink" title="特定の正常性イベントによる影響を受けるリソースの一覧と、影響時間、影響の詳細、可用性の状態、リージョン"></a>特定の正常性イベントによる影響を受けるリソースの一覧と、影響時間、影響の詳細、可用性の状態、リージョン</h3><p>VirtualMachineHostRebootedForRepair 注釈の影響を受ける仮想マシンの一覧を、その ID プロパティで集約して返します。<br>また、このクエリは、仮想マシンの対応する可用性状態、中断の時間、影響の原因を含む注釈の詳細を返します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type == &quot;microsoft.resourcehealth/resourceannotations&quot;</span><br><span class="line">| where properties.AnnotationName contains &#x27;VirtualMachineHostRebootedForRepair&#x27;</span><br><span class="line">| project ResourceId = tolower(tostring(properties.targetResourceId)), Reason = tostring(properties.reason), Context = tostring(properties.context), Category = tostring(properties.category), Location = location, Timestamp = tostring(properties.occurredTime)</span><br><span class="line">| join ( </span><br><span class="line">    HealthResources</span><br><span class="line">    | where type == &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">    | project ResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState), Location = location)</span><br><span class="line">    on ResourceId</span><br><span class="line">| project ResourceId, Reason, Context, Category, AvailabilityState, Timestamp</span><br></pre></td></tr></table></figure><h3 id="計画イベントによる影響を受けたリソースのリージョンごとの一覧"><a href="#計画イベントによる影響を受けたリソースのリージョンごとの一覧" class="headerlink" title="計画イベントによる影響を受けたリソースのリージョンごとの一覧"></a>計画イベントによる影響を受けたリソースのリージョンごとの一覧</h3><p>Azure プラットフォームによって実施された計画的なメンテナンスまたは修復操作の影響を受けた仮想マシンの一覧を、ID プロパティで集約して返します。<br>また、このクエリは、仮想マシンの対応する可用性状態、中断の時間、場所、影響の原因を含む注釈の詳細を返します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type == &quot;microsoft.resourcehealth/resourceannotations&quot;</span><br><span class="line">| where properties.category contains &#x27;Planned&#x27;</span><br><span class="line">| project ResourceId = tolower(tostring(properties.targetResourceId)), Reason = tostring(properties.reason), Location = location, Timestamp = tostring(properties.occuredTime)</span><br><span class="line">| join ( </span><br><span class="line">    HealthResources</span><br><span class="line">    | where type == &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">    | project ResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState), Location = location)</span><br><span class="line">    on ResourceId</span><br><span class="line">| project ResourceId, Reason, AvailabilityState, Timestamp, Location</span><br></pre></td></tr></table></figure><h3 id="計画外のプラットフォーム中断の影響を受けたリソースの一覧と、可用性、電力状態、場所"><a href="#計画外のプラットフォーム中断の影響を受けたリソースの一覧と、可用性、電力状態、場所" class="headerlink" title="計画外のプラットフォーム中断の影響を受けたリソースの一覧と、可用性、電力状態、場所"></a>計画外のプラットフォーム中断の影響を受けたリソースの一覧と、可用性、電力状態、場所</h3><p>Azure プラットフォームによって実施された計画的なメンテナンスまたは修復操作の影響を受けた仮想マシンの一覧を、ID プロパティで集約して返します。<br>また、このクエリによって、仮想マシンの対応する可用性状態、電力状態、場所の詳細も示されます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type =~ &#x27;microsoft.resourcehealth/resourceannotations&#x27;</span><br><span class="line">| where tostring(properties.context) == &#x27;Platform Initiated&#x27; and tostring(properties.category) == &#x27;Planned&#x27;</span><br><span class="line">| project ResourceId = tolower(properties.targetResourceId), Location = location</span><br><span class="line">| join (</span><br><span class="line">    HealthResources</span><br><span class="line">    | where type =~ &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">    | project ResourceId = tolower(properties.targetResourceId), AvailabilityState = tostring(properties.availabilityState), Location = location)</span><br><span class="line">    on ResourceId</span><br><span class="line">| join (</span><br><span class="line">    Resources</span><br><span class="line">    | where type =~ &#x27;microsoft.compute/virtualmachines&#x27;</span><br><span class="line">    | project ResourceId = tolower(id), PowerState = properties.extended.instanceView.powerState.code, Location = location)</span><br><span class="line">    on ResourceId</span><br><span class="line">| project ResourceId, AvailabilityState, PowerState, Location</span><br></pre></td></tr></table></figure><p>次に Azure Monitor による VM の可用性メトリックを紹介します。</p><h2 id="Azure-Monitor-による-VM-の可用性メトリック-Preview"><a href="#Azure-Monitor-による-VM-の可用性メトリック-Preview" class="headerlink" title="Azure Monitor による VM の可用性メトリック (Preview)"></a>Azure Monitor による VM の可用性メトリック (Preview)</h2><p>VM 可用性についてのメトリックが取得できるようになりました。<br>このメトリックを用いることで、可用性が低下した場合に、しきい値ベースのメトリックアラートを設定し、適切な軽減措置を迅速にトリガーするよう設定することが可能となりました。</p><p><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-10.png"><br><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-11.png"></p><p>上記の結果より、VM を停止したことで可用性の低下が発生したことを確認できます。</p><h2 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h2><p>Azure ではこの Project Flash を通じて、お客様のエクスペリエンスの継続的な改善を目的とし監視プラットフォームの強化を実施してまいります。</p><p>以前は Azure 基盤で発生した問題について、何が起こったのかわからず大きな不安を抱えることもあったかと存じます。</p><p>Azure 基盤で発生した問題について、お客様の視認性を強化し、可能な限り迅速に情報提供をすることで、お客様への影響とご不安を最小限にするように引き続き信頼性向上に努めてまいります。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポート チームの鳥越です。&lt;/p&gt;
&lt;p&gt;2022年に Azure 仮想マシンの可用性の監視を進化するプロジェクトである Project Flash について、以下のブログで紹介されました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; &lt;strong&gt;Project Flash で Azure 仮想マシンの可用性の監視を進化させる&lt;/strong&gt;&lt;br&gt; &lt;a href=&quot;https://azure.microsoft.com/ja-jp/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash/&quot;&gt;https://azure.microsoft.com/ja-jp/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;このプロジェクトは Azure 仮想マシンに対して、お客様の可用性監視ニーズを満たすために、次のようなことが行えるように進められております。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VM の可用性障害 (VM のリブートや再起動のほか、ネットワーク ドライバーの更新によるアプリケーションのフリーズ、30 秒間のホスト OS の更新など) に関する正確で実用的なデータ、および障害の詳細 (プラットフォームのものかユーザー操作によるものか、リブートかフリーズか、計画的か非計画的かなど) を入手する。&lt;/li&gt;
&lt;li&gt;VM の可用性の傾向を分析してアラートを生成し、迅速なデバッグと前月比のレポート作成を実現する。&lt;/li&gt;
&lt;li&gt;データを定期的かつ大規模に監視し、カスタム ダッシュボードを作成して、すべてのリソースの最新の可用性状態について常に最新の情報を提供する。&lt;/li&gt;
&lt;li&gt;影響を受けた VM、ダウンタイムの原因および期間、結果的な修正などの詳細を示す自動根本原因分析 (RCA) を受け取り、ターゲットを絞った調査および事後分析を行えるようにする。&lt;/li&gt;
&lt;li&gt;VM の可用性に重大な変化があった場合、即座に通知を受け取り、迅速に修復アクションをトリガーし、エンドユーザーへの影響を防止する。&lt;/li&gt;
&lt;li&gt;刻々と変化するワークロードの感度やフェールオーバーのニーズに基づき、プラットフォームの回復ポリシーを動的に調整し、自動化する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;その中で、上記ブログではプレビューであった &lt;a href=&quot;https://learn.microsoft.com/ja-jp/azure/governance/resource-graph/overview&quot;&gt;Azure Resource Graph&lt;/a&gt; を用いた VM の可用性情報の監視が GA として公開され、Azure Monitor による VM 可用性メトリックがパブリック プレビューとして公開されました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; &lt;strong&gt;New Project Flash Update: Advancing Azure Virtual Machine availability monitoring&lt;/strong&gt;&lt;br&gt; &lt;a href=&quot;https://azure.microsoft.com/en-us/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash-update/&quot;&gt;https://azure.microsoft.com/en-us/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash-update/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;このブログでは、Azure Resource Graph を用いた VM の可用性情報がどのように利用できるのかを解説します。&lt;br&gt;本内容がお客様の VM の監視に少しでもお役に立てられれば幸いです。&lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Monitoring / Alert" scheme="https://jpaztech.github.io/blog/tags/Monitoring-Alert/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
  </entry>
  
  <entry>
    <title>Classic VM から ARM への移行についての注意事項 (VM、ストレージ編)</title>
    <link href="https://jpaztech.github.io/blog/vm/migrate_classic_vm_and_storage/"/>
    <id>https://jpaztech.github.io/blog/vm/migrate_classic_vm_and_storage/</id>
    <published>2022-12-29T08:30:00.000Z</published>
    <updated>2023-08-18T00:59:11.650Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポート チームの鳥越です。<br>2014年に Azure Resource Manager モデルがリリースされており、リタイアがアナウンスされた 2020 年 7 月時点ですでに 90% が Azure Resource Manager モデルで利用されておりました。</p><p>Azure 初期で利用されておりました Azure Service Manager (ASM) を介した IaaS 仮想マシン (VM) の管理を 2020 年 2 月 28 日 に 非推奨として <strong>2023 年 9 月 6 日</strong> に完全に廃止される予定です。</p><blockquote><p>■ ご参考: Migrate your IaaS resources to Azure Resource Manager by September 6, 2023<br><a href="https://learn.microsoft.com/en-us/azure/virtual-machines/classic-vm-deprecation">https://learn.microsoft.com/en-us/azure/virtual-machines/classic-vm-deprecation</a><br>(ご参考: 日本語 URL)<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/classic-vm-deprecation">https://learn.microsoft.com/ja-jp/azure/virtual-machines/classic-vm-deprecation</a></p></blockquote><div class="alert is-important"><p class="alert-title">重要</p><p><strong>(2023/01/27 Update)</strong>: 当初、2023 年 3 月 1日とご説明しておりました ASM の廃止は <strong>2023 年 9 月 1 日</strong> に延期されました。</p><p>その後、2023 年 9 月 6 日まで更に延期されましたが、現在これ以上の延期は計画されておりません。</p></div><p>そのため、これから 2023 年 9 月 6 日までに移行計画を立てていらっしゃるお客様に対して、移行がスムーズに行えるようにあらかじめ確認しておくべきポイントをお纏めしました。</p><p>本内容がお客様の移行作業に少しでもお役に立てば幸いでございます。</p><span id="more"></span><hr><h2 id="移行作業の全体像"><a href="#移行作業の全体像" class="headerlink" title="移行作業の全体像"></a>移行作業の全体像</h2><blockquote><p>■ ご参考: プラットフォームでサポートされているクラシックから Azure Resource Manager への移行に関する技術的な詳細<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/migration-classic-resource-manager-deep-dive">https://learn.microsoft.com/ja-jp/azure/virtual-machines/migration-classic-resource-manager-deep-dive</a></p></blockquote><p>Azure ではリソースの管理操作にかかわる Control Plane と実際のリソースに対する Data Plane が存在します。<br>ASM (Azure Service Manager) から ARM (Azure Resource Manager) への移行は Control Plane に対する操作となります。</p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image1.png"></p><p>原則として Data Plane はそのまま使用可能なので、ユーザー目線から見た場合、VM の動作状況や、ストレージアカウント上へのアクセスには影響がないように見えます。<br>しかしながら、移行非対応の機能のための構成変更に伴い、ユーザー目線でのダウンタイムが発生する可能性はございます。</p><p>たとえば、クラシック VM においては、「仮想ネットワークに配置されていない VM」という構成があり得ましたが、ARM における VM ではすべての仮想マシンが仮想ネットワーク上に配置されます。<br>従いまして、仮想ネットワークに配置されていないクラシック VM を、ARM に移行する場合、移行手順の途上で VM の停止が伴います。</p><p>また、移行中は、管理系の操作が行えないことも合わせてご理解いただく必要がございます。<br>例えば、VMのサイズ変更、開始、停止、再起動、再デプロイ、ディスクの構成変更、ネットワーク的な構成変更が実施できなくなる操作となります。<br>そのため、移行で問題が生じたときに、VM 側の操作ができないといった事態に陥る可能性もゼロではございません。</p><h3 id="移行をサポートしていないリソース"><a href="#移行をサポートしていないリソース" class="headerlink" title="移行をサポートしていないリソース"></a>移行をサポートしていないリソース</h3><p><img src="/blog/vm/migrate_classic_vm_and_storage/image2.png"></p><p><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/migration-classic-resource-manager-overview#unsupported-features-and-configurations">https://learn.microsoft.com/ja-jp/azure/virtual-machines/migration-classic-resource-manager-overview#unsupported-features-and-configurations</a></p><hr><p>全体的な移行の流れは下記の図のようになります。</p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image3.png"></p><h2 id="移行の事前準備-重要"><a href="#移行の事前準備-重要" class="headerlink" title="移行の事前準備 (重要)"></a>移行の事前準備 (重要)</h2><h3 id="1-クラシックリソースの操作に対応した、クラシック用の-Azure-PowerShell-を実施前にご用意ください。"><a href="#1-クラシックリソースの操作に対応した、クラシック用の-Azure-PowerShell-を実施前にご用意ください。" class="headerlink" title="(1) クラシックリソースの操作に対応した、クラシック用の Azure PowerShell を実施前にご用意ください。"></a>(1) クラシックリソースの操作に対応した、クラシック用の Azure PowerShell を実施前にご用意ください。</h3><p>クラシックリソース用の Azure PowerShell コマンドは、現行の ARM 対応の <code>AzureRM</code> や <code>Az</code> というモジュールではなく、<code>Azure</code> という名称で配布されています。<br>インストール方法は、以下の技術文書をご参照ください。</p><blockquote><p>■ ご参考: Azure PowerShell Service Management モジュールのインストール<br><a href="https://learn.microsoft.com/ja-jp/powershell/azure/servicemanagement/install-azure-ps?view=azuresmps-4.0.0">https://learn.microsoft.com/ja-jp/powershell/azure/servicemanagement/install-azure-ps?view=azuresmps-4.0.0 </a></p></blockquote><p>なお、クラシック Azure PowerShell によるリソース管理には、Azure サブスクリプションにおける <strong>従来の管理者</strong> の割り当てが必要になることにご注意ください。</p><blockquote><p>■ ご参考: Azure の従来のサブスクリプション管理者<br><a href="https://learn.microsoft.com/ja-jp/azure/role-based-access-control/classic-administrators">https://learn.microsoft.com/ja-jp/azure/role-based-access-control/classic-administrators</a></p></blockquote><p>多くの場合、移行が失敗した場合には、コマンドベースで回復作業を実施します。<br>そのため、事前にクラシックリソース用 Azure PowerShell を利用いただける環境をご用意いただけますと幸いです。</p><h3 id="2-クラシック-Azure-PowerShell-を用いて事前チェックをお願いいたします"><a href="#2-クラシック-Azure-PowerShell-を用いて事前チェックをお願いいたします" class="headerlink" title="(2) クラシック Azure PowerShell を用いて事前チェックをお願いいたします"></a>(2) クラシック Azure PowerShell を用いて事前チェックをお願いいたします</h3><p>たとえば、よくあるお問い合わせとして、ストレージアカウント内にディスクリソースが存在するためクラシックストレージアカウントの移行に失敗するといったお問い合わせがございます。</p><p>Portal 側の手順では、この点が考慮されていない部分がございますので、下記のように PowerShell を利用してチェックをいただけますと幸いです。<br>VM の移行が完了しておらず、クラシックストレージアカウントに VM で利用中のディスクリソースが残ってしまっていないかなどのチェック方法は以下のとおりです。</p><h4 id="2-1-ディスクがストレージ-アカウントに格納されている仮想マシンを移行する。"><a href="#2-1-ディスクがストレージ-アカウントに格納されている仮想マシンを移行する。" class="headerlink" title="(2-1) ディスクがストレージ アカウントに格納されている仮想マシンを移行する。"></a>(2-1) ディスクがストレージ アカウントに格納されている仮想マシンを移行する。</h4><p>次のコマンドは、ストレージ アカウント内のすべての VM ディスクの RoleName および DiskName プロパティを返します。RoleName はディスクが接続される仮想マシンの名前です。<br>このコマンドでディスクが返される場合、ストレージアカウントを移行する前にこれらのディスクが接続されている仮想マシンが移行されている必要があります。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$storageAccountName</span> = <span class="string">&#x27;yourStorageAccountName&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Get-AzureDisk</span> | <span class="built_in">where-Object</span> &#123;<span class="variable">$_</span>.MediaLink.Host.Contains(<span class="variable">$storageAccountName</span>)&#125; | <span class="built_in">Select-Object</span> <span class="literal">-ExpandProperty</span> AttachedTo <span class="literal">-Property</span> DiskName | <span class="built_in">Format-List</span> <span class="literal">-Property</span> RoleName, DiskName</span><br></pre></td></tr></table></figure><h4 id="2-2-ストレージ-アカウントに格納されている、接続されていない-VM-ディスクを削除する。"><a href="#2-2-ストレージ-アカウントに格納されている、接続されていない-VM-ディスクを削除する。" class="headerlink" title="(2-2) ストレージ アカウントに格納されている、接続されていない VM ディスクを削除する。"></a>(2-2) ストレージ アカウントに格納されている、接続されていない VM ディスクを削除する。</h4><p>次のコマンドを使用して、ストレージ アカウントの接続されていない VM のディスクを探します。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$storageAccountName</span> = <span class="string">&#x27;yourStorageAccountName&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Get-AzureDisk</span> | <span class="built_in">where-Object</span></span><br><span class="line">&#123;<span class="variable">$_</span>.MediaLink.Host.Contains(<span class="variable">$storageAccountName</span>)&#125; | <span class="built_in">Where-Object</span> <span class="literal">-Property</span> AttachedTo <span class="operator">-EQ</span> <span class="variable">$null</span> | <span class="built_in">Format-List</span> <span class="literal">-Property</span> DiskName</span><br></pre></td></tr></table></figure><p>上記のコマンドでディスクが返された場合、次のコマンドを使用してこれらのディスクを削除します。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Remove-AzureDisk</span> <span class="literal">-DiskName</span> <span class="string">&#x27;yourDiskName&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-ストレージ-アカウントに格納されている-VM-イメージを削除する。"><a href="#2-3-ストレージ-アカウントに格納されている-VM-イメージを削除する。" class="headerlink" title="(2-3) ストレージ アカウントに格納されている VM イメージを削除する。"></a>(2-3) ストレージ アカウントに格納されている VM イメージを削除する。</h4><p>次のコマンドは、ストレージ アカウントに格納されたすべての VM イメージと OS ディスクを返します。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-AzureVmImage</span> | <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span>.OSDiskConfiguration.MediaLink <span class="operator">-ne</span> <span class="variable">$null</span> <span class="operator">-and</span> <span class="variable">$_</span>.OSDiskConfiguration.MediaLink.Host.Contains(<span class="variable">$storageAccountName</span>)&#125; | <span class="built_in">Select-Object</span> <span class="literal">-Property</span> ImageName, ImageLabel</span><br></pre></td></tr></table></figure><p>次のコマンドは、ストレージ アカウントに格納されたすべての VM イメージとデータ ディスクを返します。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-AzureVmImage</span> | <span class="built_in">Where-Object</span> &#123;<span class="variable">$_</span>.DataDiskConfigurations <span class="operator">-ne</span> <span class="variable">$null</span> <span class="operator">-and</span> (<span class="variable">$_</span>.DataDiskConfigurations | <span class="built_in">Where-Object</span> &#123;<span class="variable">$_</span>.MediaLink <span class="operator">-ne</span> <span class="variable">$null</span> <span class="operator">-and</span> <span class="variable">$_</span>.MediaLink.Host.Contains(<span class="variable">$storageAccountName</span>)&#125;).Count <span class="operator">-gt</span> <span class="number">0</span> &#125; | <span class="built_in">Select-Object</span> <span class="literal">-Property</span> ImageName, ImageLabel</span><br></pre></td></tr></table></figure><p>次のコマンドを使用して、上記のコマンドによって返されるすべての VM イメージを削除します。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Remove-AzureVMImage</span> <span class="literal">-ImageName</span> <span class="string">&#x27;yourImageName&#x27;</span>  </span><br></pre></td></tr></table></figure><hr><h2 id="検証フェーズ-Validate"><a href="#検証フェーズ-Validate" class="headerlink" title="検証フェーズ (Validate)"></a>検証フェーズ (Validate)</h2><p>検証フェーズでは移行対象リソースが前提条件を満たしているのかチェックします。<br>ただし、この検証フェーズですべての前提条件がチェックされる訳ではない点に注意が必要です。</p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image4.png"><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/migration-classic-resource-manager-deep-dive#checks-not-done-in-the-validate-operation">https://learn.microsoft.com/ja-jp/azure/virtual-machines/migration-classic-resource-manager-deep-dive#checks-not-done-in-the-validate-operation</a></p><h2 id="準備フェーズ-Prepare"><a href="#準備フェーズ-Prepare" class="headerlink" title="準備フェーズ (Prepare)"></a>準備フェーズ (Prepare)</h2><p>準備フェーズでは、リソースの実体に対して、ASM 側にも ARM 側にもリソースが表示されるようになります。</p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image5.png"></p><p>このタイミングで管理系操作はロックされるため、Commit で実行フェーズに進むか Abort で強制終了するかのどちらかの作業が必要となります。</p><h3 id="準備フェーズでの重要な注意点"><a href="#準備フェーズでの重要な注意点" class="headerlink" title="準備フェーズでの重要な注意点"></a>準備フェーズでの重要な注意点</h3><p>注意点となりますが、ASM から ARM への移行に際し VM 単位で実施する場合に、Prepare -&gt; Commit の間に 4 分間の間隔を空けないと移行処理が失敗するという報告がございます。</p><p>このような状態に陥った場合、Portal での対処ができず、先にご案内しましたクラシック用の PowerShell により以下のコマンドで Commit を実行いただく必要がございます。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$serviceName</span> = <span class="string">&quot;My Service&quot;</span>   <span class="comment"># クラシック VM が配置されているクラウドサービス名に置き換えてください</span></span><br><span class="line"><span class="variable">$deployment</span> = <span class="built_in">Get-AzureDeployment</span> <span class="literal">-ServiceName</span> <span class="variable">$serviceName</span></span><br><span class="line"><span class="variable">$deploymentName</span> = <span class="variable">$deployment</span>.DeploymentName</span><br><span class="line"><span class="built_in">Move-AzureService</span> <span class="literal">-Commit</span> <span class="literal">-ServiceName</span> <span class="variable">$serviceName</span> <span class="literal">-DeploymentName</span> <span class="variable">$deploymentName</span></span><br></pre></td></tr></table></figure><h2 id="実行フェーズ-Commit"><a href="#実行フェーズ-Commit" class="headerlink" title="実行フェーズ (Commit)"></a>実行フェーズ (Commit)</h2><p>実行フェーズにてリソースの実体に対してクラシック側の参照が切り離される動作となります。</p><p>これにより ARM への移行が完了します。</p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image6.png"></p><hr><h2 id="ASM-から-ARM-に移行される際の-FAQ"><a href="#ASM-から-ARM-に移行される際の-FAQ" class="headerlink" title="ASM から ARM に移行される際の FAQ"></a>ASM から ARM に移行される際の FAQ</h2><p>公式ドキュメントとしては以下のご用意がございます。</p><blockquote><p>■ ご参考: クラシックから Azure Resource Manager への移行に関してよく寄せられる質問<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/migration-classic-resource-manager-faq">https://learn.microsoft.com/ja-jp/azure/virtual-machines/migration-classic-resource-manager-faq</a></p></blockquote><p>問題が発生した場合の対処コマンドについては、以下に記載させていただきます。</p><h3 id="Q1-移行の-Abort-はできますか？"><a href="#Q1-移行の-Abort-はできますか？" class="headerlink" title="Q1. 移行の Abort はできますか？"></a>Q1. 移行の Abort はできますか？</h3><p>移行作業をどうしても Abort したい場合には下記コマンドを実施ください。<br>デバッグ出力も併せて表示されますので、何らかのエラーが発生する場合は、デバッグ出力も添えて Azure サポート窓口へのお問い合わせをご検討ください。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$serviceName</span> = <span class="string">&quot;My Service&quot;</span>   <span class="comment"># クラシック VM が配置されているクラウドサービス名に置き換えてください</span></span><br><span class="line"><span class="variable">$deployment</span> = <span class="built_in">Get-AzureDeployment</span> <span class="literal">-ServiceName</span> <span class="variable">$serviceName</span>  </span><br><span class="line"><span class="variable">$deploymentName</span> = <span class="variable">$deployment</span>.DeploymentName  </span><br><span class="line"><span class="built_in">Move-AzureService</span> <span class="literal">-Abort</span> <span class="literal">-ServiceName</span> <span class="variable">$serviceName</span> <span class="literal">-DeploymentName</span> <span class="variable">$deploymentName</span> <span class="literal">-debug</span> <span class="literal">-verbose</span></span><br></pre></td></tr></table></figure><h3 id="Q2-ストレージアカウントを-Azure-PowerShell-で-Commit-する方法はありますか？"><a href="#Q2-ストレージアカウントを-Azure-PowerShell-で-Commit-する方法はありますか？" class="headerlink" title="Q2. ストレージアカウントを Azure PowerShell で Commit する方法はありますか？"></a>Q2. ストレージアカウントを Azure PowerShell で Commit する方法はありますか？</h3><p>移行作業でポータルから操作ができず、Azure PowerShell を利用して Commit が必要なケースが存在します。<br>そのような場合には以下のように Commit の実施をお願いいたします。<br>デバッグ出力も併せて表示されますので、何らかのエラーが発生する場合は、デバッグ出力も添えて Azure サポート窓口へのお問い合わせをご検討ください。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$storageAccountName</span> = <span class="string">&quot;myStorageAccount&quot;</span></span><br><span class="line"><span class="built_in">Move-AzureStorageAccount</span> <span class="literal">-Commit</span> <span class="literal">-StorageAccountName</span> <span class="variable">$storageAccountName</span> <span class="literal">-debug</span> <span class="literal">-verbose</span></span><br></pre></td></tr></table></figure><h3 id="Q3-VNET-を含んだ-VM-の移行で問題が発生したときはどうすればよいですか？"><a href="#Q3-VNET-を含んだ-VM-の移行で問題が発生したときはどうすればよいですか？" class="headerlink" title="Q3. VNET を含んだ VM の移行で問題が発生したときはどうすればよいですか？"></a>Q3. VNET を含んだ VM の移行で問題が発生したときはどうすればよいですか？</h3><p>VNET を含んだ VM の移行については今回割愛しておりますが、移行に問題が発生した際に、PowerShell を利用した切り分け作業の実施が必要となります。</p><p>上記のとおり、PowerShell 環境の事前の準備と問題が発生した際には <code>-debug</code> オプションと <code>-verbose</code> オプションを利用した原因調査の実施が必要となりますのであらかじめご承知おきいただけますと幸いです。</p><h3 id="Q4-移行がスタックした際にクラシック-VM-から新規-の-ARM-の-VM-を手動で作成できますか？"><a href="#Q4-移行がスタックした際にクラシック-VM-から新規-の-ARM-の-VM-を手動で作成できますか？" class="headerlink" title="Q4. 移行がスタックした際にクラシック VM から新規 の ARM の VM を手動で作成できますか？"></a>Q4. 移行がスタックした際にクラシック VM から新規 の ARM の VM を手動で作成できますか？</h3><p>移行が途中でスタックした際には、上述の通り管理操作を行うことができません。<br>そのため、VM の起動再開といった作業が実現できないこととなります。</p><p>この場合、VM で利用されていた VHD を利用して新たに VM を作成することで、スタックの状況を回避することが可能となります。<br>作業としては以下の流れで作業の実施をお願いいたします。</p><h4 id="4-1-コピー先-URL-を準備"><a href="#4-1-コピー先-URL-を準備" class="headerlink" title="(4-1) コピー先 URL を準備"></a>(4-1) コピー先 URL を準備</h4><h5 id="手順A-ARM-仮想マシン用のストレージ-アカウントを作成します。"><a href="#手順A-ARM-仮想マシン用のストレージ-アカウントを作成します。" class="headerlink" title="手順A. ARM 仮想マシン用のストレージ アカウントを作成します。"></a>手順A. ARM 仮想マシン用のストレージ アカウントを作成します。</h5><ol><li>Azure Portal より <strong>[ストレージ アカウント]</strong> を開き、<strong>[追加]</strong> をクリックします。<br>適宜値を設定し、ストレージ アカウントを作成します。</li><li>作成後、<strong>[ストレージ アカウント]</strong> - <strong>[&lt;当該ストレージ アカウント名&gt;]</strong> を選択し、左メニュー <strong>[Blob service]</strong> から <strong>[コンテナー]</strong> を選択します。</li><li><strong>[+ コンテナー]</strong> をクリックし <code>vhds</code> という名前でコンテナーを作成します。</li></ol><h5 id="手順B-VHD-ファイルをコピーするためのコピー先の-SAS-を発行します。"><a href="#手順B-VHD-ファイルをコピーするためのコピー先の-SAS-を発行します。" class="headerlink" title="手順B. VHD ファイルをコピーするためのコピー先の SAS を発行します。"></a>手順B. VHD ファイルをコピーするためのコピー先の SAS を発行します。</h5><ol><li><strong>手順A-1</strong> で作成した <strong>[&lt;当該ストレージ アカウント名&gt;]</strong> を選択し、左メニュー <strong>[設定]</strong> から <strong>[Shared Access Signature]</strong> を選択します。</li><li>適宜設定を行い、<strong>[SAS と接続文字列を生成する]</strong> をクリックします。</li><li><strong>[Blob service の SAS URL]</strong> をテキストエディタ等にコピーしておきます。</li></ol><h5 id="手順C-手順D-3-で取得した-URL-を下記のとおり編集し、テキスト-エディタ等にコピーしておきます。"><a href="#手順C-手順D-3-で取得した-URL-を下記のとおり編集し、テキスト-エディタ等にコピーしておきます。" class="headerlink" title="手順C. 手順D-3 で取得した URL を下記のとおり編集し、テキスト エディタ等にコピーしておきます。"></a>手順C. 手順D-3 で取得した URL を下記のとおり編集し、テキスト エディタ等にコピーしておきます。</h5><p><strong>編集前</strong>: <code>https://&#123;ストレージ アカウント名&#125;.blob.core.windows.net/?&#123;SAS&#125;</code><br><strong>編集後</strong>: <code>https://&#123;ストレージ アカウント名&#125;.blob.core.windows.net/vhds/&#123;コピー後の VHD ファイル名&#125;?&#123;SAS&#125;</code></p><p>コピー後の VHD ファイル名は「.vhd」拡張子となるようにご指定ください。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p>A から C の手順は、当初より公開しております以下の記事にも記載がございます。</p><p>Azure VM からエクスポートした VHD ファイルを用いた複製 VM の作成方法のページにおける</p><p><a href="https://jpaztech.github.io/blog/vm/create-vm-using-vhd/#1-%E3%82%B3%E3%83%94%E3%83%BC%E5%85%88%E3%81%AE%E3%82%B9%E3%83%88%E3%83%AC%E3%83%BC%E3%82%B8-%E3%82%A2%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88%E3%81%8A%E3%82%88%E3%81%B3%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E2%80%95%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B">[1] コピー先のストレージ アカウントおよびコンテナ―を作成する</a></p><p><a href="https://jpaztech.github.io/blog/vm/create-vm-using-vhd/#2-%E3%82%B3%E3%83%94%E3%83%BC%E5%85%88%E3%81%AE-SAS-%E3%82%92%E7%99%BA%E8%A1%8C%E3%81%99%E3%82%8B">[2] コピー先の SAS を発行する</a></p><p>の手順と同様です。</p><p>　</p><p>■ ご参考: Azure VM からエクスポートした VHD ファイルを用いた複製 VM の作成方法</p><p><a href="https://jpaztech.github.io/blog/vm/create-vm-using-vhd/">https://jpaztech.github.io/blog/vm/create-vm-using-vhd/</a></p></div><h4 id="4-2-コピー元のVMの停止"><a href="#4-2-コピー元のVMの停止" class="headerlink" title="(4-2) コピー元のVMの停止"></a>(4-2) コピー元のVMの停止</h4><h5 id="手順D-コピー元の仮想マシンを停止します。"><a href="#手順D-コピー元の仮想マシンを停止します。" class="headerlink" title="手順D. コピー元の仮想マシンを停止します。"></a>手順D. コピー元の仮想マシンを停止します。</h5><h4 id="4-3-コピー元-URL-を準備"><a href="#4-3-コピー元-URL-を準備" class="headerlink" title="(4-3) コピー元 URL を準備"></a>(4-3) コピー元 URL を準備</h4><p>事前に VM のディスクに関してスナップショットを取得します。</p><h5 id="手順E-クラシック仮想マシン-の-VHD-にてスナップショットを取得します。"><a href="#手順E-クラシック仮想マシン-の-VHD-にてスナップショットを取得します。" class="headerlink" title="手順E. クラシック仮想マシン の VHD にてスナップショットを取得します。"></a>手順E. クラシック仮想マシン の VHD にてスナップショットを取得します。</h5><ol><li>Azure Portal にて、<strong>[ストレージ アカウント]</strong> - <strong>[&lt;当該 (クラシック) ストレージアカウント名&gt;]</strong> を選択し、左メニュー <strong>[Blob service]</strong> から <strong>[コンテナー]</strong> を選択します。</li><li>スナップショットを作成します。<br> <strong>[vhds (コンテナー名)]</strong> - <strong>[&lt;ファイル名.vhd&gt;]</strong> の <strong>[…]</strong> をクリックし、<strong>[スナップショットの作成]</strong> をクリックします。</li><li>スナップショットを表示します。<br> <strong>[vhds (コンテナー名)]</strong> - <strong>[&lt;ファイル名.vhd&gt;]</strong> の <strong>[…]</strong> をクリックし、<strong>[スナップショットの表示]</strong> をクリックします。<br> 該当スナップショットの <strong>[…]</strong> をクリックし、ダブルクリックして表示される <strong>[スナップショットのプロパティ]</strong> から URL をテキスト エディタ等にコピーしておきます。</li></ol><h5 id="手順F-クラシック仮想マシンで作成した-VHD-ファイルをコピーするための-SAS-を発行します。"><a href="#手順F-クラシック仮想マシンで作成した-VHD-ファイルをコピーするための-SAS-を発行します。" class="headerlink" title="手順F. クラシック仮想マシンで作成した VHD ファイルをコピーするための SAS を発行します。"></a>手順F. クラシック仮想マシンで作成した VHD ファイルをコピーするための SAS を発行します。</h5><ol><li><strong>手順E-2, 3</strong> と同様に <strong>[vhds (コンテナー名)]</strong> - <strong>[&lt;ファイル名.vhd&gt;]</strong> の <strong>[…]</strong> をクリックし、<strong>[SAS の生成]</strong> をクリックします。</li><li>適宜設定を行い、<strong>[SAS トークンおよび URL を生成]</strong> をクリックします。</li><li><strong>[BLOB SAS トークン]</strong> をテキスト エディタ等にコピーしておきます。</li></ol><h5 id="手順G-コピー元の-URL-を合わせ、テキスト-エディタ等準備しておきます。"><a href="#手順G-コピー元の-URL-を合わせ、テキスト-エディタ等準備しておきます。" class="headerlink" title="手順G. コピー元の URL を合わせ、テキスト エディタ等準備しておきます。"></a>手順G. コピー元の URL を合わせ、テキスト エディタ等準備しておきます。</h5><p>スナップショットを AzCopy で複製する場合に、コピー元 URL を作成する手順は以下のようになります。</p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image7.png"></p><ol><li><p><strong>手順E-3</strong> で準備した URL を前半 (VHD のパスまで)、後半 (? マークから後ろ) に分けます。<br> <strong>例: 元々のスナップショットの URL が以下の場合</strong><br> <code>https://&#123;コピー元のストレージアカウント&#125;.blob.core.windows.net/vhds/&#123;ファイル名&#125;.vhd?snapshot=YYYY-MM-DDThhmm:ss.nnnnnnnZ</code></p><p> <strong>前半</strong>:<br> <code>https://&#123;コピー元のストレージアカウント&#125;.blob.core.windows.net/vhds/&#123;ファイル名&#125;.vhd</code></p><p> <strong>後半</strong> (? マークから後ろ):<br> <code>snapshot=YYYY-MM-DDThhmm:ss.nnnnnnnZ</code></p></li><li><p>（<strong>手順G-1</strong> の前半部分）＋ (?) + (SAS文字列) + (&amp;) +(<strong>手順G-1</strong> の後半部分）を連結し、以下のようなコピー元 URL を準備します。<br> <code>https://&#123;コピー元のストレージアカウント&#125;.blob.core.windows.net/vhds/&#123;ファイル名&#125;.vhd?&#123;SAS文字列&#125;&amp;snapshot=YYYY-MM-DDThh:mmss.nnnnnnnZ</code></p></li></ol><h4 id="4-4-AzCopy-コマンドで-VHD-ファイルをコピー"><a href="#4-4-AzCopy-コマンドで-VHD-ファイルをコピー" class="headerlink" title="(4-4) AzCopy コマンドで VHD ファイルをコピー"></a>(4-4) AzCopy コマンドで VHD ファイルをコピー</h4><h5 id="手順H-作業環境に-AzCopy-コマンドをダウンロードします。"><a href="#手順H-作業環境に-AzCopy-コマンドをダウンロードします。" class="headerlink" title="手順H. 作業環境に AzCopy コマンドをダウンロードします。"></a>手順H. 作業環境に AzCopy コマンドをダウンロードします。</h5><p>Azure Cloud Shell をご利用の場合、この手順は不要です。</p><blockquote><p>■ ご参考: AzCopy を使ってみる<br><a href="https://docs.microsoft.com/ja-jp/azure/storage/common/storage-use-azcopy-v10">https://docs.microsoft.com/ja-jp/azure/storage/common/storage-use-azcopy-v10</a></p></blockquote><h5 id="手順I-以下のようにコマンドを実行し、VHD-をコピーします。"><a href="#手順I-以下のようにコマンドを実行し、VHD-をコピーします。" class="headerlink" title="手順I. 以下のようにコマンドを実行し、VHD をコピーします。"></a>手順I. 以下のようにコマンドを実行し、VHD をコピーします。</h5><p><code>azcopy copy &quot;&#123;手順Gで準備したURLとファイル名.vhd?SAS文字列&amp;snapshot=日時を含む文字列&#125;&quot; &quot;&#123;手順CでコピーしたURL?SAS文字列&#125;&quot; --blob-type PageBlob</code></p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image8.png"></p><p>正常に転送が完了した場合は以下のような例の表示となります。</p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image9.png"></p><p>これにより、ARM 環境のストレージアカウントに ASM 環境の VHD ファイルのコピーができました。</p><h4 id="4-5-vhdを元にディスクを作成、仮想マシンを作成"><a href="#4-5-vhdを元にディスクを作成、仮想マシンを作成" class="headerlink" title="(4-5) vhdを元にディスクを作成、仮想マシンを作成"></a>(4-5) vhdを元にディスクを作成、仮想マシンを作成</h4><h5 id="手順J-ARM-環境の仮想マシンを作成します。"><a href="#手順J-ARM-環境の仮想マシンを作成します。" class="headerlink" title="手順J. ARM 環境の仮想マシンを作成します。"></a>手順J. ARM 環境の仮想マシンを作成します。</h5><ol><li>Azure Portal より <strong>[ディスク]</strong> を開き、<strong>[+ 追加]</strong> をクリックします。</li><li>適宜設定を行い、<strong>[確認および作成]</strong> - <strong>[作成]</strong> をクリックします。<ol><li><code>ソースの種類</code> は <strong>[ストレージ BLOB]</strong> を選択します。</li><li><code>ソース BLOB</code> は <strong>手順C</strong> のストレージ アカウントの <code>vhds</code> にコピーした VHD ファイルを選択します。</li><li><code>OS の種類</code> は適宜選択します。<br><img src="/blog/vm/migrate_classic_vm_and_storage/image10.png"></li></ol></li><li>Azure Portal より作成した OS ディスクを開き、<strong>[+ VM の作成]</strong> をクリックします。</li><li>適宜設定を行い、<strong>[確認および作成]</strong> - <strong>[作成]</strong> をクリックします。</li></ol><h5 id="手順K-ARM-仮想マシンに接続し、必要に応じて動作を確認します。"><a href="#手順K-ARM-仮想マシンに接続し、必要に応じて動作を確認します。" class="headerlink" title="手順K. ARM 仮想マシンに接続し、必要に応じて動作を確認します。"></a>手順K. ARM 仮想マシンに接続し、必要に応じて動作を確認します。</h5><p>以上の手順で、移行がスタックした際にクラシック VM から新規 の ARM の VM を手動で作成することが可能となります。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p>J から K の手順は、当初より公開しております以下の記事にも記載がございます。</p><p>Azure VM からエクスポートした VHD ファイルを用いた複製 VM の作成方法のページにおける</p><p><a href="https://jpaztech.github.io/blog/vm/create-vm-using-vhd/#5-VHD-%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%8B%E3%82%89%E7%AE%A1%E7%90%86%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B">[5] VHD ファイルから管理ディスクを作成する</a></p><p><a href="https://jpaztech.github.io/blog/vm/create-vm-using-vhd/#6-VHD-%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%8B%E3%82%89%E4%BD%9C%E6%88%90%E3%81%97%E3%81%9F%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%81%A7-VM-%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B%E3%80%82">[6] VHD ファイルから作成したディスクで VM を作成する。</a></p><p>と同様です。</p><p>　</p><p>■ ご参考: Azure VM からエクスポートした VHD ファイルを用いた複製 VM の作成方法</p><p><a href="https://jpaztech.github.io/blog/vm/create-vm-using-vhd/">https://jpaztech.github.io/blog/vm/create-vm-using-vhd/</a></p></div><p>これらの記事の内容が皆様のお役にたてれば幸いでございます。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポート チームの鳥越です。&lt;br&gt;2014年に Azure Resource Manager モデルがリリースされており、リタイアがアナウンスされた 2020 年 7 月時点ですでに 90% が Azure Resource Manager モデルで利用されておりました。&lt;/p&gt;
&lt;p&gt;Azure 初期で利用されておりました Azure Service Manager (ASM) を介した IaaS 仮想マシン (VM) の管理を 2020 年 2 月 28 日 に 非推奨として &lt;strong&gt;2023 年 9 月 6 日&lt;/strong&gt; に完全に廃止される予定です。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;■ ご参考: Migrate your IaaS resources to Azure Resource Manager by September 6, 2023&lt;br&gt;&lt;a href=&quot;https://learn.microsoft.com/en-us/azure/virtual-machines/classic-vm-deprecation&quot;&gt;https://learn.microsoft.com/en-us/azure/virtual-machines/classic-vm-deprecation&lt;/a&gt;&lt;br&gt;(ご参考: 日本語 URL)&lt;br&gt;&lt;a href=&quot;https://learn.microsoft.com/ja-jp/azure/virtual-machines/classic-vm-deprecation&quot;&gt;https://learn.microsoft.com/ja-jp/azure/virtual-machines/classic-vm-deprecation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;[!IMPORTANT]&lt;br&gt;&lt;strong&gt;(2023/01/27 Update)&lt;/strong&gt;: 当初、2023 年 3 月 1日とご説明しておりました ASM の廃止は &lt;strong&gt;2023 年 9 月 1 日&lt;/strong&gt; に延期されました。&lt;br&gt;その後、2023 年 9 月 6 日まで更に延期されましたが、現在これ以上の延期は計画されておりません。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;そのため、これから 2023 年 9 月 6 日までに移行計画を立てていらっしゃるお客様に対して、移行がスムーズに行えるようにあらかじめ確認しておくべきポイントをお纏めしました。&lt;/p&gt;
&lt;p&gt;本内容がお客様の移行作業に少しでもお役に立てば幸いでございます。&lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Migration" scheme="https://jpaztech.github.io/blog/tags/Migration/"/>
    
    <category term="Storage" scheme="https://jpaztech.github.io/blog/tags/Storage/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes の監査ログで AKS クラスターで起こるすべてのことを追跡しよう</title>
    <link href="https://jpaztech.github.io/blog/containers/aks-kube-audit/"/>
    <id>https://jpaztech.github.io/blog/containers/aks-kube-audit/</id>
    <published>2022-12-24T06:00:00.000Z</published>
    <updated>2023-08-18T00:59:11.258Z</updated>
    
    <content type="html"><![CDATA[<p>この記事は <a href="https://qiita.com/advent-calendar/2022/microsoft-azure-tech">Microsoft Azure Tech Advent Calendar 2022</a> の 24 日目の記事になります🎅</p><p>こんにちは。Azure テクニカル サポートチームの桐井です。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/aks/intro-kubernetes">Azure Kubernetes Service (AKS)</a> のクラスターを利用しているときに、アプリケーションがデプロイされたタイミングや、ノードのステータスがいつどのような理由で変わったのかなど、過去にクラスターで起こったイベントの履歴を確認したい場合があります。Kubernetes の監査ログを活用すると、これらのイベントをログから確認できるようになります。</p><p>本記事では、Kubernetes の監査ログの紹介と、AKS において監査ログ利用する方法を、実例を交えて解説します。</p><span id="more"></span><hr><h2 id="Kubernetes-の監査ログ-kube-audit"><a href="#Kubernetes-の監査ログ-kube-audit" class="headerlink" title="Kubernetes の監査ログ (kube-audit)"></a>Kubernetes の監査ログ (kube-audit)</h2><p>Kubernetes のクラスターは大きく分けて、<strong>コントロール プレーン</strong> と <strong>ノード</strong> の 2 つのコンポーネントで構成されています。<br>クラスターに対する各種操作は、コントロール プレーンに存在する <strong><a href="https://kubernetes.io/ja/docs/concepts/overview/components/#kube-apiserver">API サーバー (kube-apiserver)</a></strong> が提供する Kubernetes API を介して行われます。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit01.png" alt="Kubernetes クラスターのアーキテクチャー"></p><p>クラスターの利用者が実行する <a href="https://kubernetes.io/ja/docs/reference/kubectl/overview/">kubectl コマンド</a>は、API サーバーに対してリクエストを送信することで、Pod をはじめとするクラスター内のオブジェクトの作成や変更をします。</p><p>また、ノード上で稼働する <a href="https://kubernetes.io/ja/docs/concepts/overview/components/#kubelet">kubelet</a> やシステム Pod、さらにはコントロール プレーンを構成するコンポーネントも、API サーバーに対してアクセスをしています。各コンポーネントが自身の役割を果たすことで、Kubernetes クラスターの動作が成り立っています。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p>たとえば、新しい Pod が作成された際には、<a href="https://kubernetes.io/ja/docs/concepts/overview/components/#kube-scheduler">kube-scheduler</a> が Pod のデプロイに最適なノードを決定し、その結果を API サーバーへ報告します。Pod が割り当てられたノードでは、kubelet が Pod の仕様を読み取り、その内容に従ってコンテナー ランタイムにコンテナーの起動を指示します。コンテナーの起動が成功すると、API サーバーに対して Pod ステータスの更新がリクエストされ、Pod が動作中であると記録します。</p></div><p>そのため、API サーバーにどのようなリクエストが届いて、そのレスポンス (実行結果) はどのような内容であったのか記録されたログがあれば、クラスターで過去に行われた操作や発生したイベントを追跡できます。</p><p>Kubernetes では<strong>監査ログ (kube-audit)</strong> 機能を利用することで、API サーバーのアクセス ログを得ることができます。監査ログには、クラスター内で行われた一連の操作が記録されています。</p><blockquote><p><strong>Kubernetesドキュメント / 監査</strong><br><a href="https://kubernetes.io/ja/docs/tasks/debug/debug-cluster/audit/">https://kubernetes.io/ja/docs/tasks/debug/debug-cluster/audit/</a></p></blockquote><h3 id="Kubernetes-の監査ログの内容"><a href="#Kubernetes-の監査ログの内容" class="headerlink" title="Kubernetes の監査ログの内容"></a>Kubernetes の監査ログの内容</h3><p>Kubernetes の監査ログの構造や、どのような情報が記録されているかについて、実例をもとに解説します。<br>ここでは、<code>kubectl get pod</code> コマンドで Pod の情報を取得した際のログを確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pod nginx</span></span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx   1/1     Running   0          6d4h</span><br></pre></td></tr></table></figure><p>コマンドを実行すると、<code>GET https://&#123;API Server FQDN&#125;:443/api/v1/namespaces/default/pods/nginx</code> のように、API サーバーに対して HTTPS のリクエストが送信されます。</p><p>API サーバーは、リクエストにしたがって必要な処理を行い、クライアントへレスポンスを返します。そして、監査ログにその記録を出力します。監査ログは JSON 形式で出力されます。</p><blockquote><p><strong>Kubernetes Documentation / Reference / Configuration APIs / kube-apiserver Audit Configuration (v1) - Event</strong><br><a href="https://kubernetes.io/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event">https://kubernetes.io/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event</a></p></blockquote><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit02.png" alt="Pod の情報を取得した際の kube-audit ログの例"></p><p>このログから、次のことがわかります。ログの該当箇所を抜粋して解説します。</p><h4 id="WHAT-何が起きたのか？"><a href="#WHAT-何が起きたのか？" class="headerlink" title="WHAT: 何が起きたのか？"></a>WHAT: 何が起きたのか？</h4><p><code>&quot;verb&quot;</code> は <a href="https://kubernetes.io/docs/reference/using-api/api-concepts/#single-resource-api">Kubernetes API verbs</a> を表します。個々の Pod のように、単一のオブジェクトに対して行われた操作では、get、 create、 apply、 update、 patch、 delete、 proxy といった verb が使用されます。<br>この情報から、オブジェクトの作成・削除といった、どのような操作が実行されたか判断できます。</p><p>この例では、<code>nginx</code> Pod の情報を取得したため <code>&quot;get&quot;</code> が記録されています。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;verb&quot;</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WHEN-いつ起こったのか？"><a href="#WHEN-いつ起こったのか？" class="headerlink" title="WHEN: いつ起こったのか？"></a>WHEN: いつ起こったのか？</h4><p>タイムスタンプの情報から、そのイベントがいつ起こったのかがわかります。</p><p><code>&quot;requestReceivedTimestamp&quot;</code>は、クライアントからのリクエストが API サーバーに到着した日時です。</p><p>監査ログは、API サーバーがリクエストを処理する<a href="https://kubernetes.io/docs/tasks/debug/debug-cluster/audit/">段階 (stage)</a> ごとに出力されます。<br>この例では、<code>&quot;stage&quot;</code>は<code>&quot;ResponseComplete&quot;</code>と記録されています。API サーバーがクライアントにレスポンスを転送し終わった際のログとなっており、<code>&quot;stageTimestamp&quot;</code>はレスポンスが完了した日時を表します。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;stage&quot;</span>: <span class="string">&quot;ResponseComplete&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;requestReceivedTimestamp&quot;</span>: <span class="string">&quot;2022-12-18T07:21:50.6437530Z&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;stageTimestamp&quot;</span>: <span class="string">&quot;2022-12-18T07:21:50.6480500Z&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WHO-誰がその操作を始めたのか？"><a href="#WHO-誰がその操作を始めたのか？" class="headerlink" title="WHO: 誰がその操作を始めたのか？"></a>WHO: 誰がその操作を始めたのか？</h4><p><code>&quot;user&quot;</code> の情報から、どのユーザーが行った操作であるか特定できます。<br>AKS では、<a href="https://learn.microsoft.com/ja-jp/Azure/aks/control-kubeconfig-access#available-cluster-roles-permissions"><code>az aks get-credentials</code> コマンドで取得した資格情報</a>を使ってクラスターを操作した場合に <code>&quot;user.username&quot;</code> が <code>&quot;masterclient&quot;</code> となります。</p><p><code>&quot;userAgent&quot;</code> にはリクエストを送信したクライアントの <a href="https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/User-Agent">User Agent</a> の情報が記録されます。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;user&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;masterclient&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;groups&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;system:masters&quot;</span>,</span><br><span class="line">      <span class="string">&quot;system:authenticated&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;userAgent&quot;</span>: <span class="string">&quot;kubectl/v1.26.0 (linux/amd64) kubernetes/b46a3f8&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>たとえば、<a href="https://learn.microsoft.com/ja-jp/azure/aks/kubernetes-portal?tabs=azure-cli">Azure Portal から AKS クラスター内のリソースにアクセス</a>した場合には、<code>&quot;userAgent&quot;</code> は次のように Web ブラウザーからのアクセスを示す文字列となります。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;userAgent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1462.54&quot;</span>,</span><br></pre></td></tr></table></figure><p>User Agent を調べることで、クラスター上にデプロイされているツールやコントローラーによる操作も特定できます。<br>次の例では、<a href="https://kubernetes.github.io/ingress-nginx/">NGINX Ingress Controller</a>のコントローラー Pod からリクエストされた操作であることがわかります。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;userAgent&quot;</span>: <span class="string">&quot;nginx-ingress-controller/v1.4.0 (linux/amd64) ingress-nginx/50be2bf95fd1ef480420e2aa1d6c5c7c138c95ea&quot;</span>,</span><br></pre></td></tr></table></figure><h4 id="WHERE-どこから操作をされたのか？"><a href="#WHERE-どこから操作をされたのか？" class="headerlink" title="WHERE: どこから操作をされたのか？"></a>WHERE: どこから操作をされたのか？</h4><p><code>&quot;sourceIPs&quot;</code> にはリクエスト元の IP アドレスが記録されます。IP アドレスを調べることによって、操作がどこから行われたのか特定できます。<br>(次の例では<a href="https://www.rfc-editor.org/rfc/rfc5737">例示用 IP アドレス</a>に置き換えています)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;sourceIPs&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;203.0.113.10&quot;</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WHAT-何に対する操作が行われたのか？"><a href="#WHAT-何に対する操作が行われたのか？" class="headerlink" title="WHAT: 何に対する操作が行われたのか？"></a>WHAT: 何に対する操作が行われたのか？</h4><p><code>&quot;requestURI&quot;</code> はクライアントから API サーバーに送信されたリクエスト URI を示します。</p><p><code>&quot;objectRef&quot;</code> (<a href="https://kubernetes.io/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-ObjectReference">Object Reference</a>) は、操作のターゲットとなったオブジェクトを表します。</p><p>次の例では、<code>&quot;default&quot;</code> ネームスペースに存在する <code>&quot;pods&quot;</code> リソースで、名前が <code>&quot;nginx&quot;</code> であるオブジェクトが操作対象であったことがわかります。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;requestURI&quot;</span>: <span class="string">&quot;/api/v1/namespaces/default/pods/nginx&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;objectRef&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;resource&quot;</span>: <span class="string">&quot;pods&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;namespace&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;nginx&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;apiVersion&quot;</span>: <span class="string">&quot;v1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="操作の結果はどうなったのか"><a href="#操作の結果はどうなったのか" class="headerlink" title="操作の結果はどうなったのか"></a>操作の結果はどうなったのか</h4><p><code>&quot;responseStatus&quot;</code> は、API サーバーがクライアントに返したレスポンス ステータスを表します。</p><p>次の例では、リクエスト対象の Pod がクラスターに存在し、Pod の情報を応答することが成功した (HTTP Status 200) ことがわかります。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;responseStatus&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="number">200</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>リクエストがエラーとなった場合には、エラーの内容を示すステータスが記録されます。<br>次の例では、存在しない Pod の情報を取得しようとしたために、HTTP Status 404 が返されたことがわかります。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;requestURI&quot;</span>: <span class="string">&quot;/api/v1/namespaces/default/pods/nginxxxxxx&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;responseStatus&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;Failure&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;NotFound&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="number">404</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="API-リクエストとレスポンスのオブジェクト内容"><a href="#API-リクエストとレスポンスのオブジェクト内容" class="headerlink" title="API リクエストとレスポンスのオブジェクト内容"></a>API リクエストとレスポンスのオブジェクト内容</h4><p><code>&quot;requestObject&quot;</code> には、クライアントから API サーバーに送信されたリクエストの内容が記録されています。Pod や Deployment といったオブジェクトを作成する際には、YAML 形式のマニフェスト ファイルに記載した内容が記録されます。監査ログ上では JSON 形式で記録されますが、フィールド名や値、オブジェクトの構造は YAML 形式の場合と同様です。<br>ノードや Pod などのステータスが更新された場合には、更新が必要な情報 (フィールド) のみを抜粋した patch リクエストが行われる場合もあります。</p><p>次の例は、Deployment を作成した際のログの抜粋です。<code>spec.replicas</code> に Pod のレプリカ数が指定されていることがわかります。Deployment オブジェクトはまだ作成されていない状態のため、作成日時のタイムスタンプは <code>null</code> です。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;requestObject&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;Deployment&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;apiVersion&quot;</span>: <span class="string">&quot;apps/v1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;azure-vote-back&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;namespace&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;creationTimestamp&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;spec&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;replicas&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&quot;responseObject&quot;</code> には、API サーバーからクライアントへ返されたレスポンスの内容が記録されています。</p><p>次の例は、Deployment の作成リクエストに対するレスポンスです。Deployment オブジェクトが作成されたため、作成日時のタイムスタンプ情報があり、オブジェクトの <code>&quot;uid&quot;</code> が割り当てられていることが確認できます。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;responseObject&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;Deployment&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;apiVersion&quot;</span>: <span class="string">&quot;apps/v1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;azure-vote-back&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;namespace&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;uid&quot;</span>: <span class="string">&quot;b5154018-c171-4155-8d95-2a1866a25a6b&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;resourceVersion&quot;</span>: <span class="string">&quot;144810978&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;generation&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;creationTimestamp&quot;</span>: <span class="string">&quot;2022-12-19T11:13:27.0000000Z&quot;</span>,</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このように、監査ログには、API サーバーにリクエストされた操作の内容やリクエストの発生元、そしてその結果となるレスポンスがどうなったのかについて情報が記録されています。</p><p>前述のとおり、クラスターに対する操作は、クラスターの利用者の操作、ツール / Kubernetes のコントローラーの自動化処理など、すべて API サーバーに対してリクエストが送信されます。<br>監査ログをみることで、どのような操作が行われたのかを追跡でき、過去にクラスターで何が起こったのかを手に取るように把握できます。</p><h2 id="AKS-クラスターの監査ログ出力を設定する"><a href="#AKS-クラスターの監査ログ出力を設定する" class="headerlink" title="AKS クラスターの監査ログ出力を設定する"></a>AKS クラスターの監査ログ出力を設定する</h2><p>監査ログの出力を有効化するには、kube-apiserver に対して設定が必要となります。<br>AKS はマネージドの Kubernetes サービスであるため、ご利用者様において kube-apiserver の設定を直接変更することはできませんが、AKS クラスター (managedCluster) リソースの<a href="https://learn.microsoft.com/ja-jp/azure/azure-monitor/essentials/resource-logs"><strong>診断設定</strong></a>を構成することで、Kubernetes の監査ログを Log Analytics ワークスペースやストレージ アカウントに送信できます。</p><blockquote><p><strong>AKS データの監視に関するリファレンス - リソース ログ</strong><br><a href="https://learn.microsoft.com/ja-jp/azure/aks/monitor-aks-reference#resource-logs">https://learn.microsoft.com/ja-jp/azure/aks/monitor-aks-reference#resource-logs</a></p></blockquote><p>Azure ポータルでは、対象となる AKS クラスターを開いたあと、左に表示されるメニューの <strong>[診断設定]</strong> の画面から設定できます。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit03.png" alt="ポータルの左メニューから[診断設定]を開きます"></p><p>診断設定の作成画面では、設定につける名前とログのカテゴリ、ログの転送先の選択をします。<br>次の例では、Kubernetes の監査ログを Log Analytics ワークスペースへ送信するように設定しています。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit04.png" alt="新しい診断設定を作成します"></p><p>監査ログに該当するカテゴリには、<strong>Kubernetes Audit</strong> と <strong>Kubernetes Audit Admin Logs</strong> の 2 つが存在します。それぞれ、次の違いがあります。</p><ul><li><strong>Kubernetes Audit (kube-audit)</strong><ul><li>get、list、create、update、delete、patch、post を含む、すべての監査イベントのログを出力します</li></ul></li><li><strong>Kubernetes Audit Admin Logs (kube-audit-admin)</strong><ul><li>Kubernetes Audit (kube-audit) カテゴリのログから、get および list の監査イベント (参照系のイベント) を除外したログを出力します</li></ul></li></ul><p>Kubernetes クラスターの動作は、さまざまなコントローラー (ソフトウェア) がリソース オブジェクトを操作することによって成り立っています。そのため、オブジェクトの get や list、watch といったリクエストが継続的に発生しています。<strong>Kubernetes Audit</strong> カテゴリは、コントローラーによる参照系リクエストもふくめ、すべてのイベントのログが出力されます。</p><p>一方、クラスターに対する変更系の操作のみを追跡したいというシナリオでは、get や list といった参照系のログは必要ないということがあります。その場合、<strong>Kubernetes Admit Admin Logs</strong> を選択することで、ログの数を大幅に削減でき、Log Analytics ワークスペースやストレージ アカウントの容量・料金の節約になります。</p><p>診断設定で出力できる AKS クラスターのリソース ログについては、次のドキュメントに一般的な推奨事項が記載されていますので、あわせてご参照ください。</p><blockquote><p><strong>Azure Monitor のコンテナー正常性機能を使用して Azure Kubernetes Service (AKS) を監視する - リソース ログを収集する</strong><br><a href="https://learn.microsoft.com/ja-jp/azure/aks/monitor-aks#collect-resource-logs">https://learn.microsoft.com/ja-jp/azure/aks/monitor-aks#collect-resource-logs</a><br>　<br>このドキュメントでは、kube-audit を Azure ストレージへ転送し、kube-audit-admin を Log Analytics ワークスペースへ転送する構成が紹介されています。</p></blockquote><h3 id="監査ログの取得方法"><a href="#監査ログの取得方法" class="headerlink" title="監査ログの取得方法"></a>監査ログの取得方法</h3><p>診断設定で Log Analytics ワークスペースへ送信したログは、Azure ポータルの <a href="https://portal.azure.com/#view/Microsoft_Azure_Monitoring/AzureMonitoringBrowseBlade/~/overview"><strong>[モニター]</strong></a> 画面から、<a href="https://learn.microsoft.com/ja-jp/azure/azure-monitor/logs/log-query-overview">Kusto クエリ</a>を実行することで取得できます。</p><p>左のメニューから <strong>[ログ]</strong> 画面へ移動し、ログの出力先の Log Analytics ワークスペースを選択して新しいクエリを実行します。</p><p>診断設定のログは <strong>AzureDiagnostics</strong> テーブルに格納されています。<br><code>Category</code> カラムの値が <code>kube-audit</code> となっているログを絞り込むことで、Kubernetes の監査ログが取得できます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AzureDiagnostics </span><br><span class="line">| where Category == &quot;kube-audit&quot;</span><br><span class="line">| take 10</span><br></pre></td></tr></table></figure><p>次のスクリーンショットは、クエリを実行してログを取得した画面です。<code>log_s</code> カラムに、Kubernetes の監査ログが JSON 形式で記録されています。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit05.png" alt="AzureDiagnostics テーブルで Category が &quot;kube-audit&quot; のログを取得します"></p><p><code>log_s</code> カラムの値を <a href="https://learn.microsoft.com/ja-jp/azure/data-explorer/kusto/query/parsejsonfunction">parse_json()</a> 関数で変換することで、監査ログ内部の値にアクセスしやすくなります。<br><a href="https://learn.microsoft.com/ja-jp/azure/data-explorer/kusto/query/extendoperator">extend 演算子</a>でログの項目ごとに新しい列を作成しておくと、クエリに検索条件を追加する際に便利です。また、必要な列のみに絞ってログを表示することが可能になります。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AzureDiagnostics </span><br><span class="line">| where Category == &quot;kube-audit&quot;</span><br><span class="line">| extend audit = parse_json(log_s)</span><br><span class="line">| extend Method = audit.verb</span><br><span class="line">| extend RequestURI = audit.requestURI</span><br><span class="line">| extend RequestObject = audit.requestObject</span><br><span class="line">| extend ResponseObject = audit.responseObject</span><br><span class="line">| extend ResponseStatusCode = audit.responseStatus.code</span><br><span class="line">| extend UserAgent = audit.userAgent</span><br><span class="line">| extend User = audit.user.username</span><br><span class="line">| project TimeGenerated, Method, ResponseStatusCode, RequestURI, User, UserAgent, RequestObject, ResponseObject</span><br><span class="line">| order by TimeGenerated asc</span><br></pre></td></tr></table></figure><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit06.png" alt="extend 演算子を使用したクエリ結果"></p><h2 id="クエリとログの例"><a href="#クエリとログの例" class="headerlink" title="クエリとログの例"></a>クエリとログの例</h2><p>ここまでの手順で、AKS クラスターの監査ログを Log Analytics ワークスペースへ転送し、クエリの実行でログ取得ができるようになりました。</p><p>ここでは 4 つのシナリオをもとに、監査ログの情報を取得する例を紹介します。</p><h3 id="シナリオ-1-アプリケーション-Pod-Deployment-の作成履歴を確認する"><a href="#シナリオ-1-アプリケーション-Pod-Deployment-の作成履歴を確認する" class="headerlink" title="シナリオ 1: アプリケーション (Pod/Deployment) の作成履歴を確認する"></a>シナリオ 1: アプリケーション (Pod/Deployment) の作成履歴を確認する</h3><p>AKS クラスターにアプリケーションをデプロイした際のログを見てみましょう。<a href="https://learn.microsoft.com/ja-jp/azure/aks/tutorial-kubernetes-deploy-application">AKS チュートリアル</a>で使用されている azure-vote アプリケーションをクラスターにデプロイし、Kubernetes の監査ログからDeployment の作成履歴を確認します。</p><p><code>kubectl</code> コマンドでアプリケーションの YAML マニフェストをクラスターに適用します。次のコマンド例では Deployment と Service が2つずつ作成されています。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f azure-vote-all-in-one-redis.yaml</span></span><br><span class="line">deployment.apps/azure-vote-back created</span><br><span class="line">service/azure-vote-back created</span><br><span class="line">deployment.apps/azure-vote-front created</span><br><span class="line">service/azure-vote-front created</span><br></pre></td></tr></table></figure><p>次のクエリ例では、監査ログ (<code>audit</code>) 内に <code>&quot;azure-vote&quot;</code> の文字列を含むログを抽出しています。<br>その他の条件として、create リクエスト (<code>Method</code>)、kubectl コマンドからのアクセス (<code>UserAgent</code>) を指定しています。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AzureDiagnostics </span><br><span class="line">| where Category == &quot;kube-audit&quot;</span><br><span class="line">| extend audit = parse_json(log_s)</span><br><span class="line">| extend Method = audit.verb</span><br><span class="line">| extend RequestURI = audit.requestURI</span><br><span class="line">| extend RequestObject = audit.requestObject</span><br><span class="line">| extend ResponseObject = audit.responseObject</span><br><span class="line">| extend ResponseStatusCode = audit.responseStatus.code</span><br><span class="line">| extend UserAgent = audit.userAgent</span><br><span class="line">| extend User = audit.user.username</span><br><span class="line">| where audit contains &quot;azure-vote&quot;     // 監査ログ内に &quot;azure-vote&quot; の文字列を含む</span><br><span class="line">| where Method == &quot;create&quot;              // create リクエスト</span><br><span class="line">| where UserAgent contains &quot;kubectl&quot;    // クライアントが kubectl のログ</span><br><span class="line">| project TimeGenerated, Method, ResponseStatusCode, RequestURI, User, UserAgent, RequestObject, ResponseObject</span><br><span class="line">| order by TimeGenerated asc</span><br></pre></td></tr></table></figure><p>クエリを実行すると、次のスクリーンショットのようにログが取得されました。ログの内容を表示された順に上から確認してみましょう。</p><p>まずは、 API サーバーに対して、<code>2022-12-19 11:13:27 (UTC)</code> に <code>/apis/apps/v1/namespace/default/deployments</code> のパスに <code>create</code> リクエストが送信されたことがわかります。</p><p><code>User</code> カラムの情報から、<code>az aks get-credentials</code> コマンドで取得した AKS クラスターの資格情報 (<code>masterclient</code>) が使用されていることがわかります。また、<code>UserAgent</code> カラムの情報から、<code>kubectl</code> コマンドによる操作が実行されたことがわかります。</p><p><code>RequestObject</code> には Deployment の YAML マニフェストの内容が記録されています。<code>spec</code> には Deployment の仕様が記録されており、Pod のレプリカ数 (<code>spec.replicas</code>) や Pod テンプレート (<code>spec.template</code>) の内容が含まれていることが確認できます。 </p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit07.png" alt="Deployment オブジェクトの作成ログ"></p><p>Kubernetes では、Deployment オブジェクトが作成・更新されると、その内容をもとに ReplicaSet オブジェクトが作成されます。そして、指定されたレプリカの数だけ Pod オブジェクトが作成されます。この動作は、Kubernetes クラスターを構成するコントローラーによって自動的に行われます。</p><p>上記のクエリ例では、人によって開始された Deployment 作成のログを確認しましたが、コントローラーによる自動処理についても Kubernetes の監査ログから確認できます。<br>作成した Deployment から最終的に Pod が起動するまでの様子を、実際に監査ログから追ってみましょう。ここでは、ReplicaSet が作成される箇所は割愛し、最終的に Pod が作成される様子を紹介します。</p><p>先ほど使用したクエリの条件 (kubectl によるリクエスト) を削除して、ログ内に <code>&quot;azure-vote&quot;</code> の文字列を含む create リクエストのすべてを検索します。すると、<code>/api/v1/namespaces/default/pods</code> パスに対する create リクエストが確認できます。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit08.png" alt="Pod オブジェクトの作成ログ"></p><p><code>User</code> および <code>UserAgent</code> から、<a href="https://kubernetes.io/ja/docs/concepts/overview/components/#kube-controller-manager">kube-controller-manager</a> 内の ReplicaSet Controller によって、Pod の作成がリクエストされたことがわかります。</p><p>Deployment の場合と同様に、<code>ResponseObject</code> には Pod のデプロイ内容が記録されています。<code>metadata.name</code> の情報から、<code>azure-vote-back-59d587dbb7-pjkxr</code> という名前で Pod が作成されたことがわかります。<br>また、<code>status.phase</code> が <code>Pending</code> となっています。この時点では Pod がノードにスケジューリングされておらず、ステータスが <code>Pending</code> の状態であったことがわかります。</p><p>Pod の名前が特定できました。この Pod 名を <code>RequestURI</code> に含むログを検索してみましょう。クエリを実行すると、次のリクエストのログが表示されました。</p><ul><li><code>create /api/v1/namespaces/default/pods/azure-vote-back-59d587dbb7-pjkxr/binding</code> <strong>(binding)</strong></li><li><code>patch /api/v1/namespaces/default/pods/azure-vote-back-59d587dbb7-pjkxr/status</code> <strong>(status)</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| where RequestURI contains &quot;azure-vote-back-59d587dbb7-pjkxr&quot;  // Pod 名を指定</span><br></pre></td></tr></table></figure><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit09.png" alt="ノードの割り当てと Pod ステータスが更新された際のログ"></p><p><code>RequestURI</code> の末尾が <code>/binding</code> のログは、Pod がノードにスケジューリングされた際のリクエストです。<code>UserAgent</code> から kube-scheduler によるリクエストであることが確認できます。<br>また、<code>RequestObject.target</code> の情報から、Pod がノード <code>aks-nodepool2-20356098-vmss000001</code> に割り当てられたことがわかります。</p><p><code>RequestURI</code> の末尾が <code>/status</code> のログは、Pod のステータス情報が更新された際のリクエストです。<code>User</code> と <code>UserAgent</code> から、Pod がスケジューリングされたノード <code>aks-nodepool2-20356098-vmss000001</code> の kubelet から送信されたことが確認できます。</p><p>ノード上の kubelet は、コンテナー ランタイムにコンテナーの起動を指示し、その結果を API サーバーに送信する役割を持っています。コンテナーの状態にあわせて Pod のステータスを更新しています (<code>Method</code> も <code>create</code> ではなく <code>patch</code> となっています)。</p><p><code>RequestObject</code> の <code>status</code> の情報が、kubelet から報告された Pod の状態になります。<code>status.phase</code> より、Pod が <code>Running</code> ステータスになったことがわかります。また、Pod に割り当てられた IP アドレスの情報も確認できます。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p>create リクエストでは、作成するオブジェクトがまだ存在しないため、<code>RequestURI</code> にはオブジェクト名が含まれません。たとえば、Pod の作成では <code>/api/v1/namespaces/default/pods</code> に対して create リクエストが送信され、Pod 名などの情報は <code>RequestObject</code> に含まれています。</p><p>　</p><p>オブジェクトが作成された後は、オブジェクト名を含む <code>RequestURI</code> で操作されます。たとえば、特定の Pod の削除操作では、対象となる Pod を表す <code>/api/v1/namespaces/default/pods/azure-vote-back-59d587dbb7-pjkxr</code> に対して delete リクエストが送信されます。</p><p>　</p><p>クエリの作りこみをする際には、上述のクエリ例 (<code>where audit contains &quot;azure-vote&quot;</code>) のように、監査ログ全体を絞り込みの条件にして、必要な情報がどのフィールドに存在するかを確認するとよいです。ReplicaSet によって作成された Pod のように、名前にランダムな文字列が含まれる場合もログの特定がしやすくなります。</p></div><h3 id="シナリオ-2-Pod-のステータスとノードへのスケジューリング履歴を確認"><a href="#シナリオ-2-Pod-のステータスとノードへのスケジューリング履歴を確認" class="headerlink" title="シナリオ 2: Pod のステータスとノードへのスケジューリング履歴を確認"></a>シナリオ 2: Pod のステータスとノードへのスケジューリング履歴を確認</h3><p>新しく作成された Pod が <code>Pending</code> ステータスとなり、起動しない場合があります。</p><blockquote><p>コンピュート リソースの不足によって発生する Pod の Pending ステータスについては、こちらのブログ記事もご参照ください。<br>　<br><strong>Japan Azure IaaS Core Support Blog - AKSのメモリ関連トラブルシューティング</strong><br><a href="https://jpaztech.github.io/blog/containers/aks-memory-troubleshoot/">https://jpaztech.github.io/blog/containers/aks-memory-troubleshoot/</a></p></blockquote><p>次の例では、Pod が要求する CPU リソースが、現在クラスターに存在する空きノードで提供できないために、Pod が <code>Pending</code> ステータスとなっています。<br>また、<a href="https://learn.microsoft.com/ja-jp/azure/aks/cluster-autoscaler">クラスター オートスケーラー</a>が <code>Pending</code> ステータスの Pod が存在することを検知し、ノードプールのスケール アップを実行したイベントが確認できます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -l app=azure-vote-front</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">azure-vote-front-7655fcc46d-jm5sh   0/1     Pending   0          2s</span><br><span class="line">azure-vote-front-7655fcc46d-wtfph   1/1     Running   0          31s</span><br><span class="line">azure-vote-front-7655fcc46d-zqvbc   0/1     Pending   0          2s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod azure-vote-front-7655fcc46d-jm5sh</span></span><br><span class="line">  ...</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age   From                Message</span><br><span class="line">  ----     ------            ----  ----                -------</span><br><span class="line">  Warning  FailedScheduling  35s   default-scheduler   0/2 nodes are available: 2 Insufficient cpu.</span><br><span class="line">  Normal   TriggeredScaleUp  28s   cluster-autoscaler  pod triggered scale-up: [&#123;aks-nodepool2-20356098-vmss 2-&gt;4 (max: 5)&#125;]</span><br></pre></td></tr></table></figure><p>このときの Pod のステータスの変化と、ノードの追加のイベントを、監査ログから確認してみましょう。</p><p><code>RequestURI</code> に対象の Pod 名を含むログを検索します。ステータス情報が更新されたイベントを抽出するために、<code>Method</code> が get 以外のログを取得します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AzureDiagnostics </span><br><span class="line">| where Category == &quot;kube-audit&quot;</span><br><span class="line">| extend audit = parse_json(log_s)</span><br><span class="line">| extend Method = audit.verb</span><br><span class="line">| extend RequestURI = audit.requestURI</span><br><span class="line">| extend RequestObject = audit.requestObject</span><br><span class="line">| extend ResponseStatusCode = audit.responseStatus.code</span><br><span class="line">| extend UserAgent = audit.userAgent</span><br><span class="line">| where Method != &quot;get&quot;</span><br><span class="line">| where RequestURI contains &quot;/api/v1/namespaces/default/pods/azure-vote-front-7655fcc46d-jm5sh&quot;</span><br><span class="line">| project TimeGenerated, RequestObject, Method, ResponseStatusCode, RequestURI, UserAgent</span><br><span class="line">| order by TimeGenerated asc</span><br></pre></td></tr></table></figure><p>ログを検索した結果、kube-scheduler によって Pod のステータス情報が更新されたログが見つかりました (URI 末尾が <code>/status</code>) 。<br><code>RequestObject.status.conditions[0]</code> に Pod の状態を表す情報が記録されています。<code>Unschedulable</code> のメッセージが確認でき、<code>message</code> から CPU リソースの不足が理由であることがわかります。このメッセージは <code>kubectl describe pod</code> コマンドで確認できるものと同様の内容です。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit10.png" alt="CPU リソースの不足により Pod がスケジューリングされていない状態のログ"></p><p>そのあとの時間に、Pod がノードに割り当てられたログが確認できました (URI 末尾が <code>/binding</code>) 。<code>ResponseObject.target</code> から、Pod のデプロイ先がノード <code>aks-nodepool2-20356098-vmss000005</code> になったことがわかります。クラスター オートスケーラーによって新しい空きノードが追加され、Pod がデプロイできるようになりました。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit11.png" alt="新規に追加されたノードへ Pod がスケジューリングされた際のログ"></p><p>クラスターにノードが追加された際のログをみてみましょう。<code>kubectl get nodes</code> コマンドで取得できるノードの情報は、Node オブジェクトとして管理されています。<code>/api/v1/nodes</code> に送信された create リクエストのログを検索します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AzureDiagnostics </span><br><span class="line">| where Category == &quot;kube-audit&quot;</span><br><span class="line">| extend audit = parse_json(log_s)</span><br><span class="line">| extend Method = audit.verb</span><br><span class="line">| extend RequestURI = audit.requestURI</span><br><span class="line">| extend RequestObject = audit.requestObject</span><br><span class="line">| extend ResponseStatusCode = audit.responseStatus.code</span><br><span class="line">| extend UserAgent = audit.userAgent</span><br><span class="line">| extend User = audit.user.username</span><br><span class="line">| where Method == &quot;create&quot;</span><br><span class="line">| where RequestURI contains &quot;/api/v1/nodes&quot;</span><br><span class="line">| project TimeGenerated, RequestObject, Method, ResponseStatusCode, RequestURI, User, UserAgent</span><br><span class="line">| order by TimeGenerated asc</span><br></pre></td></tr></table></figure><p>Node オブジェクトの作成ログが取得できました。<code>User</code> および <code>UserAgent</code> から、<code>aks-nodepool2-20356098-vmss000005</code> ノードの kubelet からリクエストが送信されたことがわかります。<br>新しいノード (VM) が作成され、kubelet が動作を開始すると、API サーバーにノードの情報が登録されます。<code>ResponseObject</code> の <code>spec</code> や <code>status</code> から、ノードの情報やステータスが取得できます。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit12.png" alt="新規 Node が作成された際のログ"></p><div class="alert is-success"><p class="alert-title">ヒント</p><p>クラスター オートスケーラーのログは、監査ログと同様に AKS クラスターの診断設定で <strong>Kubernetes Cluster Autoscaler (cluster-autoscaler)</strong> を出力することで、お客様にてご確認いただけます。</p><p>オートスケールによってノードが意図した通りに追加・削除されなかった際に、クラスター オートスケーラーがどのような判断をしたのかや、VMSS インスタンスの操作リクエストが失敗していないかについて、ログから確認できます。</p></div><h3 id="シナリオ-3-Node-のステータス履歴を確認"><a href="#シナリオ-3-Node-のステータス履歴を確認" class="headerlink" title="シナリオ 3: Node のステータス履歴を確認"></a>シナリオ 3: Node のステータス履歴を確認</h3><p>ノードが新規に作成されると、はじめは <code>NotReady</code> ステータスの状態でクラスターに登録されます。その後 Pod を起動する準備が完了すると <code>Ready</code> ステータスへ変化します。<br>上記例 2 のシナリオで新しいノードが作成された際のログから、ノードのステータス情報が変化した様子を確認してみましょう。</p><p><code>RequestURI</code> に文字列 <code>&quot;/api/v1/nodes&quot;</code> を含み、かつ <code>&quot;/status&quot;</code> で終わるという条件をクエリに追加します。<code>Method</code> には patch を指定しています。</p><p>ノードのステータス情報は <code>ResponseObject.status.conditions</code> の配列に含まれています。扱いやすいように <a href="https://learn.microsoft.com/ja-jp/azure/data-explorer/kusto/query/mvexpandoperator">mv-expand 演算子</a>で配列の値を複数のレコードに展開します。ノードが Ready であるかどうかを表す情報は、<code>conditions.type</code> が <code>Ready</code> のものが該当します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AzureDiagnostics </span><br><span class="line">| where Category == &quot;kube-audit&quot;</span><br><span class="line">| extend audit = parse_json(log_s)</span><br><span class="line">| extend Method = audit.verb</span><br><span class="line">| extend RequestURI = audit.requestURI</span><br><span class="line">| extend ResponseObject = audit.responseObject</span><br><span class="line">| extend UserAgent = audit.userAgent</span><br><span class="line">| where RequestURI contains &quot;/api/v1/nodes&quot; and RequestURI endswith &quot;/status&quot;</span><br><span class="line">| where Method == &quot;patch&quot;</span><br><span class="line">| mv-expand conditions = ResponseObject.status.conditions   // conditions 配列の値を複数のレコードに展開</span><br><span class="line">| where conditions.type == &quot;Ready&quot;                          // type が &quot;Ready&quot; のログを取得</span><br><span class="line">| project TimeGenerated, conditions.type, conditions.status, conditions.reason, conditions.message, RequestURI, UserAgent</span><br><span class="line">| order by TimeGenerated asc</span><br></pre></td></tr></table></figure><p>クエリを実行すると、次の例のようにログが取得できます。<br>少々わかりにくいですが、<code>conditions_status</code> が <code>False</code> となっている場合は、ノードが <code>Ready</code> <strong>ではない</strong> ことを示しています (<code>NotReady</code> ステータス) 。</p><p>そのあとの時間に <code>conditions_status</code> が <code>True</code> へと変化しています (ノードが <code>Ready</code> ステータスになった)。また、<code>kubelet is posting ready status.</code> のメッセージから、kubelet から API サーバーにノードが正常であるという情報が報告されたことがわかります。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit13.png" alt="ノードのステータスが更新された際のログ"></p><div class="alert is-success"><p class="alert-title">ヒント</p><p><a href="https://learn.microsoft.com/ja-jp/azure/azure-monitor/containers/container-insights-overview">Container Insights</a> を利用にすることで、Azure Monitor で<a href="https://learn.microsoft.com/ja-jp/azure/azure-monitor/containers/container-insights-livedata-metrics#node-count">ノードのステータス情報をメトリックとして取得</a>できます。</p><p>監査ログではクラスターのさまざまな情報が取得可能ですが、Pod や Node のステータス変化をモニタリングする目的では、クエリの作成やログ データの管理が不要なため、Container Insights で用意されたメトリックを利用することをおすすめします。メトリックから、ステータス変化が発生した事実・発生日時を把握し、具体的な理由や関連するクラスター上のイベントを調査する目的で、監査ログを併用すると良いでしょう。</p></div><h3 id="シナリオ-4-Pod-再起動のなぞを追え！"><a href="#シナリオ-4-Pod-再起動のなぞを追え！" class="headerlink" title="シナリオ 4: Pod 再起動のなぞを追え！"></a>シナリオ 4: Pod 再起動のなぞを追え！</h3><blockquote><p><strong>[Contoso 社のストーリー]</strong><br><a href="https://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%B3%E3%83%88%E3%82%BD">Contoso 社</a>では先月、AKS を使って期待の新サービスをリリースしました。年明けにはイベント開催も控えており、2022年も終わりをむかえるこの12月も、開発は鋭意進行中です。今のところ目立った問題は起きておらず、安定して稼働をしているようです。今日の AKS の調子はどうかな？<br>　<br>ところが今日、開発のエンジニアより「最近 Pod が突然再起動するようになった」との報告を受けました。リリース作業などのクラスター操作はしていないのにもかかわらず、Pod が再起動 (再作成) されるとのことです。事象は平日の夜に起こることが多く、再作成された Pod の情報から、直近では <code>2022/12/21 21:47:39 (JST)</code> 頃に起きたようです。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod azure-vote-front-7655fcc46d-zp9v7</span></span><br><span class="line">  ...</span><br><span class="line">Start Time:       Wed, 21 Dec 2022 21:47:39 +0900</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>同じノードの Pod が一斉に再起動するため、開発のエンジニアはノードの調子が悪いのではないかと心配しています。事象は開発環境で発生したため、現時点でサービス影響は出ていないですが、今後の開発やサービス提供のために原因を突き止めたいとのことでした。<br>　<br>さてどうしましょう？ こんなこともあろうかと、監査ログの出力を有効にしていたのでした！</p></blockquote><p>Contoso 社では開発に kubectl と <a href="https://helm.sh/ja/">Helm</a> を使っています。事象の発生時間帯を調べると、これらのツールによる Pod 操作は見つからず、たしかにクラスター利用者の操作は無いようでした。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| where TimeGenerated between(datetime(2022/12/21 12:00:00) .. 1h)  // 21:00 - 22:00 (JST) のログを検索。クエリ上では UTC 表記</span><br><span class="line">| where RequestURI contains &quot;/api/v1/namespaces/default/pods&quot;       // default ネームスペースの Pod 操作に絞り込み</span><br><span class="line">| where Method !in (&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;)                         // 参照系リクエストは除く</span><br><span class="line">| where UserAgent contains &quot;kubectl&quot; or UserAgent contains &quot;helm&quot;   // kubectl もしくは helm による操作に絞り込み</span><br></pre></td></tr></table></figure><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit14.png" alt="kubectl や Helm による操作は見つからない"></p><p>Pod の delete リクエストのログを検索します。すると、事象の時間帯に複数の Pod が削除されていることがわかりました。<br>Pod が存在していたノードは <code>ResponseObject.spec.nodeName</code> から確認できます。ノード名がすべて <code>aks-nodepool2-20356098-vmss000001</code> となっており、同じノードの Pod が再起動するという開発エンジニアの証言とも一致します。<br><code>UserAgent</code> が kubelet と kube-controller-manager となっていることから、何らかの理由により Kubernetes 側から Pod の削除がリクエストされたと推察されます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| where TimeGenerated between(datetime(2022/12/21 12:00:00) .. 1h)</span><br><span class="line">| where RequestURI contains &quot;pods&quot;</span><br><span class="line">| where Method == &quot;delete&quot;</span><br><span class="line">| project TimeGenerated, Method, ResponseStatusCode, RequestURI, UserAgent, ResponseObject.spec.nodeName</span><br></pre></td></tr></table></figure><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit15.png" alt="ノード aks-nodepool2-20356098-vmss000001 の Pod が delete されている"></p><p>ノード <code>aks-nodepool2-20356098-vmss000001</code> に何が起きたのか手がかりを探します。このノードに関するリクエストを調べると、ノードに対して <code>unschedulable</code>フラグを設定・解除しているリクエストが見つかりました。<code>UserAgent</code> は <code>kured/v0.0.0</code> になっています。<code>unschedulable</code> は対象のノードへの Pod のスケジューリングを無効化する際に利用される設定値です (<code>kubectl cordon / uncordon</code> コマンドの操作に該当します)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| where TimeGenerated between(datetime(2022/12/21 12:00:00) .. 1h)</span><br><span class="line">| where RequestURI == &quot;/api/v1/nodes/aks-nodepool2-20356098-vmss000001&quot;</span><br><span class="line">| where Method !in (&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;)</span><br><span class="line">| where RequestObject != &quot;&#123;&#125;&quot; and RequestObject != &quot;skipped-too-big-size-object&quot;  // RequestObject が空、もしくは省略された場合 (後述) を除外</span><br></pre></td></tr></table></figure><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit16.png" alt="kured によってノードの unschedulable フラグが設定・解除されている"></p><p><code>UserAgent</code> に <code>kured/v0.0.0</code> を含むログを検索してみます。すると、今回削除された Pod に対して退避のリクエストを送っていることがわかりました (URI 末尾が <code>/evictions</code>) 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| where TimeGenerated between(datetime(2022/12/21 12:00:00) .. 1h)</span><br><span class="line">| where UserAgent contains &quot;kured/v0.0.0&quot;</span><br><span class="line">| where Method !in (&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;)</span><br></pre></td></tr></table></figure><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit17.png" alt="Kured によって Pod の eviction がリクエストされている"></p><p><a href="https://github.com/kubereboot/kured">Kured</a> はオープンソースのツールです。Linux OS のパッケージ アップデートの状態を確認し、アップデートの反映のために OS の再起動が必要となった場合に、自動的に OS を再起動します。</p><blockquote><p><strong>kured を使用した Linux ノードの再起動の処理 - Azure Kubernetes Service - Microsoft Learn</strong><br><a href="https://learn.microsoft.com/ja-JP/azure/aks/node-updates-kured">https://learn.microsoft.com/ja-JP/azure/aks/node-updates-kured</a></p></blockquote><p>Kured はノードを再起動する前に、対象ノードへの Pod スケジューリングを停止し、稼働中の Pod を別のノードへ退避させます (<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#drain">ノードのドレイン</a>)。今回発生した事象は、Kured によるノードの自動再起動が実施され、Pod の停止と別ノードでの再作成が発生したためであると判断できそうです。<br>(正確な判断には、Kured 自体が出力した動作ログをあわせて確認するのがよいでしょう)</p><p>Kured はいつクラスターにインストールされたのでしょうか？ 直近 1 週間でログを検索すると、関連するとみられるリソースが <code>kured</code> ネームスペースに作成されていることがわかりました。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| where TimeGenerated &gt;= ago(7d)</span><br><span class="line">| where audit contains &quot;kured&quot;</span><br><span class="line">| where Method !in (&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;)</span><br></pre></td></tr></table></figure><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit18.png" alt="Kured 関連リソースの作成リクエスト"></p><p>Kured は DaemonSet を利用して各ノードへ配置されます。作成された DaemonSet の内容を確認してみます。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit19.png" alt="DaemonSet の作成リクエスト"></p><p>コンテナー内で実行される <code>kured</code> コマンドにいくつかのオプションが渡されています (<code>spec.template.spec.containers[0].args</code>)。<code>--start-time=9pm</code> と<a href="https://kured.dev/docs/configuration/#setting-a-schedule">時間が指定</a>されており、この時間以降でノードの再起動が開始される設定になっていました。Pod 再起動の事象が、夜の時間帯に発生するという証言の裏付けが取れました。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;DaemonSet&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;apiVersion&quot;</span>: <span class="string">&quot;apps/v1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;my-release-kured&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;namespace&quot;</span>: <span class="string">&quot;kured&quot;</span>,</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;spec&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;template&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;spec&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;containers&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;kured&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;image&quot;</span>: <span class="string">&quot;ghcr.io/kubereboot/kured:1.12.0&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: [</span><br><span class="line">              <span class="string">&quot;/usr/bin/kured&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">              <span class="string">&quot;--ds-name=my-release-kured&quot;</span>,</span><br><span class="line">              <span class="string">&quot;--ds-namespace=kured&quot;</span>,</span><br><span class="line">              <span class="string">&quot;--reboot-command=/bin/systemctl reboot&quot;</span>,</span><br><span class="line">              <span class="string">&quot;--start-time=9pm&quot;</span>,         <span class="comment">// 夜9時以降にノード再起動を開始 (タイムウィンドウの設定)</span></span><br><span class="line">              <span class="string">&quot;--time-zone=Asia/Tokyo&quot;</span>,   <span class="comment">// タイムゾーン</span></span><br><span class="line">              <span class="string">&quot;--log-format=text&quot;</span></span><br><span class="line">            ],</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>[Contoso 社のストーリー - 後日談]</strong><br>後日、チームメンバーにヒアリングをしたところ、クラスター運用の効率化のために、<a href="https://learn.microsoft.com/ja-JP/azure/aks/node-updates-kured">AKS ドキュメントで紹介されていた Kured</a> の検証を行っていたことがわかりました。Pod 再起動の理由が解明でき、ノードの不調ではないことがわかったことで、開発のエンジニアも安心したようでした。<br>その後、Contoso 社ではクラスターの運用方法について検討が行われ、AKS のマネージド機能である<a href="https://learn.microsoft.com/ja-jp/azure/aks/auto-upgrade-cluster">自動アップグレード</a>や、<a href="https://learn.microsoft.com/ja-jp/azure/aks/planned-maintenance">計画メンテナンス機能</a> についても試してみることになりました。</p></blockquote><div class="alert is-success"><p class="alert-title">ヒント</p><p>ノードプールに VMSS を利用しているクラスターでは、ノードを最新状態にするために、<a href="https://learn.microsoft.com/ja-JP/azure/aks/node-image-upgrade">ノードイメージのアップグレード</a>が利用可能です。</p><p>スケール操作によって新規追加されたノードは、使用されているノードイメージをもとにインスタンスが起動します。そのため、古いバージョンのノードイメージが使用されている場合、日次で実行されるパッケージ アップデートまでの間は、ノードが最新状態ではない可能性がある点に留意しましょう。</p><p>VMSS を利用しているクラスターでは、定期的にノードイメージのアップグレード作業を実施する、もしくは自動アップグレード機能を利用することをおすすめします。</p><p>以前の AKS の既定である、ノードに可用性セットを使用するクラスターでは、ノードイメージが利用できないため、運用の自動化と OS を最新状態へ維持するために、Kured の利用が手段の 1 つとして挙げられます。</p></div><h3 id="注意点-RequestObject-ResponseObject-のサイズ制限"><a href="#注意点-RequestObject-ResponseObject-のサイズ制限" class="headerlink" title="注意点: RequestObject / ResponseObject のサイズ制限"></a>注意点: RequestObject / ResponseObject のサイズ制限</h3><p><code>RequestObject</code> および <code>ResponseObject</code> カラムは、値が Log Analytics カラムのサイズ上限に達している場合に記録されません。</p><blockquote><p><strong>Azure/AKS - Release 2022-08-14</strong><br>Remove responseObject from kube-audit logs when its size is reaching log analytics column size limit (32K) and customer enables kube-audit/kube-audit-admin diagnostics.<br><a href="https://github.com/Azure/AKS/releases/tag/2022-08-14">https://github.com/Azure/AKS/releases/tag/2022-08-14</a></p></blockquote><p>サイズ上限に達した場合は <code>&quot;skipped-too-big-size-object&quot;</code> というメッセージに置き換えられます。監査ログによる調査やクエリの作成時には、<code>RequestObject</code> と <code>ResponseObject</code> の情報が取得できない場合があることに注意しましょう。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit20.png" alt="サイズ上限に達したログの例"></p><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>本記事では、Kubernetes の監査ログの紹介と、AKS・Azure Monitor で実際にログ情報を利用する様子を紹介しました。監査ログを活用することで、過去にクラスターで発生した操作やオブジェクトの変更履歴を調べることができます。我々サポート エンジニアも AKS クラスターの調査をする際に、Kusto のクエリを利用して Kubernetes や AKS 基盤のさまざまなログを調査しています。</p><p>監査ログを活用するために、Request / Response Object の構造や、ある操作をしたときに何の API リクエストが送信されるのかについて把握していると役立ちます。Kubernetes API のリファレンスが参考になります。</p><blockquote><p><strong>Kubernetes Documentation / Reference / Kubernetes API</strong><br><a href="https://kubernetes.io/docs/reference/kubernetes-api/">https://kubernetes.io/docs/reference/kubernetes-api/</a></p></blockquote><p>また、kubectl コマンドのデバッグ出力 (<code>kubectl --v=8</code>) を有効にすると、API サーバーへのリクエスト内容が確認できるため、ログと照らし合わせて動作を確認するのに便利です。ログ出力を有効にして、クラスターを操作しながら実際にどのようなログが出力されるか試してみるとわかりやすいです。監査ログをみることで、トラブルシューティングだけではなく、Kubernetes クラスターがどのように動作をしているのか、理解をより深めることができるでしょう。</p><p>今回紹介しました監査ログが、AKS をよりご活用いただくうえでのご参考になりましたら幸いです。また、AKS のご利用において、お困りの点やご不明点がありました際は、いつでも Azure サポートまでお気兼ねなくご相談ください。</p><h2 id="参考リンク"><a href="#参考リンク" class="headerlink" title="参考リンク"></a>参考リンク</h2><ul><li>Kubernetes に Audit log を求めるのは間違っているだろうか？<ul><li>@makocchi さんによる CloudNative Days 2019 / OpenStack Days 2019 (コンテナー / クラウド ネイティブに関する国内カンファレンス) の発表資料</li><li><a href="https://speakerdeck.com/makocchi/cndt2019-kubernetes-audit-log-c4d4c5f6-6058-40f9-a5fc-abbb36073a19">https://speakerdeck.com/makocchi/cndt2019-kubernetes-audit-log-c4d4c5f6-6058-40f9-a5fc-abbb36073a19</a></li></ul></li></ul><hr><p>最後まで読んでいただきありがとうございました！<br><a href="https://qiita.com/advent-calendar/2022/microsoft-azure-tech">Microsoft Azure Tech Advent Calendar 2022</a> は明日が最終日となります。是非ご覧くださいー！</p><p>本年は多くのお客様にお世話になりました。ありがとうございました。<br>来年もみなさまにとって素晴らしい年でありますように、心よりお祈り申し上げます。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;この記事は &lt;a href=&quot;https://qiita.com/advent-calendar/2022/microsoft-azure-tech&quot;&gt;Microsoft Azure Tech Advent Calendar 2022&lt;/a&gt; の 24 日目の記事になります🎅&lt;/p&gt;
&lt;p&gt;こんにちは。Azure テクニカル サポートチームの桐井です。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://learn.microsoft.com/ja-jp/azure/aks/intro-kubernetes&quot;&gt;Azure Kubernetes Service (AKS)&lt;/a&gt; のクラスターを利用しているときに、アプリケーションがデプロイされたタイミングや、ノードのステータスがいつどのような理由で変わったのかなど、過去にクラスターで起こったイベントの履歴を確認したい場合があります。Kubernetes の監査ログを活用すると、これらのイベントをログから確認できるようになります。&lt;/p&gt;
&lt;p&gt;本記事では、Kubernetes の監査ログの紹介と、AKS において監査ログ利用する方法を、実例を交えて解説します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Containers" scheme="https://jpaztech.github.io/blog/tags/Containers/"/>
    
    <category term="Azure Kubernetes Service (AKS)" scheme="https://jpaztech.github.io/blog/tags/Azure-Kubernetes-Service-AKS/"/>
    
  </entry>
  
  <entry>
    <title>AKS で利用可能なオートスケールについて</title>
    <link href="https://jpaztech.github.io/blog/containers/aks-autoscaling/"/>
    <id>https://jpaztech.github.io/blog/containers/aks-autoscaling/</id>
    <published>2022-12-24T03:00:00.000Z</published>
    <updated>2023-08-18T00:59:11.254Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは！ Azure テクニカル サポート チームの川畑です。</p><p>Kubernetes を利用するにあたり、負荷に応じてワークロードを動的に増減させるオートスケーリングの構成を取ることがあります。</p><p>この記事では、 Azure Kubernetes Service (AKS) を利用している環境を想定し、Pod およびノードのオートスケーリングの設定と動作についてご紹介します。</p><span id="more"></span><hr><h2 id="スケーリングとは？水平オートスケーラー-HPA"><a href="#スケーリングとは？水平オートスケーラー-HPA" class="headerlink" title="スケーリングとは？水平オートスケーラー (HPA)"></a>スケーリングとは？水平オートスケーラー (HPA)</h2><p>スケーリングには、スケールアップ / スケールダウンとスケールアウト / スケール インの 2 種類があります。</p><p>スケールアップは、垂直スケールとも呼ばれ、1 台あたりのコンピュート リソースを増やすことでシステムの性能を上げる手段となります。<br>AKS では、AKS ノードとして利用している Azure 仮想マシンのサイズ (vCPU 数) を増やす、Pod に割り当てるリソース量を増やすなど、ノードや Podのコンピュート リソースを増やす方法が挙げられます。</p><p>次に、スケールアウトは、水平スケールとも呼ばれ、コンピュート リソースは変えず、ノードの数や Pod のレプリカ数を増やすことでシステムの性能を上げる手段となります。</p><p>これらのスケーリングの操作は、クラスターの利用者によって手動で実施される場合と、オートスケールの機能によって自動で実施される場合があります。<br>表でまとめると次のような形となります。</p><table><thead><tr><th></th><th>自動/手動</th><th>水平/垂直</th><th>Pod/ノード</th></tr></thead><tbody><tr><td><a href="https://learn.microsoft.com/ja-jp/azure/aks/concepts-scale#horizontal-pod-autoscaler">水平オートスケーラー (HPA)</a></td><td>自動</td><td>水平</td><td>Pod</td></tr><tr><td><a href="https://learn.microsoft.com/ja-jp/azure/aks/cluster-autoscaler">クラスター オートスケーラー</a></td><td>自動</td><td>水平</td><td>ノード</td></tr><tr><td><a href="https://learn.microsoft.com/ja-JP/azure/aks/keda-about">KEDA</a> *1</td><td>自動</td><td>水平</td><td>Pod</td></tr><tr><td><a href="https://learn.microsoft.com/ja-jp/azure/aks/vertical-pod-autoscaler">垂直オートスケーラー (VPA)</a> *1</td><td>自動</td><td>垂直</td><td>Pod</td></tr><tr><td>レプリカ数の定義変更</td><td>手動</td><td>水平</td><td>Pod</td></tr><tr><td><a href="https://learn.microsoft.com/ja-jp/azure/aks/scale-cluster?tabs=azure-cli">Azure CLI (az aks acale) / Azure Portal</a></td><td>手動</td><td>水平</td><td>ノード</td></tr><tr><td><a href="https://learn.microsoft.com/ja-jp/azure/aks/resize-node-pool?tabs=azure-cli">ノード プールのサイズ変更</a> *2</td><td>手動</td><td>垂直</td><td>ノード</td></tr></tbody></table><p>*1 2022.12.24 時点ではプレビューの機能です。<br>*2 ドキュメントのタイトルは「変更」となっていますが、新しいサイズでノードプールを作成・削除する手順となります。</p><p>今回はこれらの方法のうち、自動でスケーリング可能な水平オートスケーラー (HPA) とクラスター オートスケーラーについて紹介します。</p><h2 id="Pod-のオートスケーリング-HPA"><a href="#Pod-のオートスケーリング-HPA" class="headerlink" title="Pod のオートスケーリング (HPA)"></a>Pod のオートスケーリング (HPA)</h2><p>AKS では、Pod のレプリカ数を負荷に応じてスケーリングする Pod の水平オートスケーラー (HPA) が使用できます。<br>HPA は、Kubernetes の標準 API リソースであり、AKS 固有の機能ではありません。<br>そのため、HPA の内容に関しましては、下記 Kubernetes 公式ドキュメントの内容に準拠します。</p><blockquote><p>ご参考情報：Horizontal Pod Autoscalerウォークスルー | Kubernetes<br><a href="https://kubernetes.io/ja/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/">https://kubernetes.io/ja/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/</a></p></blockquote><p>HPA では、ノード上のメトリクス情報を kubelet を経由して Kubernetes クラスター内に存在するメトリクス サーバーに収集します。<br>なお、このメトリクス サーバーは現時点でサポートされている AKS クラスターでは標準でデプロイされております。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -n kube-system -l k8s-app=metrics-server</span></span><br><span class="line">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">metrics-server-5f87fccc7d-724vf   2/2     Running   0          2d11h</span><br><span class="line">metrics-server-5f87fccc7d-bl2d4   2/2     Running   0          2d11h</span><br></pre></td></tr></table></figure><p>メトリクス サーバーは収集された情報より、Pod が使用している CPU やメモリ等のメトリクス情報に基づき Deployment、ReplicaSet または StatefulSet といったレプリケーション コントローラー内のPodのレプリカ数をスケーリングします。</p><p>これによって、負荷に応じて Pod のレプリカ数が増減します。</p><p>それでは、実際に AKS クラスターを利用して HPA の設定をします。</p><h3 id="HPA-の挙動を確認してみる"><a href="#HPA-の挙動を確認してみる" class="headerlink" title="HPA の挙動を確認してみる"></a>HPA の挙動を確認してみる</h3><p>ここでは、AKS のチュートリアルで利用されているサンプル アプリケーション (azure-vote) を用いて確認します。<br>サンプル アプリケーションをローカル端末にクローンします。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/Azure-Samples/azure-voting-app-redis.git</span></span><br></pre></td></tr></table></figure><p>上記コマンドによってクローンされたマニフェスト ファイルを確認し、コンテナーにリソース要求が設定されていることを確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> less ./azure-voting-app-redis/azure-vote-all-in-one-redis.yaml</span></span><br></pre></td></tr></table></figure><p>azure-vote-front コンテナーでは、次のようにリソース要求が設定されていることが確認できます。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">azure-vote-front</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">mcr.microsoft.com/azuredocs/azure-vote-front:v1</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">250m</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">500m</span></span><br></pre></td></tr></table></figure><p>上記リソース要求を確認すると、コンテナーをデプロイするために必要なリソースは、250 ミリ CPU であり、制限は 500 ミリ CPU となっていることが確認できました。<br>HPA では、対象のレプリケーション コントローラー内の Pod に設定された、リソース要求に対する使用率の平均を計算します。</p><p>それでは、当該 Pod をデプロイします。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f ./azure-voting-app-redis/azure-vote-all-in-one-redis.yaml</span></span><br></pre></td></tr></table></figure><p>デプロイされた Pod を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">azure-vote-back-5fb9656dff-6ln9w    1/1     Running   0          47s</span><br><span class="line">azure-vote-front-7589b695dd-wb7mq   1/1     Running   0          47s</span><br></pre></td></tr></table></figure><p>azure-vote-front の Pod が作成されていることを確認できました。</p><p>それでは、ここから HPA の設定をします。</p><p>HPA の設定は、HorizontalPodAutoscaler リソースを用いて定義することが可能となり、kubectl autoscale コマンドもしくは、マニフェスト ファイルを用いて作成することが可能となります。</p><p>今回の検証では、Deplyoment “azure-vote-front” 内の全 Pod の平均 CPU 使用率が 50% を目標に、最小 3 台、最大 10 台まで Pod のレプリカ数を増減させるように設定します。</p><p>この設定を kubectl autoscale コマンドにて実施する場合は、下記コマンドとなります。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl autoscale deployment azure-vote-front --cpu-percent=50 --min=3 --max=10</span></span><br></pre></td></tr></table></figure><p>この HPA によって Deplyoment “azure-vote-front” 内の Pod のレプリカ数は最小 3 台となるため、先ほど確認した Pod のレプリカ数は 1 台でしたが、3 台に増えていることが確認できます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -l app=azure-vote-front</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">azure-vote-front-7589b695dd-d7psh   1/1     Running   0          98s</span><br><span class="line">azure-vote-front-7589b695dd-km4hq   1/1     Running   0          98s</span><br><span class="line">azure-vote-front-7589b695dd-wb7mq   1/1     Running   0          11m</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get hpa</span></span><br><span class="line">NAME               REFERENCE                     TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">azure-vote-front   Deployment/azure-vote-front   2%/50%    3         10        3          110s</span><br></pre></td></tr></table></figure><p>想定どおり、Pod のレプリカ数が HPA の設定にしたがって Pod のレプリカ数が増えたことが確認できました。</p><p>次に、Pod に負荷をかけることで、HPA によって Pod のレプリカ数が増えることを確認します。<br>まずは、事前に現在の Pod の CPU 負荷状況を kubectl top pods コマンドを用いて確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl top pods -l app=azure-vote-front</span></span><br><span class="line">NAME                                CPU(cores)   MEMORY(bytes)</span><br><span class="line">azure-vote-front-7589b695dd-d7psh   1m           60Mi</span><br><span class="line">azure-vote-front-7589b695dd-km4hq   1m           58Mi</span><br><span class="line">azure-vote-front-7589b695dd-wb7mq   1m           45Mi</span><br></pre></td></tr></table></figure><p>現在の Pod の CPU 使用量が低い状況であることが確認できました。<br>次に、CPU に負荷をかけるために、今回は stress コマンドを用います。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> -it azure-vote-front-7589b695dd-d7psh -- stress -c 1</span></span><br><span class="line">stress: info: [330] dispatching hogs: 1 cpu, 0 io, 0 vm, 0 hdd</span><br></pre></td></tr></table></figure><p>stress コマンドによって、Pod “azure-vote-front-7589b695dd-d7psh” の CPU に負荷をかけ始めました。再度 kubectl top pods コマンドを用いて CPU の負荷状況を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl top pods -l app=azure-vote-front</span></span><br><span class="line">NAME                                CPU(cores)   MEMORY(bytes)</span><br><span class="line">azure-vote-front-7589b695dd-d7psh   312m         65Mi</span><br><span class="line">azure-vote-front-7589b695dd-km4hq   1m           58Mi</span><br><span class="line">azure-vote-front-7589b695dd-wb7mq   1m           45Mi</span><br></pre></td></tr></table></figure><p>先ほど 2 ミリ CPU 程度であったのに対して、312 ミリ CPU 程リソースを消費していることが確認できました。<br>ここで HPA の状況ならびに Pod の稼働状況を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get hpa</span></span><br><span class="line">NAME               REFERENCE                     TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">azure-vote-front   Deployment/azure-vote-front   67%/50%   3         10        4          30m</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -l app=azure-vote-front</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">azure-vote-front-7589b695dd-4q79q   1/1     Running   0          101s</span><br><span class="line">azure-vote-front-7589b695dd-d7psh   1/1     Running   0          30m</span><br><span class="line">azure-vote-front-7589b695dd-km4hq   1/1     Running   0          30m</span><br><span class="line">azure-vote-front-7589b695dd-wb7mq   1/1     Running   0          39m</span><br></pre></td></tr></table></figure><p>stress コマンドを用いて CPU の負荷をかけたことによって、Pod のレプリカ数が 3 から 4 に増えたことが確認できました。<br>最後に stress コマンドを停止し、増えた Pod が自動で削除されることも確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt; - Control + Cキー によってプロセスを終了する</span><br><span class="line">command terminated with exit code 130</span><br></pre></td></tr></table></figure><p>再度 kubectl top pods コマンドを用いて CPU の負荷状況を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl top pods -l app=azure-vote-front</span></span><br><span class="line">NAME                                CPU(cores)   MEMORY(bytes)</span><br><span class="line">azure-vote-front-7589b695dd-4q79q   1m           39Mi</span><br><span class="line">azure-vote-front-7589b695dd-d7psh   1m           65Mi</span><br><span class="line">azure-vote-front-7589b695dd-km4hq   1m           58Mi</span><br><span class="line">azure-vote-front-7589b695dd-wb7mq   1m           45Mi</span><br></pre></td></tr></table></figure><p>Pod “azure-vote-front-7589b695dd-d7psh” の CPU 使用量が減少したことが確認できました。<br>その後、しばらくした後に、次のように Pod のレプリカ数が最小の 3 に戻ることが確認できます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get hpa</span></span><br><span class="line">NAME               REFERENCE                     TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">azure-vote-front   Deployment/azure-vote-front   0%/50%    3         10        4          38m</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get hpa</span></span><br><span class="line">NAME               REFERENCE                     TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">azure-vote-front   Deployment/azure-vote-front   0%/50%    3         10        3          38m</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">azure-vote-front-7589b695dd-d7psh   1/1     Running   0          39m</span><br><span class="line">azure-vote-front-7589b695dd-km4hq   1/1     Running   0          39m</span><br><span class="line">azure-vote-front-7589b695dd-wb7mq   1/1     Running   0          48m</span><br></pre></td></tr></table></figure><p>このように HPA を利用することで、Pod の負荷状況に応じて Pod のレプリカ数を自動で増減可能なことを確認しました。</p><h2 id="クラスター-オートスケーラーについて"><a href="#クラスター-オートスケーラーについて" class="headerlink" title="クラスター オートスケーラーについて"></a>クラスター オートスケーラーについて</h2><p>AKS では、ノードをオートスケールするための機能として、クラスター オートスケーラーが提供されています。<br>クラスター オートスケーラーを利用することで、新規 Pod がデプロイ可能な空きノードが不足し、Pending (割り当て不可) 状態となった際にノードである Azure 仮想マシンの数を自動で増減することが可能となります。<br>これによって、Pod のデプロイに必要なノード数のみ稼働させることで、コストの最適化などが期待されます。</p><div class="alert is-important"><p class="alert-title">重要</p><p>クラスター オートスケーラーは、CPU やメモリ等のリソースの使用率を監視し自動でスケールする機能ではありません。</p><p>新規 Pod がデプロイ可能な空きノードが不足し、Pending (割り当て不可) 状態となった際に自動でスケールアウトする機能となります。</p></div><div class="alert is-warning"><p class="alert-title">警告</p><p>AKS のクラスター オートスケーラーを利用する場合、VMSS のオートスケール機能を有効にしないでください。</p><p>AKS では、VMSS などの IaaS リソースの API を用いて直接変更することはサポート外となります。</p><p>いずれの機能も有効にした場合は、 VMSS へ直接変更を加えたことにより、AKS クラスターがサポートされない状態になる恐れや、2 つのオートスケ</p><p>ールの処理が競合することで、ノードの増減が想定通りに動作しない可能性がございます。</p><blockquote><p>ご参考情報：エージェント ノードのユーザー カスタマイズ</p><p><a href="https://learn.microsoft.com/ja-jp/azure/aks/support-policies#user-customization-of-agent-nodes">https://learn.microsoft.com/ja-jp/azure/aks/support-policies#user-customization-of-agent-nodes</a></p><p>　</p><p>ご参考情報： AKS クラスターの作成とクラスター オートスケーラーの有効化</p><p><a href="https://learn.microsoft.com/ja-jp/azure/aks/cluster-autoscaler#create-an-aks-cluster-and-enable-the-cluster-autoscaler">https://learn.microsoft.com/ja-jp/azure/aks/cluster-autoscaler#create-an-aks-cluster-and-enable-the-cluster-autoscaler</a></p></div></blockquote><p>そのため、適切にクラスター オートスケーラーを利用するためには、各 Pod に適切なリソース要求を設定することが重要となります。</p><p>それでは、実際に AKS クラスターを利用してクラスター オートスケーラーの挙動を確認します。</p><h3 id="クラスター-オートスケーラーの挙動を確認してみる"><a href="#クラスター-オートスケーラーの挙動を確認してみる" class="headerlink" title="クラスター オートスケーラーの挙動を確認してみる"></a>クラスター オートスケーラーの挙動を確認してみる</h3><p>クラスター オートスケーラーの挙動を確認するにあたり、まずはユーザー ノードプールを追加します。<br>ここでは、ノード数が 1、仮想マシンのサイズが Standard_DS2_v2 (2vCPU, 7GiB) のノード プールを追加します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az aks nodepool add \</span></span><br><span class="line"><span class="bash">    --resource-group &lt;リソースグループ名&gt; \</span></span><br><span class="line"><span class="bash">    --cluster-name &lt;クラスター名&gt; \</span></span><br><span class="line"><span class="bash">    --name usernp1 \</span></span><br><span class="line"><span class="bash">    --node-count 1 \</span></span><br><span class="line"><span class="bash">    --mode User \</span></span><br><span class="line"><span class="bash">    --node-vm-size Standard_ DS2_v2 \</span></span><br><span class="line"><span class="bash">    --labels nodelabel=catest</span></span><br></pre></td></tr></table></figure><p>追加されたノードの情報を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get nodes</span></span><br><span class="line">NAME                                STATUS   ROLES   AGE     VERSION</span><br><span class="line">aks-nodepool1-12285779-vmss000000   Ready    agent   4h14m   v1.24.6</span><br><span class="line">aks-nodepool1-12285779-vmss000001   Ready    agent   4h13m   v1.24.6</span><br><span class="line">aks-nodepool1-12285779-vmss000002   Ready    agent   4h13m   v1.24.6</span><br><span class="line">aks-usernp1-70474131-vmss000000     Ready    agent   3m      v1.24.6</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe node aks-usernp1-70474131-vmss000000</span></span><br><span class="line">&lt;中略&gt;</span><br><span class="line">Allocatable:</span><br><span class="line">  cpu:                1900m</span><br><span class="line">  ephemeral-storage:  119703055367</span><br><span class="line">  hugepages-1Gi:      0</span><br><span class="line">  hugepages-2Mi:      0</span><br><span class="line">  memory:             4670956Ki</span><br><span class="line">  pods:               110</span><br><span class="line">&lt;中略&gt;</span><br></pre></td></tr></table></figure><p>ノードが追加されていることを確認しました。<br>それでは、このノード プールにリソース要求を設定した Pod をデプロイするために、Deployments のマニフェスト ファイルを作成します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat &lt;&lt; <span class="string">EOF &gt;&gt; ca-test-pod.yaml</span></span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        nodelabel: catest</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 2.5Gi</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>上記定義によって、nodelabel キーにcatest を持つノードにのみ nginx Pod が配置されます。これによって、他のノードに Pod がデプロイされることを防げます。<br>それでは、このマニフェスト ファイルに従い、Deployment を作成します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f ca-test-pod.yaml</span></span><br><span class="line">deployment.apps/nginx created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -o wide</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP           NODE                              NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-67d6486785-7rj7r   0/1     Pending   0          18s   &lt;none&gt;       &lt;none&gt;                            &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-67d6486785-hfcmw   1/1     Running   0          18s   10.244.3.5   aks-usernp1-70474131-vmss000000   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p>Pod “nginx-67d6486785-7rj7r” が Pending 状態であることが確認できました。 原因を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod nginx-67d6486785-7rj7r</span></span><br><span class="line"></span><br><span class="line">&lt;中略&gt;</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age    From               Message</span><br><span class="line">  ----     ------            ----   ----               -------</span><br><span class="line">  Warning  FailedScheduling  2m54s  default-scheduler  0/4 nodes are available: 1 Insufficient memory, 3 node(s) didn&#x27;t match Pod&#x27;s node affinity/selector. preemption: 0/4 nodes are available: 1 No preemption victims found for incoming pod, 3 Preemption is not helpful for scheduling.</span><br></pre></td></tr></table></figure><p>このメッセージは、クラスター内の全 4 台のノードのうち、1 ノードはメモリの空き容量が不足しており、他 3 ノードがセレクターを満たさず、Pod をスケジューリング可能なノードが見つからなかったことを示します。</p><p>これによって、ノード プール “usernp1” では、リソースの不足に伴い Pod が Pending となる状況となりました。</p><p>この状態で、ノード プール “usernp1” に対して、クラスター オートスケーラーを有効にします。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az aks nodepool update \</span></span><br><span class="line"><span class="bash">  --resource-group &lt;リソースグループ名&gt; \</span></span><br><span class="line"><span class="bash">  --cluster-name &lt;クラスター名&gt; \</span></span><br><span class="line"><span class="bash">  --name usernp1 \</span></span><br><span class="line"><span class="bash">  --enable-cluster-autoscaler \</span></span><br><span class="line"><span class="bash">  --min-count 1 \</span></span><br><span class="line"><span class="bash">  --max-count 3</span></span><br></pre></td></tr></table></figure><p>クラスター オートスケーラーを有効化したので、ノードが追加されていることを確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get nodes</span></span><br><span class="line">NAME                                STATUS   ROLES   AGE     VERSION</span><br><span class="line">aks-nodepool1-12285779-vmss000000   Ready    agent   4h47m   v1.24.6</span><br><span class="line">aks-nodepool1-12285779-vmss000001   Ready    agent   4h47m   v1.24.6</span><br><span class="line">aks-nodepool1-12285779-vmss000002   Ready    agent   4h46m   v1.24.6</span><br><span class="line">aks-usernp1-70474131-vmss000000     Ready    agent   36m     v1.24.6</span><br><span class="line">aks-usernp1-70474131-vmss000001     Ready    agent   34s     v1.24.6</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -o wide</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP           NODE                              NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-67d6486785-7rj7r   1/1     Running   0          14m   10.244.4.2   aks-usernp1-70474131-vmss000001   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-67d6486785-hfcmw   1/1     Running   0          14m   10.244.3.5   aks-usernp1-70474131-vmss000000   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p>期待どおりノード プール “usernp1” に新規ノード “usernp1-70474131-vmss000001”が作成され、Pod “nginx-67d6486785-7rj7r” がデプロイされていることが確認できました。</p><p>最後に Pod のレプリカ数を 1 に減らし、ノードが自動削除されることを確認します。<br>マニフェスト ファイルを修正し、Pod のレプリカ数を 1 に減らした後に、再度マニフェスト ファイルを適用します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f ca-test-pod.yaml</span></span><br><span class="line">deployment.apps/nginx configured</span><br></pre></td></tr></table></figure><p>これによって、Pod のレプリカ数およびノードが減っていることを確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -o wide</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP           NODE                              NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-67d6486785-hfcmw   1/1     Running   0          19m   10.244.3.5   aks-usernp1-70474131-vmss000000   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get nodes</span></span><br><span class="line">NAME                                STATUS   ROLES   AGE    VERSION</span><br><span class="line">aks-nodepool1-12285779-vmss000000   Ready    agent   5h3m   v1.24.6</span><br><span class="line">aks-nodepool1-12285779-vmss000001   Ready    agent   5h3m   v1.24.6</span><br><span class="line">aks-nodepool1-12285779-vmss000002   Ready    agent   5h3m   v1.24.6</span><br><span class="line">aks-usernp1-70474131-vmss000000     Ready    agent   52m    v1.24.6</span><br></pre></td></tr></table></figure><p>このように クラスター オートスケーラーを利用することで、ノード上のリソース不足が原因で Pending となった Pod が発生した際にノード プール内のノードの数を自動で増え、リソースの使用率が低下した際にノードの数が自動で減ることが確認できました。</p><h3 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h3><p>この記事では、HPA とクラスター オートスケーラーによる Pod とノードのオートスケーリングのしくみについて、サンプル アプリケーションを例にご紹介しました。設定した条件に応じて、自動でスケールアウトされることが確認いただけたかと思います。<br>こういったオートスケールの設定を適切にお使いいただくことで、お客様のワークロードの可用性を高めることができるかと存じますので、ご参考にいただけますと幸いです。</p><p>本稿が皆様のお役に立ちましたら幸いです。</p><p>最後まで読んでいただきありがとうございました！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは！ Azure テクニカル サポート チームの川畑です。&lt;/p&gt;
&lt;p&gt;Kubernetes を利用するにあたり、負荷に応じてワークロードを動的に増減させるオートスケーリングの構成を取ることがあります。&lt;/p&gt;
&lt;p&gt;この記事では、 Azure Kubernetes Service (AKS) を利用している環境を想定し、Pod およびノードのオートスケーリングの設定と動作についてご紹介します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Containers" scheme="https://jpaztech.github.io/blog/tags/Containers/"/>
    
    <category term="Azure Kubernetes Service (AKS)" scheme="https://jpaztech.github.io/blog/tags/Azure-Kubernetes-Service-AKS/"/>
    
  </entry>
  
  <entry>
    <title>Azure Linux エージェント (waagent) に出力されるメッセージについて</title>
    <link href="https://jpaztech.github.io/blog/vm/vmagent-error/"/>
    <id>https://jpaztech.github.io/blog/vm/vmagent-error/</id>
    <published>2022-12-23T03:00:00.000Z</published>
    <updated>2023-08-18T00:59:11.810Z</updated>
    
    <content type="html"><![CDATA[<p>この記事は <a href="https://qiita.com/advent-calendar/2022/microsoft-azure-tech">Microsoft Azure Tech Advent Calendar 2022</a> の 23 日目の記事です。</p><p>こんにちは、Azure テクニカル サポートの木下です。<br>今回は、よくお問い合わせいただきます、Azure Linux エージェント (waagent) に出力されるメッセージについてご紹介いたします。 </p><span id="more"></span> <p>Azure Linux VM の /var/log/messages において、以下のような Error 句を含むメッセージが出力されたため、原因を知りたいというお問い合わせをいただくことがございます。 </p><p>メッセージ例） </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dec 11 06:16:46 testvm python: 2022-12-15T21:16:46.414141Z ERROR MonitorHandler ExtHandler An error occurred <span class="keyword">in</span> the monitor thread main loop; will skip the current iteration. </span><br><span class="line">Dec 11 06:16:46 testvm python: [ProtocolError] Error fetching goal state </span><br><span class="line">Dec 11 06:16:46 testvm python: Inner error: [ResourceGoneError] [HTTP Failed] [410: Gone] The page you requested was removed. </span><br></pre></td></tr></table></figure><h2 id="1-Error-句を含むメッセージの内容について"><a href="#1-Error-句を含むメッセージの内容について" class="headerlink" title="1. Error 句を含むメッセージの内容について"></a>1. Error 句を含むメッセージの内容について</h2><p>Azure Linux エージェントは新しい更新情報などがないかの確認のため、VM と拡張機能の状態を物理ホストへ報告し、定期的に目標状態 (Goal State) の取得を行っております。<br>上記のような Error 句を含むメッセージは、この目標状態の取得に失敗した場合に出力されるエラーならびに関連のメッセージとなります。<br>目標状態の取得は、Azure 基盤内部の専用のエンドポイントとのやり取りで行われておりますが、このエンドポイントについては、稼働率が 100 % とすることは叶わず、拡張機能などの動作に支障がない範囲でメンテナンスが行われております。 </p><p>そのため、これらの Error 句を含むメッセージは、エンドポイントまでの通信経路で何らかの一時的な接続断やエンドポイント側のメンテナンスなどが発生し、目標状態の取得に失敗した際に発生することが想定となります。 </p><p>Azure Linux エージェント (waagent) については、以下公開情報におまとめしておりますので、詳細については、こちらをご参照ください。 </p><blockquote><p>参考） </p><ul><li><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/extensions/agent-linux">Azure Linux エージェントの理解と使用</a> </li></ul></blockquote><h2 id="2-影響の有無について"><a href="#2-影響の有無について" class="headerlink" title="2. 影響の有無について"></a>2. 影響の有無について</h2><p>Azure Linux エージェントの更新情報の確認は、数秒間隔で常に行われております。一時的に失敗していた期間が存在していたとしても、VM の動作へ影響を与えるものではないため、その後成功 (=Error 句を含むメッセージの出力が停止) していれば問題のないものと判断いただくことが可能です。<br>従いまして、このメッセージの出力が一時的なものであれば、基本的にはご放念いただいて問題なく、また、お客様側で何らかの対処をいただく必要はございません。 </p><p>一方で、Azure Linux エージェント自体が何らかの動作不具合となってしまった等が原因で恒常的にエンドポイントとの通信に失敗している場合、Azure 基盤側が「Azure Linux エージェント (waagent) と通信ができない状態」とみなし、エージェントが管理している拡張機能の動作 、例えば、Azure Backup の取得等に失敗してしまうケースがあります。この場合は、是正を行う必要がある状態となります。 </p><p>まずは、Error 句を含むメッセージが出力された VM のエージェントの状態が Ready なのか、Not Ready となってしまっているのかを Azure ポータル や Azure PowerShell / Azure CLI のコマンドの実行結果よりご確認ください。 </p><h2 id="3-エージェントの状態の確認方法について"><a href="#3-エージェントの状態の確認方法について" class="headerlink" title="3. エージェントの状態の確認方法について"></a>3. エージェントの状態の確認方法について</h2><h3 id="▼Azure-ポータルの場合"><a href="#▼Azure-ポータルの場合" class="headerlink" title="▼Azure ポータルの場合"></a>▼Azure ポータルの場合</h3><p><img src="/blog/vm/vmagent-error/vmagent-error01.png"> </p><h3 id="▼Azure-PowerShell-の場合"><a href="#▼Azure-PowerShell-の場合" class="headerlink" title="▼Azure PowerShell の場合"></a>▼Azure PowerShell の場合</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PS &gt; <span class="variable">$vm</span> = Get-AzVm -ResourceGroupName &lt;RGName&gt; -Name &lt;VMName&gt; -Status </span><br><span class="line"></span><br><span class="line"><span class="comment"># エージェントの状態表示 (DisplayStatus が Ready であるかを確認) </span></span><br><span class="line">PS &gt; <span class="variable">$vm</span>.VMAgent.Statuses[0] </span><br><span class="line"></span><br><span class="line">Code          : ProvisioningState/succeeded </span><br><span class="line">Level         : Info </span><br><span class="line">DisplayStatus : Ready </span><br><span class="line">Message       : GuestAgent is running and processing the extensions. </span><br><span class="line">Time          : 11/28/2022 3:53:17 AM </span><br></pre></td></tr></table></figure><h3 id="▼Azure-CLI-の場合"><a href="#▼Azure-CLI-の場合" class="headerlink" title="▼Azure CLI の場合"></a>▼Azure CLI の場合</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># VM の状態情報を取得し、エージェントの状態を抽出して表示 (displayStatus が Ready であるかを確認) </span></span><br><span class="line">az vm get-instance-view -g &lt;RGName&gt; -n &lt;VMName&gt; --query <span class="string">&#x27;&#123;AgentStatus:instanceView.vmAgent.statuses&#125;&#x27;</span> </span><br><span class="line">&#123; </span><br><span class="line">  <span class="string">&quot;AgentStatus&quot;</span>: [ </span><br><span class="line">    &#123; </span><br><span class="line">      <span class="string">&quot;code&quot;</span>: <span class="string">&quot;ProvisioningState/succeeded&quot;</span>, </span><br><span class="line">      <span class="string">&quot;displayStatus&quot;</span>: <span class="string">&quot;Ready&quot;</span>, </span><br><span class="line">      <span class="string">&quot;level&quot;</span>: <span class="string">&quot;Info&quot;</span>, </span><br><span class="line">      <span class="string">&quot;message&quot;</span>: <span class="string">&quot;GuestAgent is running and processing the extensions.&quot;</span>, </span><br><span class="line">      <span class="string">&quot;time&quot;</span>: <span class="string">&quot;2022-11-28T03:56:17.923000+00:00&quot;</span> </span><br><span class="line">    &#125; </span><br><span class="line">  ] </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Not Readyの状態が継続して発生している場合の想定されるシナリオと対処策をおまとめしたブログ記事もございますので、想定されるシナリオに該当するかの切り分け方法としてご参照くださいませ。 </p><blockquote><p>参考） </p><ul><li><a href="https://jpaztech.github.io/blog/vm/vmagent-notready/">「仮想マシン エージェントの状態が準備できていません」について</a> </li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;この記事は &lt;a href=&quot;https://qiita.com/advent-calendar/2022/microsoft-azure-tech&quot;&gt;Microsoft Azure Tech Advent Calendar 2022&lt;/a&gt; の 23 日目の記事です。&lt;/p&gt;
&lt;p&gt;こんにちは、Azure テクニカル サポートの木下です。&lt;br&gt;今回は、よくお問い合わせいただきます、Azure Linux エージェント (waagent) に出力されるメッセージについてご紹介いたします。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Linux" scheme="https://jpaztech.github.io/blog/tags/Linux/"/>
    
    <category term="VM Agent" scheme="https://jpaztech.github.io/blog/tags/VM-Agent/"/>
    
  </entry>
  
  <entry>
    <title>Windows VM のビルトイン Administrator アカウントの名前変更について</title>
    <link href="https://jpaztech.github.io/blog/vm/vm-administrator-username-change/"/>
    <id>https://jpaztech.github.io/blog/vm/vm-administrator-username-change/</id>
    <published>2022-12-21T15:00:00.000Z</published>
    <updated>2023-08-18T00:59:11.746Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの洪です。<br>Azure VM (Windows OS) 作成時には、OS 内で “ビルトイン Administrator” として <strong>管理者アカウント</strong> のユーザー名をご指定いただくことになりますが、こちらのユーザー名の変更が可能であるかとのお問い合わせをいただくことがございます。<br>本記事ではそのユーザー名を OS 上から変更する方法および関連の留意事項 についてご案内いたします。</p><span id="more"></span><hr><h2 id="変更対象"><a href="#変更対象" class="headerlink" title="変更対象"></a>変更対象</h2><p>本記事にて案内しております手順は、以下のように作成されたユーザーを後から変更するものとなります。</p><p>■ 確認例 - Azure ポータル画面<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-01.png"><br>※ Azure VM の管理者アカウントのユーザー名として、azureadmin を指定します。</p><p>■ 確認例 - OS 上の画面<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-02.png"><br>※ Windows OS のビルトイン Administrator として azureadmin のユーザーが生成されます。<br>※ こちらのユーザー名の変更に関しまして、以下にご案内いたします。  </p><h2 id="管理者アカウント-ユーザー名を変更する"><a href="#管理者アカウント-ユーザー名を変更する" class="headerlink" title="管理者アカウント ユーザー名を変更する"></a>管理者アカウント ユーザー名を変更する</h2><p>管理者アカウントのユーザー名は従来の Windows の動作のように Windows の [コンピューターの管理] で変更可能でございます。<br>詳細手順に関しましては以下をご確認ください。</p><h2 id="■-手順"><a href="#■-手順" class="headerlink" title="■ 手順"></a>■ 手順</h2><h3 id="1-現在の管理者-ビルドイン-Administrator-のユーザー名を確認します。"><a href="#1-現在の管理者-ビルドイン-Administrator-のユーザー名を確認します。" class="headerlink" title="1. 現在の管理者 (ビルドイン Administrator) のユーザー名を確認します。"></a>1. 現在の管理者 (ビルドイン Administrator) のユーザー名を確認します。</h3><p>1-1. 画面左下側の Windows アイコンを右クリックし、[コンピューターの管理] を開きます。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-03.png"></p><p>1-2. [ローカル ユーザーとグループ] - [ユーザー] を選択し、”Built-in account for administering the computer” にて 該当するユーザー名を確認します。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-04.png"><br>※ この例では、[azureadmin] になります。</p><h3 id="2-管理者のユーザー名を変更します。"><a href="#2-管理者のユーザー名を変更します。" class="headerlink" title="2. 管理者のユーザー名を変更します。"></a>2. 管理者のユーザー名を変更します。</h3><p>2-1. 当該名前を右クリックし、[名前の変更] をクリックします。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-05.png"></p><p>2-2. ご希望のユーザー名を入力し、変更が可能です。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-06.png"><br>※ この例では、[azureadminnew] に変更しました。</p><h2 id="ユーザー名変更の影響および対処について"><a href="#ユーザー名変更の影響および対処について" class="headerlink" title="ユーザー名変更の影響および対処について"></a>ユーザー名変更の影響および対処について</h2><p>Windows OS のユーザーにつきましては、[C:\ユーザー] 配下にユーザー名でフォルダーが作成されますが、上記の手順で管理者のユーザー名をご変更いただいた際に、フォルダーの名前が自動で変更される動作はございません。<br>フォルダ名とログオン ユーザー名が異なっていても通常は問題ないためご放念いただく形となりますが、もしアプリケーションが動作しないなどやむを得ない理由があれば以下の手順で変更することは可能です。<br>フォルダー名を新しいユーザー名に変更する場合には、手動にてレジストリをご変更いただく必要がございます。<br>具体的な手順を下記にご案内いたします。</p><blockquote><p>[!CAUTION]<br>レジストリを誤って変更すると、深刻な問題が発生することがございます。<br>レジストリを編集する際には十分に注意してください。<br>万一に備えて、編集の前にはレジストリのバックアップまたは仮想マシンのバックアップ (Azure Backup やディ&gt; スクのスナップショット) をご取得いただきますようお願いします。<br>レジストリのバックアップおよび復元方法の詳細を参照するには、以下のサポート技術情報をご確認ください。<br>ご参考) <a href="https://support.microsoft.com/ja-jp/help/322756/">Windows でレジストリをバックアップおよび復元する方法</a></p></blockquote><h2 id="■-手順-1"><a href="#■-手順-1" class="headerlink" title="■ 手順"></a>■ 手順</h2><p>※ 仮想マシン作成時に指定した管理者のユーザー名 azureadmin を azureadminnew に変更する場合を例にご説明いたします。</p><h3 id="1-新しいローカル管理者アカウント-例-tempaccount-を作成します。"><a href="#1-新しいローカル管理者アカウント-例-tempaccount-を作成します。" class="headerlink" title="1. 新しいローカル管理者アカウント (例 tempaccount) を作成します。"></a>1. 新しいローカル管理者アカウント (例 tempaccount) を作成します。</h3><p>1-1. Windows で、[コントロール パネル] を検索し、開きます。</p><p>1-2. [ユーザー アカウント] &gt; [ユーザー アカウント] &gt; [別のアカウントの管理] を選択し、[ユーザー アカウントの追加] から新しいアカウントを作成します。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-07.png"><br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-08.png"><br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-09.png"></p><p>1-3. 新しいローカル アカウントをクリックし、[アカウントの種類の変更] をクリックします。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-10.png"></p><p>1-4. [管理者] を選択し、[アカウントの種類の変更]をクリックします。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-11.png"></p><p>1-5. 新しいローカルアカウントが、[ローカル アカウント Administrator] に表示されることを確認します。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-12.png"></p><p>1-6. VMを再起動します。</p><h3 id="2-Windows-ユーザー-フォルダーの名前を変更します。"><a href="#2-Windows-ユーザー-フォルダーの名前を変更します。" class="headerlink" title="2. Windows ユーザー フォルダーの名前を変更します。"></a>2. Windows ユーザー フォルダーの名前を変更します。</h3><p>2-1. 対象仮想マシンに、新しいローカル アカウント (例 tempaccount) にてログインします。(コマンド プロンプトの whoami から確認可能です。)<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-13.png"></p><p>2-2. エクスプローラーを開き、C:\ユーザー から仮想マシン作成時に指定した管理者のユーザー フォルダーを右クリックし、[名前の変更] をクリックします。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-14.png"></p><p>2-3. フォルダー名を変更したユーザー名(例. C:\Users\azureadminnew) に変更します。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-15.png"></p><h3 id="3-ユーザーの-SID-を確認します。"><a href="#3-ユーザーの-SID-を確認します。" class="headerlink" title="3. ユーザーの SID を確認します。"></a>3. ユーザーの SID を確認します。</h3><p>3-1. コマンド プロンプトを開き、以下のコマンドを実行します。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WMIC useraccount get name,sid</span><br></pre></td></tr></table></figure><p>3-2. 出力結果から、仮想マシン作成時に指定したユーザー名の SID を確認します。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-16.png"></p><h3 id="4-レジストリ-エディターを使用して名前を変更したフォルダーをマップします。"><a href="#4-レジストリ-エディターを使用して名前を変更したフォルダーをマップします。" class="headerlink" title="4. レジストリ エディターを使用して名前を変更したフォルダーをマップします。"></a>4. レジストリ エディターを使用して名前を変更したフォルダーをマップします。</h3><p>4-1. キーボードの Windows キーと R キーを同時に押し、[ファイル名を指定して実行] を開きます。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-17.png"></p><p>4-2. 「regedit」 を入力し、[OK] を押下します。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-18.png"></p><p>4-3. [レジストリ エディター] にて、下記のパスに移動します。</p><blockquote><p>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList</p></blockquote><p><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-19.png"></p><p>4-4. [ProfileList] 配下から、手順 3 で確認した SID を選択します。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-20.png"></p><p>4-5. [ProfileImagePath] をダブル クリックします。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-21.png"></p><p>4-6. [値のデータ] へ [C:\Users&lt;変更したユーザー名&gt;] (例 C:\Users\azureadminnew) を入力し、[OK] をクリックします。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-22.png"><br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-23.png"></p><p>4-7. 当該仮想マシンを再起動します。</p><h3 id="5-新しいローカル管理者アカウントを無効にします。"><a href="#5-新しいローカル管理者アカウントを無効にします。" class="headerlink" title="5. 新しいローカル管理者アカウントを無効にします。"></a>5. 新しいローカル管理者アカウントを無効にします。</h3><p>5-1. 対象仮想マシンに、変更後の管理者アカウント(例 azureadminnew) にてログインします。</p><p>5-2. 管理者権限にてコマンドプロンプトを開きます。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-24.png"></p><p>5-3. 以下のコマンドを入力すると、新しいローカル管理者アカウント (例 tempaccount) が無効になります。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> user &lt;新しいローカル管理者アカウント名&gt; /active:no</span><br></pre></td></tr></table></figure><p>※ 本手順では無効の方法を案内しておりますが、今後ご利用されない場合は削除していただいても問題ございません。</p><h2 id="管理者アカウント名の注意事項"><a href="#管理者アカウント名の注意事項" class="headerlink" title="管理者アカウント名の注意事項"></a>管理者アカウント名の注意事項</h2><p>ユーザー名をご指定いただく際の注意事項に関しましては、以下のドキュメントにてご案内しております。<br>詳細内容をご確認いただいた上で、変更する名前をご決定いただけますようお願い申し上げます。</p><blockquote><p>ご参考) <a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/faq#vm----------------------">VM を作成する際のユーザー名の要件は何ですか。</a><br>ユーザー名は最大 20 文字の長さまで指定できますが、末尾を句点 (“.”) にすることはできません。<br>次のユーザー名を指定することはできません。</p></blockquote><p>一方で、VM 作成後にゲスト OS 上の操作でユーザー名を変更した場合には、Azure としての制約が適用されないため、上記の要件以外のユーザー名を指定しても OS の動作は可能です。</p><p>ただし、Azure VM 作成時に登録する管理者アカウントは、Azure Portal からそのパスワードをリセットする機能がございますが、ドキュメントに記載のユーザー名の要件に従っていない場合にはその操作が不可になりますため、その点ご留意いただけますようお願いいたします。</p><h2 id="管理者アカウントの追加"><a href="#管理者アカウントの追加" class="headerlink" title="管理者アカウントの追加"></a>管理者アカウントの追加</h2><p>なお、 VM 構築後にゲスト OS 上の操作にて Administrator ユーザーを追加で作成いただくことも Azure としての制約はなく、ご利用いただける方法となります。</p><p>ただし、ゲスト OS 上で “Administrator” ユーザーを作成いただいた場合に関しましても、Azure Portal にて当該ユーザーのパスワードリセットの操作は叶いませんので、その点についてご留意いただけますようお願いいたします。</p><p>本稿が皆様のお役に立てれば幸いです。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの洪です。&lt;br&gt;Azure VM (Windows OS) 作成時には、OS 内で “ビルトイン Administrator” として &lt;strong&gt;管理者アカウント&lt;/strong&gt; のユーザー名をご指定いただくことになりますが、こちらのユーザー名の変更が可能であるかとのお問い合わせをいただくことがございます。&lt;br&gt;本記事ではそのユーザー名を OS 上から変更する方法および関連の留意事項 についてご案内いたします。&lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
  </entry>
  
</feed>

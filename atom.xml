<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Japan Azure IaaS Core Support Blog</title>
  
  <subtitle>日本マイクロソフトの Azure IaaS テクニカル サポート チームより、情報をお届けします！</subtitle>
  <link href="https://jpaztech.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://jpaztech.github.io/blog/"/>
  <updated>2023-05-26T05:14:04.563Z</updated>
  <id>https://jpaztech.github.io/blog/</id>
  
  <author>
    <name>Japan Azure IaaS Core Support Team</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>強制トンネリング利用時の VPN ゲートウェイの動作変更についてのアナウンス</title>
    <link href="https://jpaztech.github.io/blog/network/vpn-defaultsite-update-2022feb/"/>
    <id>https://jpaztech.github.io/blog/network/vpn-defaultsite-update-2022feb/</id>
    <published>2023-05-26T04:00:00.000Z</published>
    <updated>2023-05-26T05:14:04.563Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームです。</p><p>Azure の仮想ネットワーク ゲートウェイ (以下「ゲートウェイ」) を用いたサイト間 VPN 接続について、2022 年 2 月 24 日以降に、強制トンネリングに関する一部の動作の変更が行われることがアナウンスされました。</p><p>影響が生じる可能性のあるお客様には通知がすでに送信されているか、近日中に送信されることが想定されます。しかしながら、通知に含まれる説明は要点のみとなっているため、本記事にてその補足をさせていただきます。</p><p><strong>※追記</strong><br>2023 年 5 月 再度、強制トンネリング利用時の仮想ネットワーク ゲートウェイの動作変更のアナウンス (Tracking ID:VK3J-580)が通知されました。<br>これは、2022 年に通知されたアナウンス (Tracking ID:ZTPX-19Z)と同様の内容となりますが、動作変更の延期により今回あらためて仮想ネットワーク ゲートウェイ は、2023/6/12 ~ 6/16 の間に動作変更が実施されるという旨のアナウンスとなります。<br>2022 年に通知を受け取ったお客様の中で、下記の対応を行っていない環境については、動作変更の影響を受ける条件や合致確認の方法、動作変更の内容および変更の影響を受けないようにする対処方法をご確認の上、2023/6/12 より前にご対応いただけますと幸いでございます。</p><span id="more"></span><p><br><br></p><h2 id="本記事の内容"><a href="#本記事の内容" class="headerlink" title="本記事の内容"></a>本記事の内容</h2><p>本記事では、動作変更の影響を受ける条件やその合致確認の方法、動作変更の内容および変更の影響を受けないようにする対処方法ついてまとめております。本記事を参考に影響有無を確認するとともに、影響が想定される場合は 2 月 24 日までにあらかじめ対処を実施いただければと思います。</p><p>前半ではリソース マネージャー モデル（新しいモデル）のための手順、後半ではクラシック モデル（古いモデル）のための手順をおまとめしておりますので、それぞれご利用の環境に合わせて確認ください。</p><p><br><br></p><h2 id="今回の動作変更の背景"><a href="#今回の動作変更の背景" class="headerlink" title="今回の動作変更の背景"></a>今回の動作変更の背景</h2><p>Azure のゲートウェイには、「SKU」と呼ばれるパラメーターがあり、ゲートウェイの性能や冗長構成を指定することができます。ゲートウェイの SKU には、大きくわけて以下の 2 種類があります。</p><ul><li>末尾に AZ がつく SKU: VpnGw1AZ、VpnGw2AZ、VpnGw3AZ、VpnGw4AZ、VpnGw5AZ<br></li><li>末尾に AZ がつかない SKU: VpnGw1、VpnGw2、VpnGw3、VpnGw4、VpnGw5、Basic、Standard、HighPerformance</li></ul><p>AZ がつく SKU とつかない SKU では、冗長性確保のためのデータセンター内部の配置が少し違うのみで、そのほかに機能面での基本的な違いはありません。</p><p>しかし今回、特定の条件下において、AZ がつく SKU と AZ がつかない SKU で強制トンネリングに関する一部の動作 (詳細は後述) に差異があることが判明しました。AZ がつかない SKU を対象に動作変更を行い、AZ がつく SKU の動作を正として動作を揃えるというのが、今回のアナウンスの内容です。</p><p><br><br></p><h2 id="動作変更の内容"><a href="#動作変更の内容" class="headerlink" title="動作変更の内容"></a>動作変更の内容</h2><h3 id="強制トンネリングを実現する-2-種類の方法"><a href="#強制トンネリングを実現する-2-種類の方法" class="headerlink" title="強制トンネリングを実現する 2 種類の方法"></a>強制トンネリングを実現する 2 種類の方法</h3><p>Azure のサイト間 VPN においては、Azure 仮想ネットワークから送信されるすべての通信を、データセンターのバックボーンネットワークではなく、VPN にルーティングする「強制トンネリング」という構成が可能です。サイト間 VPN で強制トンネリングを構成するためには、以下の 2 種類の方法があります。</p><ul><li>方法 1. 対向のルーターと BGP で経路交換を行い、対向のルーターからデフォルト ルート 0.0.0.0/0 (を広報する)</li><li>方法 2. BGP は利用せず、ゲートウェイに DefaultSite の設定を行う</li></ul><h3 id="動作が変更される対象となる方法"><a href="#動作が変更される対象となる方法" class="headerlink" title="動作が変更される対象となる方法"></a>動作が変更される対象となる方法</h3><p>このうち、方法 2 を利用している場合は、SKU によって強制トンネリングのために必要な作業が少し異なります。SKU に AZ がつく場合は、DefaultSite の設定を行うだけで、仮想ネットワーク内の全てのサブネットに対して、デフォルト ルートを VPN に向けるルートが反映されます。</p><p>しかし AZ がつかない場合は、DefaultSite の設定を行うだけでは強制トンネリングのためのルートが適用されません。DefaultSite の設定に加えて、0.0.0.0/0 のネクストホップをゲートウェイにしたユーザー定義ルート (UDR) を各サブネットに適用することで、はじめて強制トンネリングがそのサブネットで有効になります。</p><p>今回の動作変更では、この動作を AZ がつく SKU に合わせます。つまり、DefaultSite の設定がされている環境では、0.0.0.0/0 をゲートウェイに向ける UDR が適用されていなくても、強制トンネリングが有効になります。対象の環境においては、強制トンネリングが現状有効になっていないサブネットで、2 月 24 日以降に突然強制トンネリングが有効になる、ということが起こり得ます。</p><p>※ 方法 1 (BGP) を利用している場合は、今回の動作変更による影響はありません。</p><p><br><br></p><h2 id="動作変更による影響が生じる条件"><a href="#動作変更による影響が生じる条件" class="headerlink" title="動作変更による影響が生じる条件"></a>動作変更による影響が生じる条件</h2><p>以下の 5 つの条件に <strong>すべて</strong> 合致した場合に、今回の動作変更の影響を受けます。</p><ul><li>A. VPN 用の仮想ネットワーク ゲートウェイがある</li><li>B. ゲートウェイの SKU は末尾に AZ がつかないものである</li><li>C. サイト間 VPN を利用している</li><li>D. BGP でデフォルト ルートを 0.0.0.0/0 を受信していない</li><li>E. DefaultSiteの設定がされている</li></ul><p>それぞれの条件についての合致確認の方法は、本記事の末尾にまとめております。</p><p><br><br></p><h2 id="条件にすべて合致した場合の対応"><a href="#条件にすべて合致した場合の対応" class="headerlink" title="条件にすべて合致した場合の対応"></a>条件にすべて合致した場合の対応</h2><p>上記の 5 つの条件に <strong>すべて</strong> 合致した場合、動作変更の影響が生じる可能性があります。つまり、0.0.0.0/0 をゲートウェイに向けるユーザー定義ルートが適用されていなくても、2 月 24 日以降の動作変更によって、強制トンネリングがそのサブネットで有効になります。</p><p>予期せず強制トンネリングが有効になることを防ぐためには、あらかじめ 0.0.0.0/0 のネクストホップをインターネットに向ける UDR を適用することが有効です。2 月 24 日よりも前にこの UDR を適用しておくことで、その UDR が適用されたサブネットでは、動作変更によって強制トンネリングが突然有効になる状況を回避することができます。</p><p>（したがって、現状ですでに 0.0.0.0/0 のネクストホップをインターネットに設定する UDR が適用されているサブネットについては、影響を受けません）</p><h3 id="対応手順の例"><a href="#対応手順の例" class="headerlink" title="対応手順の例"></a>対応手順の例</h3><p>具体的な手順の一例は以下のとおりです。各パラメーターについてはお客様の環境に合わせて確認および決定してください。</p><ol><li><p><b>Azure ポータルを開きます。<br></b><br><a href="https://portal.azure.com/">https://portal.azure.com/</a></p></li><li><p><b>すでに対象のサブネットにルート テーブルが適用されている場合は、手順 5) までスキップします。</b></p></li><li><p><b>[ルート テーブル] を開き、[+作成] をクリックします。</b></p></li><li><p><b>以下のパラメーターを入力し、[確認および作成] をクリックします。(詳細なパラメーターは環境に合わせてください)</b><br><br>　リソース グループ: 任意<br><br>　リージョン: ルート テーブルの適用対象の仮想ネットワークと合わせる<br><br>　名前: ルート テーブルの任意の名前<br><br>　ゲートウェイのルートを伝達する: Yes</p></li><li><p><b>4) で作成したルート テーブルか、既存のルート テーブルを開きます。</b></p></li><li><p><b>[ルート] メニューをクリックし、[+追加] をクリックします。</b></p></li><li><p><b>以下のパラメーターでルートを追加して [OK] をクリックします。</b><br><br>　ルート名: 任意の名前<br><br>　アドレス プレフィックス: 0.0.0.0/0<br><br>　ネクスト ホップの種類: インターネット<br></p></li><li><p><b>すでに対象のサブネットにルート テーブルが適用されている状態で作業を行った場合は、これで終了です。</b></p></li><li><p><b>[サブネット] メニューをクリックし、[+関連付け] をクリックします。</b></p></li><li><p><b>ルート テーブルの適用対象の仮想ネットワークとサブネットを選択して、[OK] をクリックします。</b></p></li></ol><p>※ ルート テーブルの設定手順は <a href="https://docs.microsoft.com/ja-jp/azure/virtual-network/manage-route-table">公開資料</a> でも説明されておりますので、あわせてご覧ください。</p><p><br>　<br>　<br></p><h2 id="条件に合致しているかどうかを確認するための詳細手順"><a href="#条件に合致しているかどうかを確認するための詳細手順" class="headerlink" title="条件に合致しているかどうかを確認するための詳細手順"></a>条件に合致しているかどうかを確認するための詳細手順</h2><p>A～E それぞれの条件について、合致しているかどうかを確認するための手順の一例をご紹介いたします。</p><h3 id="A-VPN-用の仮想ネットワーク-ゲートウェイがあることの確認"><a href="#A-VPN-用の仮想ネットワーク-ゲートウェイがあることの確認" class="headerlink" title="A. VPN 用の仮想ネットワーク ゲートウェイがあることの確認"></a>A. VPN 用の仮想ネットワーク ゲートウェイがあることの確認</h3><p>Azure ポータルで [仮想ネットワーク ゲートウェイ] メニューを開き、[ゲートウェイの種類] が [Vpn] のものがあれば、この条件に合致しています。</p><p><img src="/blog/network/vpn-defaultsite-update-2022feb/vpn-defaultsite-update-2022feb-a01.png" alt="画面イメージ"></p><h3 id="B-ゲートウェイの-SKU-は末尾に-AZ-がつかないものであることの確認"><a href="#B-ゲートウェイの-SKU-は末尾に-AZ-がつかないものであることの確認" class="headerlink" title="B. ゲートウェイの SKU は末尾に AZ がつかないものであることの確認"></a>B. ゲートウェイの SKU は末尾に AZ がつかないものであることの確認</h3><p>A. でみつけたゲートウェイをクリックし、[SKU] 欄を確認して「AZ」が含まれていないものであれば、この条件に合致しています。（以下の画像は「AZ」が含まれる場合の例、つまり条件に合致しない例です）</p><p><img src="/blog/network/vpn-defaultsite-update-2022feb/vpn-defaultsite-update-2022feb-b01.png" alt="画面イメージ"></p><h3 id="C-サイト間-VPN-を利用していることの確認"><a href="#C-サイト間-VPN-を利用していることの確認" class="headerlink" title="C. サイト間 VPN を利用していることの確認"></a>C. サイト間 VPN を利用していることの確認</h3><p>A. でみつけたゲートウェイをクリックし、[接続] メニューをクリックします。</p><p><img src="/blog/network/vpn-defaultsite-update-2022feb/vpn-defaultsite-update-2022feb-c01.png" alt="画面イメージ"></p><p>[接続] オブジェクトが表示されれば、この条件に合致しています。</p><p><img src="/blog/network/vpn-defaultsite-update-2022feb/vpn-defaultsite-update-2022feb-c02.png" alt="画面イメージ"></p><h3 id="D-BGP-でデフォルト-ルートを-0-0-0-0-0-を受信していないことの確認"><a href="#D-BGP-でデフォルト-ルートを-0-0-0-0-0-を受信していないことの確認" class="headerlink" title="D. BGP でデフォルト ルートを 0.0.0.0/0 を受信していないことの確認"></a>D. BGP でデフォルト ルートを 0.0.0.0/0 を受信していないことの確認</h3><p>A. でみつけたゲートウェイをクリックし、[BGP ピア] メニューをクリックします。</p><p>[学習したルート] に 0.0.0.0/0 が含まれて <strong>いなければ</strong>、この条件に合致しています。（0.0.0.0/0 が含まれていたら、この条件に合致しませんので今回の変更の影響も受けません。少し紛らわしいのでご注意ください）</p><h3 id="E-DefaultSiteの設定がされていることの確認"><a href="#E-DefaultSiteの設定がされていることの確認" class="headerlink" title="E. DefaultSiteの設定がされていることの確認"></a>E. DefaultSiteの設定がされていることの確認</h3><p>この確認は PowerShell での作業が必要になります。</p><ol><li><p><b>Azure PowerShell を起動するか、<a href="https://shell.azure.com/">Cloud Shell</a> (PowerShell を選択) を開きます。</b></p></li><li><p><b>Azure PowerShell の場合、以下のコマンドを実行してサインインします。</b><br><br>Login-AzAccount</p></li><li><p><b>A. でみつけたゲートウェイが構築されているサブスクリプション ID を確認し、以下のコマンドを実行して操作対象のサブスクリプションを指定します。</b><br><br>Select-AzSubscription -SubscriptionId &lt;確認したサブスクリプション ID&gt;</p></li><li><p><b>以下のコマンドを実行し、対象のゲートウェイの構成情報を取得・表示します。</b><br><br>Get-AzVirtualNetworkGateway -Name &lt;ゲートウェイの名前&gt; -ResourceGroupName &lt;ゲートウェイのリソース グループ名&gt;</p></li><li><p><b>出力結果の中から、GatewayDefaultSite という行を探します。サイト名の情報が入っている場合は、この条件に合致します。「null」となっている場合は合致しません。</b></p></li></ol><br><hr><p><br>　<br>　<br>　<br><br><b>※ 以下は、クラシック デプロイ モデルをご利用の方に向けた手順です。</b><br><br></p><hr><h2 id="クラシックの場合-条件にすべて合致した場合の対応"><a href="#クラシックの場合-条件にすべて合致した場合の対応" class="headerlink" title="(クラシックの場合) 条件にすべて合致した場合の対応"></a>(クラシックの場合) 条件にすべて合致した場合の対応</h2><p>クラシック デプロイ モデルをご利用の場合における具体的な手順の一例は以下のとおりです。各パラメーターについてはお客様の環境に合わせて確認および決定してください。</p><h3 id="事前準備-Azure-PowerShell-の利用"><a href="#事前準備-Azure-PowerShell-の利用" class="headerlink" title="事前準備: Azure PowerShell の利用"></a>事前準備: Azure PowerShell の利用</h3><p>クラシック デプロイ モデルにおける対処のためには、Azure PowerShell をご利用いただくことができます。対処用のコマンドを実行するためには、事前に以下のコマンドを実行する必要があります。</p><ol><li><p><b>以下のコマンドを実行し、サインインします。</b><br><br>Add-AzureAccount</p></li><li><p><b>以下のコマンドを実行し、対象のサブスクリプションを指定します。</b><br><br>Select-AzureSubscription -SubscriptionId &lt;サブスクリプション ID&gt;</p></li></ol><h3 id="対応手順の例-1"><a href="#対応手順の例-1" class="headerlink" title="対応手順の例"></a>対応手順の例</h3><p>具体的な手順の一例は以下のとおりです。各パラメーターについてはお客様の環境に合わせて確認および決定してください。</p><ol><li><p><b>対象のサブネットにすでにルート テーブルが適用されているかどうかを確認します。</b><br><br>Get-AzureSubnetRouteTable -VirtualNetworkName “仮想ネットワーク名” -SubnetName “サブネット名”</p></li><li><p><b>すでに対象のサブネットにルート テーブルが適用されている場合は、手順 4) までスキップします。</b></p></li><li><p><b>任意の名前でルート テーブルを作成します。</b><br><br>New-AzureRouteTable -Name “ルート テーブルの名前” -Location “リージョン名”</p></li><li><p><b>ルート テーブルに、0.0.0.0/0 のネクストホップを Internet に指定したルートを追加します。</b><br><br>Get-AzureRouteTable -Name “ルート テーブルの名前” | Set-AzureRoute -RouteName “DefaultRoute” -AddressPrefix “0.0.0.0/0” -NextHopType Internet</p></li><li><p><b>すでに対象のサブネットにルート テーブルが適用されている状態で作業を行った場合は、これで終了です。</b></p></li><li><p><b>ルート テーブルをサブネットに適用します。</b><br><br>Set-AzureSubnetRouteTable -VirtualNetworkName “仮想ネットワーク名” -SubnetName “サブネット名” -RouteTableName “ルート テーブルの名前”</p></li></ol><br><hr><br><h2 id="クラシックの場合-条件に合致しているかどうかを確認するための詳細手順"><a href="#クラシックの場合-条件に合致しているかどうかを確認するための詳細手順" class="headerlink" title="(クラシックの場合) 条件に合致しているかどうかを確認するための詳細手順"></a>(クラシックの場合) 条件に合致しているかどうかを確認するための詳細手順</h2><p>クラシック デプロイ モデルをご利用の場合において、A～E それぞれの条件について、合致しているかどうかを確認するための手順の一例をご紹介いたします。</p><h3 id="事前準備-Azure-PowerShell-の利用-1"><a href="#事前準備-Azure-PowerShell-の利用-1" class="headerlink" title="事前準備: Azure PowerShell の利用"></a>事前準備: Azure PowerShell の利用</h3><p>クラシック デプロイ モデルにおける合致確認には、Azure PowerShell をご利用いただくことができます。合致確認用のコマンドを実行するためには、事前に以下のコマンドを実行する必要があります。</p><ol><li><p><b>以下のコマンドを実行し、サインインします。</b><br><br>Add-AzureAccount</p></li><li><p><b>以下のコマンドを実行し、対象のサブスクリプションを指定します。</b><br><br>Select-AzureSubscription -SubscriptionId &lt;確認したサブスクリプション ID&gt;</p></li></ol><h3 id="A-VPN-用の仮想ネットワーク-ゲートウェイがあることの確認-1"><a href="#A-VPN-用の仮想ネットワーク-ゲートウェイがあることの確認-1" class="headerlink" title="A. VPN 用の仮想ネットワーク ゲートウェイがあることの確認"></a>A. VPN 用の仮想ネットワーク ゲートウェイがあることの確認</h3><p>(確認不要) 下記 E. の手順に包含されるため、本手順は割愛します。</p><h3 id="B-ゲートウェイの-SKU-は末尾に-AZ-がつかないものであることの確認-1"><a href="#B-ゲートウェイの-SKU-は末尾に-AZ-がつかないものであることの確認-1" class="headerlink" title="B. ゲートウェイの SKU は末尾に AZ がつかないものであることの確認"></a>B. ゲートウェイの SKU は末尾に AZ がつかないものであることの確認</h3><p>(確認不要) クラシックでは、必ず AZ がつかない SKU となりますので、本手順は割愛します。</p><h3 id="C-サイト間-VPN-を利用していることの確認-1"><a href="#C-サイト間-VPN-を利用していることの確認-1" class="headerlink" title="C. サイト間 VPN を利用していることの確認"></a>C. サイト間 VPN を利用していることの確認</h3><p>(確認不要) 下記 E. の手順に包含されるため、本手順は割愛します。</p><h3 id="D-BGP-でデフォルト-ルートを-0-0-0-0-0-を受信していないことの確認-1"><a href="#D-BGP-でデフォルト-ルートを-0-0-0-0-0-を受信していないことの確認-1" class="headerlink" title="D. BGP でデフォルト ルートを 0.0.0.0/0 を受信していないことの確認"></a>D. BGP でデフォルト ルートを 0.0.0.0/0 を受信していないことの確認</h3><p>(確認不要) クラシックでは BGP は利用できないため、本手順は割愛します。</p><h3 id="E-DefaultSiteの設定がされていることの確認-1"><a href="#E-DefaultSiteの設定がされていることの確認-1" class="headerlink" title="E. DefaultSiteの設定がされていることの確認"></a>E. DefaultSiteの設定がされていることの確認</h3><ol><li><p><b>Azure PowerShell で以下のコマンドを実行します。</b><br><br>Get-AzureVirtualNetworkGateway</p></li><li><p><b>表示されたゲートウェイの一覧から、以下のように DefaultSite に値が入っているものがあれば、合致しています。</b><br></p><blockquote><p>GatewayId            : xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx<br><br>GatewayName          : Default<br><br>LastEventData        :<br><br>GatewayType          : DynamicRouting<br><br>LastEventTimeStamp   : xx/xx/xxxx xx:xx:xx<br><br>LastEventMessage     : Successfully updated the gateway for the following virtual network: xxxx <b>← 通常、ここに対象の仮想ネットワーク名が入ります。</b><br><br>LastEventID          : xxxxx<br><br>State                : Provisioned<br><br>VIPAddress           : x.x.x.x<br><br>DefaultSite          : Site01 <b>← ここにサイト名が入っていれば該当しています。該当しない場合空欄です。</b><br><br>GatewaySKU           : Standard<br><br>Location             : Japan East<br><br>VnetId               : xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx<br><br>SubnetId             :<br><br>EnableBgp            : False<br><br>Asn                  : xxxxx<br><br>BgpPeeringAddress    : x.x.x.x<br><br>PeerWeight           : 0<br><br>OperationDescription :<br><br>OperationId          :<br><br>OperationStatus      :<br></p></blockquote></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームです。&lt;/p&gt;
&lt;p&gt;Azure の仮想ネットワーク ゲートウェイ (以下「ゲートウェイ」) を用いたサイト間 VPN 接続について、2022 年 2 月 24 日以降に、強制トンネリングに関する一部の動作の変更が行われることがアナウンスされました。&lt;/p&gt;
&lt;p&gt;影響が生じる可能性のあるお客様には通知がすでに送信されているか、近日中に送信されることが想定されます。しかしながら、通知に含まれる説明は要点のみとなっているため、本記事にてその補足をさせていただきます。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;※追記&lt;/strong&gt;&lt;br&gt;2023 年 5 月 再度、強制トンネリング利用時の仮想ネットワーク ゲートウェイの動作変更のアナウンス (Tracking ID:VK3J-580)が通知されました。&lt;br&gt;これは、2022 年に通知されたアナウンス (Tracking ID:ZTPX-19Z)と同様の内容となりますが、動作変更の延期により今回あらためて仮想ネットワーク ゲートウェイ は、2023/6/12 ~ 6/16 の間に動作変更が実施されるという旨のアナウンスとなります。&lt;br&gt;2022 年に通知を受け取ったお客様の中で、下記の対応を行っていない環境については、動作変更の影響を受ける条件や合致確認の方法、動作変更の内容および変更の影響を受けないようにする対処方法をご確認の上、2023/6/12 より前にご対応いただけますと幸いでございます。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Network" scheme="https://jpaztech.github.io/blog/tags/Network/"/>
    
    <category term="VPN Gateway" scheme="https://jpaztech.github.io/blog/tags/VPN-Gateway/"/>
    
  </entry>
  
  <entry>
    <title>Azure VM のディスクパフォーマンス状況の確認方法について</title>
    <link href="https://jpaztech.github.io/blog/vm/disk-metrics/"/>
    <id>https://jpaztech.github.io/blog/vm/disk-metrics/</id>
    <published>2023-05-10T08:30:00.000Z</published>
    <updated>2023-05-26T05:14:04.663Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの富田です。<br>期待したディスクパフォーマンスが得られないといったお問い合わせをいただくことがあります。<br>そのため、今回この記事以下の内容について解説をさせていただきます。  </p><ol><li>Azure 側にて VM サイズとディスクサイズ毎に設定されている上限について解説</li><li>ディスクに関するメトリックでパフォーマンスを確認する方法</li><li>VM サイズとディスクサイズを変更する方法</li></ol><div class="alert is-info"><p class="alert-title">Note</p><p>本記事では各種の上限について数値を交えて解説しておりますが、こちらは理論値となっており実際の計測では OS レイヤ以上の影響等もございますので、必ずしも記載の理論値が計測可能であることを保証するものではございません点について予めご了承くださいませ。</p></div><hr><h2 id="1-1-VM-サイズとディスクサイズ毎に設定されている上限について解説"><a href="#1-1-VM-サイズとディスクサイズ毎に設定されている上限について解説" class="headerlink" title="1-1.VM サイズとディスクサイズ毎に設定されている上限について解説"></a>1-1.VM サイズとディスクサイズ毎に設定されている上限について解説</h2><p>まずは、Azure VM におけるディスクのパフォーマンスの上限値について解説させていただきます。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p>ディスク性能の上限はオンプレミス上の物理ディスクでも勿論あるものであり、OS から高負荷な I/O 要求が発生し、ディスク性能の上限に達した場合、 I/O に遅延等が発生することはご理解いただけるかと存じます。</p><p>Azure のディスク性能も同じような考え方となります。上限に達した場合は、オンプレミス環境と同様に I/O の遅延等が発生しますが、これは Azure 特有のものでは無く、オンプレミス環境と同じように発生するものであると考えていただけますと幸いです。</p></div><p>オンプレミス環境のサーバーや私たちが普段使用しているパソコンと同様に、Azure VM でもディスクアクセスが行われます。<br>Azure ではこの VM とディスク間のディスクアクセスについて、「VMサイズ」と「ディスクサイズ」のそれぞれ両方で「MBps」と「IOPS」の上限値を設定しています。  </p><p>なお、この上限は Read / Write の合計で適用されます。<br>つまり Read が 100 MBps、Write が 50 MBps 同時に発生していたら、150 MBps のディスクアクセスとして合算されます。  </p><p>重要な点として、ディスクアクセスの上限は「VMサイズ」と「ディスクサイズ」に設定されている低い方の上限値が適用されます。<br>ホストキャッシュやバーストは無効と考えて、VM とデータディスク間の通信について以下に例を記載します。  </p><p><img src="/blog/vm/disk-metrics/bisk-base.png"></p><p>上記の例では Standard_D2s_v5 の VM サイズに P20 のデータディスクのサイズを組み合わせています。</p><ul><li>Standard_D2s_v5 の VM サイズでの上限：85 MBps / 3750 IOSP</li><li>P20 のディスクサイズでの上限：150 MBps / 2300 IOPS</li></ul><p>という設定がございます。<br>先に解説した通り低い値の方（赤字）が適用されますので、実際に想定される速度の上限値としては「85 MBps / 2300 IOPS」となります。</p><p>なお、この「Standard_D2s_v5 の VM サイズでの上限：85 MBps / 3750 IOSP」という VM の上限値については、ディスク 1 つごとでは無く、ホストキャッシュ無効な全てのデータディスク全体で共有されます。<br>すなわち、複数のホストキャッシュ無効なデータディスク合算で 85 MBps / 3750 IOSP が上限となります。 </p><p>ホストキャッシュの有効なディスク・無効なディスクで上限値が別に設定されている VM サイズもございます。<br>各 VM サイズおよびディスクサイズにおけるディスクアクセスの上限値は、公式ドキュメントをご確認くださいませ。  </p><blockquote><p>■ご参考：Azure の仮想マシンのサイズ<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/sizes">https://learn.microsoft.com/ja-jp/azure/virtual-machines/sizes</a></p></blockquote><blockquote><p>■ご参考：Azure マネージド ディスクの種類<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/disks-types">https://learn.microsoft.com/ja-jp/azure/virtual-machines/disks-types</a></p></blockquote><hr><h2 id="1-2-一時的に通信の上限を上げる「ディスクバースト」という機能がございます"><a href="#1-2-一時的に通信の上限を上げる「ディスクバースト」という機能がございます" class="headerlink" title="1-2.一時的に通信の上限を上げる「ディスクバースト」という機能がございます"></a>1-2.一時的に通信の上限を上げる「ディスクバースト」という機能がございます</h2><p>先に記載した通り、「VMサイズ」と「ディスクサイズ」それぞれにディスクアクセスの上限が設定されています。<br>しかしながら、特定の「VMサイズ」と「ディスクサイズ」には、このディスクアクセスの上限を一時的に上げられる「ディスクバースト」という機能がございます。</p><ul><li>VM サイズに設定されているディスクアクセスの上限値が一時的に上がること = VM レベルのバースト</li><li>ディスクサイズに設定されているディスクアクセスの上限値が一時的に上がること = ディスクレベルのバースト</li></ul><p>ディスクバーストの詳細については公式ドキュメントをご参照くださいませ。</p><blockquote><p>■ご参考：マネージド ディスクのバースト<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/disk-bursting">https://learn.microsoft.com/ja-jp/azure/virtual-machines/disk-bursting</a></p></blockquote><p>なお、クレジットベースのバーストの場合、VM レベルのバーストとディスクレベルのバーストは独立しており、<br>以下のように 6 種類のクレジットが独立している点、ご留意くださいませ。</p><ul><li>VM レベルに関する MBps のバーストクレジット（キャッシュ無し）</li><li>VM レベルに関する IOPS のバーストクレジット（キャッシュ無し）</li><li>VM レベルに関する MBps のバーストクレジット（キャッシュあり）</li><li>VM レベルに関する IOPS のバーストクレジット（キャッシュあり）</li><li>ディスクレベルに関する MBps のバーストクレジット</li><li>ディスクレベルに関する IOPS のバーストクレジット</li></ul><p>では、ホストキャッシュは無しとして、バーストが発生した際の例を見てみましょう。</p><p><img src="/blog/vm/disk-metrics/disk-burst.png"></p><p>上記は、Standard_D2s_v5 の VM サイズに P20 のデータディスクのサイズを組み合わせて、VM レベルのバースト・ディスクレベルのバースト両方が働いた場合の例です。<br>一時的に「170 MBps / 3500 IPOS」までバースト可能なことが分かりましたね。</p><hr><h2 id="2-1-ディスクに関するメトリックでパフォーマンスを確認する方法"><a href="#2-1-ディスクに関するメトリックでパフォーマンスを確認する方法" class="headerlink" title="2-1.ディスクに関するメトリックでパフォーマンスを確認する方法"></a>2-1.ディスクに関するメトリックでパフォーマンスを確認する方法</h2><p>Azure では、ディスクアクセスに関してどの程度のパフォーマンスが出ているかといったことを記録しており、メトリックとして確認を行うことが可能です。<br>パフォーマンスが上限で頭打ちしている場合は、スペックアップが必要である可能性があるといったことを確認することができます。</p><p>パフォーマンスが上限で頭打ちしていないにも関わらず、期待したパフォーマンスを得られていない場合は、<br>OS やアプリケーションが適切なディスクアクセスを発生させていない可能性がございます。<br>ディスクパフォーマンスの詳細については以下の記事もご参照くださいませ。  </p><blockquote><p>■ご参考：Azure Premium Storage: 高パフォーマンス用に設計する<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/premium-storage-performance">https://learn.microsoft.com/ja-jp/azure/virtual-machines/premium-storage-performance</a></p></blockquote><p>Azure ではこの調査に役立つ多くのディスクに関するメトリックがございますので、一覧形式でご紹介させていただきます。</p><div class="alert is-info"><p class="alert-title">Note</p><p>これらの記録された値については Azure 基盤上で観測された値となりますため、OS 上で観測した値と差異がある可能性がございます点、予めご了承ください。</p><p>また、メトリック表示の最小の粒度は 1 分でございますため、瞬間的な状況等は確認が叶いません点、ご留意ください。</p></div><h3 id="OS-ディスクの-Read-Write-に関して何-MBps-IOPS-が記録されたか確認する"><a href="#OS-ディスクの-Read-Write-に関して何-MBps-IOPS-が記録されたか確認する" class="headerlink" title="OS ディスクの Read / Write に関して何 MBps / IOPS が記録されたか確認する"></a>OS ディスクの Read / Write に関して何 MBps / IOPS が記録されたか確認する</h3><table><thead><tr><th align="left">確認できる内容</th><th align="left">メトリック名</th></tr></thead><tbody><tr><td align="left">OS ディスクの Read が何 MBps 記録されたか確認</td><td align="left">OS Disk Read Bytes/Sec</td></tr><tr><td align="left">OS ディスクの Write が何 MBps 記録されたか確認</td><td align="left">OS Disk Write Bytes/Sec</td></tr><tr><td align="left">OS ディスクの Read が何 IOPS 記録されたか確認</td><td align="left">OS Disk Read Operations/Sec</td></tr><tr><td align="left">OS ディスクの Write が何 IOPS 記録されたか確認</td><td align="left">OS Disk Write Operations/Sec</td></tr></tbody></table><h3 id="データディスクの-Read-Write-に関して何-MBps-IOPS-が記録されたか確認する"><a href="#データディスクの-Read-Write-に関して何-MBps-IOPS-が記録されたか確認する" class="headerlink" title="データディスクの Read / Write に関して何 MBps / IOPS が記録されたか確認する"></a>データディスクの Read / Write に関して何 MBps / IOPS が記録されたか確認する</h3><table><thead><tr><th align="left">確認できる内容</th><th align="left">メトリック名</th></tr></thead><tbody><tr><td align="left">データディスクの Read が何 MBps 記録されたか確認</td><td align="left">Data Disk Read Bytes/Sec</td></tr><tr><td align="left">データディスクの Write が何 MBps 記録されたか確認</td><td align="left">Data Disk Write Bytes/Sec</td></tr><tr><td align="left">データディスクの Read が何 IOPS 記録されたか確認</td><td align="left">Data Disk Read Operations/Sec</td></tr><tr><td align="left">データディスクの Write が何 IOPS 記録されたか確認</td><td align="left">Data Disk Write Operations/Sec</td></tr><tr><td align="left"></td><td align="left"></td></tr></tbody></table><h3 id="VM-レベルのディスクバーストのクレジットの残りがどれくらいか確認する"><a href="#VM-レベルのディスクバーストのクレジットの残りがどれくらいか確認する" class="headerlink" title="VM レベルのディスクバーストのクレジットの残りがどれくらいか確認する"></a>VM レベルのディスクバーストのクレジットの残りがどれくらいか確認する</h3><table><thead><tr><th align="left">確認できる内容</th><th align="left">メトリック名</th></tr></thead><tbody><tr><td align="left">VM レベルの MBps の残バーストクレジット量（キャッシュ有効であるディスク）</td><td align="left">VM Cached Used Burst BPS Credits Percentage</td></tr><tr><td align="left">VM レベルの IOPS の残バーストクレジット量（キャッシュ有効であるディスク）</td><td align="left">VM Cached Used Burst IO Credits Percentage</td></tr><tr><td align="left">VM レベルの MBps の残バーストクレジット量（キャッシュ<strong>無効</strong>なディスク）</td><td align="left">VM Uncached Used Burst BPS Credits Percentage</td></tr><tr><td align="left">VM レベルの IOPS の残バーストクレジット量（キャッシュ<strong>無効</strong>なディスク）</td><td align="left">VM Uncached Used Burst IO Credits Percentage</td></tr><tr><td align="left"></td><td align="left"></td></tr></tbody></table><h3 id="ディスクレベルのディスクバーストのクレジットの残りがどれくらいか確認する"><a href="#ディスクレベルのディスクバーストのクレジットの残りがどれくらいか確認する" class="headerlink" title="ディスクレベルのディスクバーストのクレジットの残りがどれくらいか確認する"></a>ディスクレベルのディスクバーストのクレジットの残りがどれくらいか確認する</h3><table><thead><tr><th align="left">確認できる内容</th><th align="left">メトリック名</th></tr></thead><tbody><tr><td align="left">ディスクレベルの MBps の残バーストクレジット量（OS ディスク）</td><td align="left">OS Disk Used Burst BPS Credits Percentage</td></tr><tr><td align="left">ディスクレベルの IOPS の残バーストクレジット量（OS ディスク）</td><td align="left">OS Disk Used Burst IO Credits Percentage</td></tr><tr><td align="left">ディスクレベルの MBps の残バーストクレジット量（データディスク）</td><td align="left">Data Disk Used Burst BPS Credits Percentage</td></tr><tr><td align="left">ディスクレベルの IOPS の残バーストクレジット量（データディスク）</td><td align="left">Data Disk Used Burst IO Credits Percentage</td></tr></tbody></table><h3 id="ディスクレベルのベースパフォーマンスに対して何-のパフォーマンスが記録されたか確認する"><a href="#ディスクレベルのベースパフォーマンスに対して何-のパフォーマンスが記録されたか確認する" class="headerlink" title="ディスクレベルのベースパフォーマンスに対して何 % のパフォーマンスが記録されたか確認する"></a>ディスクレベルのベースパフォーマンスに対して何 % のパフォーマンスが記録されたか確認する</h3><table><thead><tr><th align="left">確認できる内容</th><th align="left">メトリック名</th></tr></thead><tbody><tr><td align="left">ディスクレベルのベースパフォーマンスに対して計測された MBps のパーセント表示（OS ディスク）</td><td align="left">OS Disk Bandwidth Consumed Percentage</td></tr><tr><td align="left">ディスクレベルのベースパフォーマンスに対して計測された IOPS のパーセント表示（OS ディスク）</td><td align="left">OS Disk IOPS Consumed Percentage</td></tr><tr><td align="left">ディスクレベルのベースパフォーマンスに対して計測された MBps のパーセント表示（データディスク）</td><td align="left">Data Disk Bandwidth Consumed Percentage</td></tr><tr><td align="left">ディスクレベルのベースパフォーマンスに対して計測された IOPS のパーセント表示（データディスク）</td><td align="left">Data Disk IOPS Consumed Percentage</td></tr></tbody></table><div class="alert is-info"><p class="alert-title">Note</p><p>※Premium ストレージをサポートする VM シリーズ上でのみ使用できます。</p><p>※バースト時の上限ではなくベースパフォーマンスを 100 % として記録されます。バーストしている場合も 100 % で記録されます。</p></div><h3 id="VM-レベルのベースパフォーマンスに対して何-のパフォーマンスが記録されたか確認する"><a href="#VM-レベルのベースパフォーマンスに対して何-のパフォーマンスが記録されたか確認する" class="headerlink" title="VM レベルのベースパフォーマンスに対して何 % のパフォーマンスが記録されたか確認する"></a>VM レベルのベースパフォーマンスに対して何 % のパフォーマンスが記録されたか確認する</h3><table><thead><tr><th align="left">確認できる内容</th><th align="left">メトリック名</th></tr></thead><tbody><tr><td align="left">VMレベルのベースパフォーマンスに対して計測された MBps のパーセント表示（キャッシュ有効であるディスク）</td><td align="left">VM Cached Bandwidth Consumed Percentage</td></tr><tr><td align="left">VMレベルのベースパフォーマンスに対して計測された IOPS のパーセント表示（キャッシュ有効であるディスク）</td><td align="left">VM Cached IOPS Consumed Percentage</td></tr><tr><td align="left">VMレベルのベースパフォーマンスに対して計測された MBps のパーセント表示（キャッシュ<strong>無効</strong>なディスク）</td><td align="left">VM Uncached Bandwidth Consumed Percentage</td></tr><tr><td align="left">VMレベルのベースパフォーマンスに対して計測された IOPS のパーセント表示（キャッシュ<strong>無効</strong>なディスク）</td><td align="left">VM Uncached IOPS Consumed Percentage</td></tr></tbody></table><div class="alert is-info"><p class="alert-title">Note</p><p>※Premium ストレージをサポートする VM シリーズ上でのみ使用できます。</p><p>※バースト時の上限ではなくベースパフォーマンスを 100 % として記録されます。バーストしている場合も 100 % で記録されます。</p></div><h3 id="ディスクのキューの深さを確認する"><a href="#ディスクのキューの深さを確認する" class="headerlink" title="ディスクのキューの深さを確認する"></a>ディスクのキューの深さを確認する</h3><table><thead><tr><th align="left">確認できる内容</th><th align="left">メトリック名</th></tr></thead><tbody><tr><td align="left">OS ディスクのキューの深さを確認</td><td align="left">OS Disk Queue Depth</td></tr><tr><td align="left">データ ディスクのキューの深さを確認</td><td align="left">Data Disk Queue Depth</td></tr></tbody></table><p>ディスク パフォーマンス メトリックについては公式ドキュメントもございますので、合わせてご参照くださいませ。</p><blockquote><p>■ご参考：ディスク パフォーマンス メトリック<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/disks-metrics">https://learn.microsoft.com/ja-jp/azure/virtual-machines/disks-metrics</a></p></blockquote><hr><h2 id="2-2-実際に-Azure-ポータルでメトリックを確認する（データディスク毎に確認する方法）"><a href="#2-2-実際に-Azure-ポータルでメトリックを確認する（データディスク毎に確認する方法）" class="headerlink" title="2-2.実際に Azure ポータルでメトリックを確認する（データディスク毎に確認する方法）"></a>2-2.実際に Azure ポータルでメトリックを確認する（データディスク毎に確認する方法）</h2><p>メトリックを見る際は以下のように、Azure ポータルで対象の VM の画面より「メトリック」のブレードを選択いただくことでメトリック表示画面になります。</p><p><img src="/blog/vm/disk-metrics/disk-metric.png"></p><p>メトリックの表示自体の詳細を確認したい場合は、以下の公開ドキュメントをご参照ください。</p><blockquote><p>■ご参考: Azure Monitor メトリックの概要<br><a href="https://docs.microsoft.com/ja-jp/azure/azure-monitor/essentials/data-platform-metrics">https://docs.microsoft.com/ja-jp/azure/azure-monitor/essentials/data-platform-metrics</a></p></blockquote><blockquote><p>■ご参考：Azure Monitor のサポートされるメトリック<br><a href="https://docs.microsoft.com/ja-jp/azure/azure-monitor/essentials/metrics-supported">https://docs.microsoft.com/ja-jp/azure/azure-monitor/essentials/metrics-supported</a></p></blockquote><p>データディスクのメトリックでは、既定の表示では全データディスクの値が合算されたりした状態で表示されてしまいます。<br>各データディスク毎にメトリックを確認したい場合は、以下の手順に沿う必要がございます。<br>まず、以下のように VM のディスクブレードからデータディスクの LUN 番号を確認しましょう。  </p><p><img src="/blog/vm/disk-metrics/disk-lun.png"></p><p>以下のようにメトリック画面でディメンションを LUN で分割すると、各データディスク毎のメトリックの表示が可能になります。<br>下図では 2 つのデータディスクの情報がそれぞれ表示されていますね。</p><p><img src="/blog/vm/disk-metrics/disk-metric-lun.png"></p><p>また、LUN でフィルターをすることで、特定のデータディスクのみ表示することも可能です。</p><p><img src="/blog/vm/disk-metrics/disk-metric-filter.png"></p><hr><h2 id="3-VM-サイズ-ディスクサイズを変更する"><a href="#3-VM-サイズ-ディスクサイズを変更する" class="headerlink" title="3.VM サイズ / ディスクサイズを変更する"></a>3.VM サイズ / ディスクサイズを変更する</h2><p>上記のメトリックなどを確認の上、更に高パフォーマンスなディスクアクセスが必要となった場合は、VM サイズ / ディスクサイズを変更することが可能です。<br>オンプレミス環境の場合は新しいハードウェアの調達などが必要でしたが Azure では簡単に変更をすることが可能です。<br>手順については以下のドキュメントをご確認いただけますと幸いです。  </p><blockquote><p>■ご参考：仮想マシンのサイズの変更<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/resize-vm">https://learn.microsoft.com/ja-jp/azure/virtual-machines/resize-vm</a></p></blockquote><blockquote><p>■ご参考：マネージド ディスクをある特定のディスクの種類から別のものに切り替える<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/convert-disk-storage#switch-managed-disks-from-one-disk-type-to-another">https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/convert-disk-storage#switch-managed-disks-from-one-disk-type-to-another</a></p></blockquote><p>VM サイズ / ディスクサイズ変更には VM 停止が必要となります点、ご留意くださいませ。</p><hr><p>以上の通り、ディスクのディスクメトリックの確認について解説をさせていただきました。<br>お客様の調査等の一助となれば幸いでございます。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの富田です。&lt;br&gt;期待したディスクパフォーマンスが得られないといったお問い合わせをいただくことがあります。&lt;br&gt;そのため、今回この記事以下の内容について解説をさせていただきます。  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Azur</summary>
      
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="Linux" scheme="https://jpaztech.github.io/blog/tags/Linux/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
    <category term="Disk" scheme="https://jpaztech.github.io/blog/tags/Disk/"/>
    
  </entry>
  
  <entry>
    <title>yum/dnf update に失敗する場合の原因と解決方法</title>
    <link href="https://jpaztech.github.io/blog/vm/rhui-yum-update/"/>
    <id>https://jpaztech.github.io/blog/vm/rhui-yum-update/</id>
    <published>2023-05-02T02:00:00.000Z</published>
    <updated>2023-05-26T05:14:04.835Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは！Azure テクニカル サポート チームの高橋です。<br>今回はよく、お問い合わせを頂く<br>Azure Marketplace から作成した Red Hat Enterprise Linux (RHEL) の仮想マシンにおいて<br>yum / dnf update やパッケージのインストールに失敗する場合の<br>よくある原因とその解決方法についてご紹介いたします。</p><span id="more"></span><hr><h2 id="Azure-RHUI-リポジトリ-とは？"><a href="#Azure-RHUI-リポジトリ-とは？" class="headerlink" title="Azure RHUI (リポジトリ) とは？"></a>Azure RHUI (リポジトリ) とは？</h2><p>Azure RHUI  (Red Hat Update Infrastructure) は、Azure Marketplace にある<br>Red Hat Enterprise Linux (RHEL) の従量課金 (PAYG) イメージから作成した VM を更新するために<br>提供されているリポジトリサーバーです。</p><p>Azure Marketplace から 作成した RHEL VM は、規定で Azure RHUI へのアクセスする構成が設定されているため<br>追加の設定は不要となります。</p><p>VM から、Azure RHUI にアクセスするためには、下記の IP アドレスに対する送信規則の 443 ポートの通信許可を設定する必要があります。<br>Azure RHUI の IP アドレスは下記公開ドキュメントにおまとめしておりますのでご確認ください。<br>RHEL 7、RHEL 8 は RHUI 3、RHEL 9 は RHUI 4 が利用されております。</p><blockquote><p> □ 参考 : RHUI コンテンツ配信サーバーの IP アドレス<br>   <a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/workloads/redhat/redhat-rhui#the-ips-for-the-rhui-content-delivery-servers">https://learn.microsoft.com/ja-jp/azure/virtual-machines/workloads/redhat/redhat-rhui#the-ips-for-the-rhui-content-delivery-servers</a></p></blockquote><div class="alert is-important"><p class="alert-title">重要</p><p>※Azure RHUI へのアクセスは、弊社バックボーンネットワーク経由にて接続されており、</p><p>Azure VM から、オンプレミスのネットワークインフラストラクチャや、プロキシ、NVA (仮想アプライアンス) 経由でのアクセスはサポートされておらず、</p><p>Azure VM から直接、Azure RHUI に接続する必要がある点に注意してください。</p></div><hr><h2 id="Azure-RHUI-への接続確認"><a href="#Azure-RHUI-への接続確認" class="headerlink" title="Azure RHUI への接続確認"></a>Azure RHUI への接続確認</h2><p>yum / dnf update やパッケージのインストールに失敗する場合、<br>Azure RHUI への接続ができていない可能性がございます。<br>Azure VM 内から、curl コマンド等を使うことで、Azure RHUI への接続状況を確認することができます。<br>下記のコマンドをお試しください。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl -v https://rhui-1.microsoft.com:443</span></span><br><span class="line"><span class="comment"># curl -v https://rhui-2.microsoft.com:443</span></span><br><span class="line"><span class="comment"># curl -v https://rhui-3.microsoft.com:443</span></span><br></pre></td></tr></table></figure><p>&lt; 実行結果例 (成功時) &gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@rheltest ~]# curl -v https://rhui-1.microsoft.com:443</span><br><span class="line">* Rebuilt URL to: https://rhui-1.microsoft.com:443/</span><br><span class="line">*   Trying 52.187.75.218...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* Connected to rhui-1.microsoft.com (52.187.75.218) port 443 (#0)</span><br><span class="line">* ALPN, offering h2</span><br><span class="line">* ALPN, offering http/1.1</span><br><span class="line">* successfully set certificate verify locations:</span><br><span class="line">*   CAfile: /etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">CApath: none</span><br><span class="line">* TLSv1.3 (OUT), TLS handshake, Client hello (1):</span><br><span class="line">* TLSv1.3 (IN), TLS handshake, Server hello (2):</span><br><span class="line">* TLSv1.2 (IN), TLS handshake, Certificate (11):</span><br><span class="line">* TLSv1.2 (IN), TLS handshake, Server key exchange (12):</span><br><span class="line">* TLSv1.2 (IN), TLS handshake, Server finished (14):</span><br><span class="line">* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):</span><br><span class="line">* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):</span><br><span class="line">* TLSv1.2 (OUT), TLS handshake, Finished (20):</span><br><span class="line">* TLSv1.2 (IN), TLS handshake, Finished (20):</span><br><span class="line">* SSL connection using TLSv1.2 / ECDHE-RSA-AES256-GCM-SHA384</span><br><span class="line">* ALPN, server did not agree to a protocol</span><br><span class="line">* Server certificate:</span><br><span class="line">*  subject: C=US; ST=WA; L=Redmond; O=Microsoft Corporation; CN=rhui-1.microsoft.com</span><br><span class="line">*  start date: Dec  7 11:14:49 2021 GMT</span><br><span class="line">*  expire date: Dec  2 11:14:49 2022 GMT</span><br><span class="line">*  subjectAltName: host &quot;rhui-1.microsoft.com&quot; matched cert&#x27;s &quot;rhui-1.microsoft.com&quot;</span><br><span class="line">*  issuer: C=US; O=Microsoft Corporation; CN=Microsoft Azure TLS Issuing CA 01</span><br><span class="line">*  SSL certificate verify ok.</span><br><span class="line">&gt; GET / HTTP/1.1</span><br><span class="line">&gt; Host: rhui-1.microsoft.com</span><br><span class="line">&gt; User-Agent: curl/7.61.1</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Date: Mon, 24 Jan 2022 06:51:00 GMT</span><br><span class="line">&lt; Server: Apache/2.4.6 (Red Hat Enterprise Linux)</span><br><span class="line">&lt; X-Served-By: southeastasia-cds0</span><br><span class="line">&lt; X-Content-Type-Options: nosniff</span><br><span class="line">&lt; Last-Modified: Thu, 20 Jun 2019 06:37:48 GMT</span><br><span class="line">&lt; ETag: &quot;0-58bbb9592306b&quot;</span><br><span class="line">&lt; Accept-Ranges: bytes</span><br><span class="line">&lt; Content-Length: 0</span><br><span class="line">&lt; Connection: close</span><br><span class="line">&lt; Content-Type: text/html</span><br><span class="line">&lt;</span><br><span class="line">* Closing connection 0</span><br><span class="line">* TLSv1.2 (OUT), TLS alert, close notify (256):</span><br></pre></td></tr></table></figure><p>&lt; 実行結果例 (失敗時) &gt; </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@rhelvm ~]# curl -v https://rhui-1.microsoft.com:443</span><br><span class="line">* Rebuilt URL to: https://rhui-1.microsoft.com:443/</span><br><span class="line">*   Trying 52.187.75.218...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* connect to 52.187.75.218 port 443 failed: Connection timed out</span><br><span class="line">* Failed to connect to rhui-1.microsoft.com port 443: Connection timed out</span><br><span class="line">* Closing connection 0</span><br><span class="line">curl: (7) Failed to connect to rhui-1.microsoft.com port 443: Connection timed out</span><br></pre></td></tr></table></figure><p>Azure RHUI への接続確認が失敗する場合には、NSG やプロキシ等のネットワーク設定を確認する必要がございます。<br>よくお問い合わせを頂くエラー原因と解決方法は、以下のようになります。</p><hr><h2 id="エラーの原因その-1-Azure-RHUI-への接続ができない-NSG"><a href="#エラーの原因その-1-Azure-RHUI-への接続ができない-NSG" class="headerlink" title="エラーの原因その 1 : Azure RHUI への接続ができない (NSG)"></a>エラーの原因その 1 : Azure RHUI への接続ができない (NSG)</h2><p>セキュリティ上の理由から、Network Security Group (NSG) を利用して、<br>Azure VM からインターネットへのアクセスを制限を設定している場合があるかと存じます。<br>Azure portal から対象の仮想マシンを選択後、[ネットワーク] から確認することができます。<br>下記画像の例では、送信ポートの規則で、インターネットへの接続を拒否しています。</p><p><img src="/blog/vm/rhui-yum-update/01.png"></p><p>本設定がある場合には、Azure RHUI への接続確認は、失敗することが想定され、<br>yum update を実施した際や、パッケージのインストール時にはタイムアウトエラーが発生します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@rhelvm ~]# yum update</span><br><span class="line">Red Hat Enterprise Linux 8 for x86_64 - BaseOS - Extended Update Support from RHUI (RPMs)                                                              0.0  B/s |   0  B     01:30</span><br><span class="line">Failed to download metadata for repo &#x27;rhel-8-for-x86_64-baseos-eus-rhui-rpms&#x27;</span><br><span class="line">Error: Failed to download metadata for repo &#x27;rhel-8-for-x86_64-baseos-eus-rhui-rpms&#x27;</span><br></pre></td></tr></table></figure><p><img src="/blog/vm/rhui-yum-update/02.png"></p><p>この場合の解決方法としては、Azure RHUI へアクセスできるように、<br>Azure RHUI サーバーの IP アドレスに対する送信規則の 443 ポートの通信許可を設定する必要があります。<br>下記画像の通り、”送信セキュリティ規則の追加” から、通信許可の設定を追加する必要があります。<br>また、優先度は、DenyInternet (インターネットへの制限規則) より高くする必要がある点にご注意ください。</p><p><img src="/blog/vm/rhui-yum-update/03.png"></p><hr><h2 id="エラーの原因その-2-Azure-RHUI-への接続ができない-Proxy-等"><a href="#エラーの原因その-2-Azure-RHUI-への接続ができない-Proxy-等" class="headerlink" title="エラーの原因その 2 : Azure RHUI への接続ができない (Proxy 等)"></a>エラーの原因その 2 : Azure RHUI への接続ができない (Proxy 等)</h2><p>Azure VM から、オンプレミスのネットワークインフラストラクチャや、プロキシ、NVA (仮想アプライアンス) 経由での Azure RHUI へのアクセスはサポートされていないため、<br>Azure RHUI へのアクセスは、Azure 内の IP アドレス範囲内の VM から直接アクセスする必要がございます。<br>Azure Firewall をご利用の場合には、適切に Azure RHUI に対してアクセスできるよう設定頂くことで、アクセス可能となります。</p><p>この場合の解決方法としては、Azure VM が Azure RHUI の IP アドレスに直接接続できるようユーザー定義のルートテーブル UDR (User Defined Route) を作成する必要があります。<br>下記画像のように、RHUI コンテンツ配信サーバーの IP アドレス全てに対して、<br>次ホップ (Next hops) の種類に “Internet” を指定した UDR を作成頂く必要があります。</p><p><img src="/blog/vm/rhui-yum-update/04.png"></p><p>Azure VM のルートテーブルの作成手順については、下記公開ドキュメントをご確認ください。</p><blockquote><p>  □ 参考 : ルート テーブルの作成、変更、削除 | ルートの作成<br>   <a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/manage-route-table#create-a-route-table">https://learn.microsoft.com/ja-jp/azure/virtual-network/manage-route-table#create-a-route-table</a></p></blockquote><div class="alert is-success"><p class="alert-title">ヒント</p><p>※プロキシの設定を実施している場合は、/etc/yum.conf 内の “proxy=” のプロキシ設定がないかご確認ください。</p><p>  プロキシ設定があった場合、コメントアウト等で無効にしてください。</p></div><hr><h2 id="エラーの原因その-3-Azure-RHUI-への接続ができない-外部接続不可の構成"><a href="#エラーの原因その-3-Azure-RHUI-への接続ができない-外部接続不可の構成" class="headerlink" title="エラーの原因その 3 : Azure RHUI への接続ができない (外部接続不可の構成)"></a>エラーの原因その 3 : Azure RHUI への接続ができない (外部接続不可の構成)</h2><p>ご利用の環境によっては、Standard SKU の内部ロードバランサーのバックエンドにAzure VM を配置し、外部へのインターネット接続を制限している場合もあるかと思います。<br>外部接続不可の環境では、yum update を実施した際や、パッケージのインストール時にタイムアウトエラーが発生します。<br>Azure RHUI に接続するためには、NAT Gateway または VM にパブリック IP アドレスを関連付けいただくといった構成に変更する必要があります。</p><p>ご利用の VM が外部接続不可な構成であるかについての確認手順については、<br>以下の弊社ブログにもお纏めしておりますのでご参照ください。</p><blockquote><p>  □ 参考 : Azure VM の外部接続 (SNAT) オプション まとめ<br>   <a href="https://jpaztech.github.io/blog/network/snat-options-for-azure-vm/">https://jpaztech.github.io/blog/network/snat-options-for-azure-vm/</a></p></blockquote><div class="alert is-important"><p class="alert-title">重要</p><p>※内部ロードバランサーのバックエンドに VM がない場合でも、可用性セット内の VM が内部ロードバランサーのバックエンドに配置されている場合、</p><p>可用性セット内の VM は全て外部接続ができなくなり、RHUI に繋がらない事象が発生するのでご注意ください。可用性セットの構成変更等ご検討頂ければと思います。</p></div><hr><h2 id="エラーの原因その-4-クライアント証明書の期限切れ"><a href="#エラーの原因その-4-クライアント証明書の期限切れ" class="headerlink" title="エラーの原因その 4 : クライアント証明書の期限切れ"></a>エラーの原因その 4 : クライアント証明書の期限切れ</h2><p>古い RHEL VM イメージを利用している際には、 TLS/SSL クライアント証明書の期限が切れているために、<br>Azure RHUI に接続できない問題が発生することがあります。<br>クライアント証明書の期限が切れた際には、yum update を実施した際に下記のようなエラーが出力されることがあります。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@rhelvm ~]# yum update</span><br><span class="line">Loaded plugins: langpacks, product-id, search-disabled-repos</span><br><span class="line">rhui-microsoft-azure-rhel7-eus                                                                   | 2.1 kB  00:00:00</span><br><span class="line">https://rhui-1.microsoft.com/pulp/repos//content/dist/rhel/rhui/server/7/7Server/x86_64/dotnet/1/os/repodata/repomd.xml: [Errno 14] curl#58 - &quot;SSL peer rejected your certificate as expired.&quot;</span><br><span class="line">Trying other mirror.</span><br><span class="line">https://rhui-2.microsoft.com/pulp/repos//content/dist/rhel/rhui/server/7/7Server/x86_64/dotnet/1/os/repodata/repomd.xml: [Errno 14] curl#58 - &quot;SSL peer rejected your certificate as expired.&quot;</span><br><span class="line">Trying other mirror.</span><br><span class="line">https://rhui-3.microsoft.com/pulp/repos//content/dist/rhel/rhui/server/7/7Server/x86_64/dotnet/1/os/repodata/repomd.xml: [Errno 14] curl#58 - &quot;SSL peer rejected your certificate as expired.&quot;</span><br><span class="line">Trying other mirror.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@rhel82 ~]# yum update</span><br><span class="line">Red Hat Enterprise Linux 8 for x86_64 - BaseOS - Extended Update Support from RHUI (RPM 0.0  B/s |   0  B     00:02</span><br><span class="line">Errors during downloading metadata for repository &#x27;rhel-8-for-x86_64-baseos-eus-rhui-rpms&#x27;:</span><br><span class="line">  - Curl error (56): Failure when receiving data from the peer for https://rhui-3.microsoft.com/pulp/repos/content/eus/rhel8/rhui/8.2/x86_64/baseos/os/repodata/repomd.xml [OpenSSL SSL_read: error:14094415:SSL routines:ssl3_read_bytes:sslv3 alert certificate expired, errno 0]</span><br><span class="line">  - Curl error (56): Failure when receiving data from the peer for https://rhui-1.microsoft.com/pulp/repos/content/eus/rhel8/rhui/8.2/x86_64/baseos/os/repodata/repomd.xml [OpenSSL SSL_read: error:14094415:SSL routines:ssl3_read_bytes:sslv3 alert certificate expired, errno 0]</span><br><span class="line">  - Curl error (56): Failure when receiving data from the peer for https://rhui-2.microsoft.com/pulp/repos/content/eus/rhel8/rhui/8.2/x86_64/baseos/os/repodata/repomd.xml [OpenSSL SSL_read: error:14094415:SSL routines:ssl3_read_bytes:sslv3 alert certificate expired, errno 0]</span><br><span class="line">Error: Failed to download metadata for repo &#x27;rhel-8-for-x86_64-baseos-eus-rhui-rpms&#x27;: Cannot download repomd.xml: Cannot download repodata/repomd.xml: All mirrors were tried</span><br></pre></td></tr></table></figure><p>この場合の解決方法としては、下記コマンドを実施頂き、<br>クライアント証明書を更新頂くことで、Azure RHUI へのアクセスができるようになることが想定されます。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update -y --disablerepo=<span class="string">&#x27;*&#x27;</span> --enablerepo=<span class="string">&#x27;*microsoft*&#x27;</span></span><br></pre></td></tr></table></figure><p>※本コマンドは、rhui の rpm のみを更新するコマンドとなります。<br>本事象については、以下の公開ドキュメントにもお纏めしております。</p><blockquote><p>□ 参考 : Azure での RHUI 証明書の問題のトラブルシューティング<br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-linux-rhui-certificate-issues?tabs=rhel7-eus,rhel7-noneus,rhel7-rhel-sap-apps">https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-linux-rhui-certificate-issues?tabs=rhel7-eus%2Crhel7-noneus%2Crhel7-rhel-sap-apps</a></p></blockquote><div class="alert is-success"><p class="alert-title">ヒント</p><p>解消しない場合には、下記コマンドも併せてお試しください</p><p>#キャッシュデータの削除し、キャッシュの更新</p><p>sudo yum clean all</p><p>sudo yum makecache</p></div><hr><h2 id="補足情報"><a href="#補足情報" class="headerlink" title="補足情報"></a>補足情報</h2><p>今回ご紹介した方法でも、事象が解消しない場合には、<br>yum repolist all コマンドを実行頂き、有効なリポジトリをご確認頂ければと思います。</p><p>カスタムイメージや、ゴールドイメージの BYOS イメージをご利用されている場合には、<br>RHSM や サテライトに接続する必要があります。</p><blockquote><p>□ 参考 : Azure のオンデマンド Red Hat Enterprise Linux VM 用 Red Hat Update Infrastructure<br>   <a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/workloads/redhat/redhat-rhui">https://learn.microsoft.com/ja-jp/azure/virtual-machines/workloads/redhat/redhat-rhui</a></p></blockquote><p>本稿が皆様のお役に立てれば幸いです。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは！Azure テクニカル サポート チームの高橋です。&lt;br&gt;今回はよく、お問い合わせを頂く&lt;br&gt;Azure Marketplace から作成した Red Hat Enterprise Linux (RHEL) の仮想マシンにおいて&lt;br&gt;yum / dnf update やパッケージのインストールに失敗する場合の&lt;br&gt;よくある原因とその解決方法についてご紹介いたします。&lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Linux" scheme="https://jpaztech.github.io/blog/tags/Linux/"/>
    
    <category term="RHEL" scheme="https://jpaztech.github.io/blog/tags/RHEL/"/>
    
    <category term="RHUI" scheme="https://jpaztech.github.io/blog/tags/RHUI/"/>
    
  </entry>
  
  <entry>
    <title>Azure VM のシステムリソース高騰の原因調査について</title>
    <link href="https://jpaztech.github.io/blog/vm/vm-highusage/"/>
    <id>https://jpaztech.github.io/blog/vm/vm-highusage/</id>
    <published>2023-04-28T03:00:00.000Z</published>
    <updated>2023-05-26T05:14:04.895Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカルサポートの橋本です。</p><p>Azure VM の CPU 、メモリの使用率およびディスクビジー率が高騰し、原因調査のお問合せをいただくことがございます。<br>システムリソース高騰のトラブルシューティングでは事象発生中の OS のログが必要なことから、<br>事後対応による原因究明はほぼ不可能なため、発生中に OS にログインしてログを取得する、または事象発生に備えて定期的なログ取得設定を実施しておく必要があります。</p><p>本ブログ記事では、複数ございます公式ドキュメントのシステムリソース高騰のトラブルシューティングのご案内をお纏めしつつ、よくあるお問合せとトラブルシューティングの共通事項などを踏まえまして以下をご案内させていただきます。</p><span id="more"></span><p>　・Azure VM システムリソース高騰の一般的な要因<br>　・原因調査の流れ<br>　・問題のプロセスを追跡する</p><p>関連ドキュメント</p><blockquote><p>ご参考：Linux でのパフォーマンスのトラブルシューティングとボトルネックの分離<br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-performance-bottlenecks-linux">https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-performance-bottlenecks-linux</a></p></blockquote><blockquote><p>ご参考：Azure Windows 仮想マシンでの CPU 使用率の高い問題のトラブルシューティング<br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-high-cpu-issues-azure-windows-vm">https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-high-cpu-issues-azure-windows-vm</a></p></blockquote><blockquote><p>ご参考：Azure Windows 仮想マシンでのメモリの高い問題のトラブルシューティング<br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/azure-windows-vm-memory-issue">https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/azure-windows-vm-memory-issue</a></p></blockquote><hr><h2 id="■-Azure-VM-システムリソース高騰の一般的な要因"><a href="#■-Azure-VM-システムリソース高騰の一般的な要因" class="headerlink" title="■ Azure VM システムリソース高騰の一般的な要因"></a>■ Azure VM システムリソース高騰の一般的な要因</h2><p>システムリソース高騰要因の多くはご利用のアプリケーションのワークロードに依存したものとなり、<br>まれにご利用の OS 、アプリケーションのプログラムのエラー又はバグ等の不具合による原因もございます。<br>システムリソースを多く利用するプロセスを特定することがトラブルシューティングにおいて必須の作業となります。</p><p>プロセスが特定できましたら、アプリケーションログなどから、該当プロセスの観点から当時の接続数などの負荷状況を確認、<br>エラーなどによるリトライや処理滞留がリソースひっ迫を起こしていないか、<br>ご利用バージョンより既知不具合発生報告の事例確認等を行います。</p><p>なお、 Microsoft から提供されていない、 OS プロセス以外のサードパーティ製品や、<br>又はお客様作成の業務アプリケーションのプロセスが問題を引き起こしているケースですと、<br>プロセス機能の提供元へ原因調査をお願いさせていただいております。<br>これは、プロセスがなぜ多くのシステムリソースを利用しているか、<br>その妥当性については該当プロセス側の解析調査が必要となり、<br>弊社より  判断することができないためとなります。</p><blockquote><p>ご参考：Azure Windows 仮想マシンでの CPU 使用率の高い問題のトラブルシューティング - 一般的な要因<br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-high-cpu-issues-azure-windows-vm#common-factors">https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-high-cpu-issues-azure-windows-vm#common-factors</a></p></blockquote><hr><h2 id="■-原因調査の流れ"><a href="#■-原因調査の流れ" class="headerlink" title="■ 原因調査の流れ"></a>■ 原因調査の流れ</h2><p>お客様環境の Azure VM は監視ソフトウェアや Azure のメトリックのアラート設定によって<br>OS レベルのリソース状況を監視しているかと思います。<br>しかしながら、OS 上のプロセスレベルでのシステムリソース利用状況は Azure メトリックではログ取得できず、<br>監視ソフトウェアなどでもプロセスレベルの情報を取得しているケースはそれほど多くないと思います。</p><p>プロセスレベルでのシステムリソースの利用状況を別途取得しておりませんと、<br>事後に問題のプロセスを特定することがほぼ不可能となります。<br>この点を踏まえまして、一般的に Azure VM のシステムリソース高騰の原因調査は以下のような流れとなります。</p><p>  <strong>(1) 事前のログ取得設定</strong><br>  <strong>(2) システムリソース高騰が発生</strong><br>  <strong>(3) (1) で取得設定していたログを回収し、稼働プロセス毎のリソース使用状況を解析</strong><br>  <strong>(4) 特定したプロセスの観点から原因を究明</strong></p><hr><h2 id="■-問題のプロセスを追跡する"><a href="#■-問題のプロセスを追跡する" class="headerlink" title="■ 問題のプロセスを追跡する"></a>■ 問題のプロセスを追跡する</h2><p>ご利用の OS によって問題となっているプロセスの追跡に利用するツールが異なりますため、<br>Windows 、 Linux それぞれのシナリオ毎に記載させていただきます。</p><h4 id="【Windows-環境で問題のプロセスを追跡する】"><a href="#【Windows-環境で問題のプロセスを追跡する】" class="headerlink" title="【Windows 環境で問題のプロセスを追跡する】"></a>【Windows 環境で問題のプロセスを追跡する】</h4><p>Windows 環境では、標準機能のパフォーマンスモニターを利用してプロセスレベルの情報を含む、<br>各システムリソースの利用状況を取得することが可能となります。<br>パフォーマンスモニターでのログ収集方法と、問題プロセスを追跡する方法についてはこちらの記事をご参照ください。</p><blockquote><p>ご参考：パフォーマンス ログ収集<br><a href="https://jpwinsup.github.io/blog/2021/06/07/Performance/SystemResource/PerformanceLogging/">https://jpwinsup.github.io/blog/2021/06/07/Performance/SystemResource/PerformanceLogging/</a></p></blockquote><blockquote><p>ご参考：Azure Windows 仮想マシンでの CPU 使用率の高い問題のトラブルシューティング - プロセスを特定する<br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-high-cpu-issues-azure-windows-vm#identify-the-process">https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshoot-high-cpu-issues-azure-windows-vm#identify-the-process</a></p></blockquote><h4 id="【Linux-環境で問題のプロセスを追跡する】"><a href="#【Linux-環境で問題のプロセスを追跡する】" class="headerlink" title="【Linux 環境で問題のプロセスを追跡する】"></a>【Linux 環境で問題のプロセスを追跡する】</h4><p>Linux 環境では、プロセスレベルのリソース利用状況を確認するコマンドはありますが、<br>Windows のパフォーマンスモニターのようにスケジュール機能などが組み込まれたものがございません。</p><p>このため、 cron などの機能と組み合わせてコマンドでプロセス利用状況を定期的に取得する形となりますが、<br>公式ドキュメントには ps や top コマンドの説明のみでしたので、cron と合わせてご利用する際のサンプルを<br>以下にご用意させていただきます。</p><p>なお、記事内のサンプルスクリプトは、Microsoft の標準サポートプログラムまたはサービスではサポートされません。<br>サンプル スクリプトは現状有姿で提供され、いかなる保証も行いません。<br>この点についてはご了承のうえでご利用をお願いいたします。</p><p><strong>————————————————————————-</strong><br><strong>統計情報の取得</strong><br><strong>————————————————————————-</strong><br>プロセス毎のシステムリソース利用状況について事象発生前後の傾向を確認するため<br>cron にてプロセス情報の確認コマンドを定期実行します。</p><ul><li>ログ出力先ディレクトリの名前は以下を想定しています。<br>/var/osperf<br>こちらは空き容量の十分にある任意のディレクトリに変更いただいて問題ございません。<br>出力ログのサイズは環境に依存いたしますが検証環境では 1 回あたり 60 KB 程度でございました。</li></ul><ol><li><p>root ユーザにスイッチします。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su -</span><br></pre></td></tr></table></figure></li><li><p>ログ取得のスクリプトを作成します</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/osperf</span><br><span class="line">touch /var/osperf/osperf.sh</span><br><span class="line">chmod 700 /var/osperf/osperf.sh</span><br><span class="line">vi /var/osperf/osperf.sh</span><br><span class="line">===</span><br><span class="line">date &gt;&gt; /var/osperf/`date +%y%m%d`.free.out ; /usr/bin/free &gt;&gt; /var/osperf/`date +%y%m%d`.free.out</span><br><span class="line">date &gt;&gt; /var/osperf/`date +%y%m%d`.meminfo.out ; /usr/bin/cat /proc/meminfo &gt;&gt; /var/osperf/`date +%y%m%d`.meminfo.out</span><br><span class="line">date &gt;&gt; /var/osperf/`date +%y%m%d`.slabtop.out ; /usr/bin/slabtop -o &gt;&gt; /var/osperf/`date +%y%m%d`.slabtop.out</span><br><span class="line">date &gt;&gt; /var/osperf/`date +%y%m%d`.psaux.out ; /usr/bin/ps aux --sort -rss &gt;&gt; /var/osperf/`date +%y%m%d`.psaux.out</span><br><span class="line">date &gt;&gt; /var/osperf/`date +%y%m%d`.top.out ; /usr/bin/top -b -n 1 &gt;&gt; /var/osperf/`date +%y%m%d`.top.out</span><br><span class="line">===</span><br><span class="line">※osperf.sh ファイルにこちらの五行を記載</span><br></pre></td></tr></table></figure></li><li><p>root 権限で以下コマンドより root ユーザの crontab を修正します</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">crontab -e -u root</span><br><span class="line">===</span><br><span class="line">*/10 * * * * sh /var/osperf/osperf.sh</span><br><span class="line">===</span><br><span class="line">※こちら、10 分毎に一度実行される形としております。</span><br></pre></td></tr></table></figure></li><li><p>システムリソースの高騰の事象が再現しましたら<br>/var/osperf ディレクトリの情報の取得をお願いいたします。</p></li></ol><p>今回ご案内させていただきました内容が、皆様のお役に立てますと幸いでございます。</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカルサポートの橋本です。&lt;/p&gt;
&lt;p&gt;Azure VM の CPU 、メモリの使用率およびディスクビジー率が高騰し、原因調査のお問合せをいただくことがございます。&lt;br&gt;システムリソース高騰のトラブルシューティングでは事象発生中の OS のログが必要なことから、&lt;br&gt;事後対応による原因究明はほぼ不可能なため、発生中に OS にログインしてログを取得する、または事象発生に備えて定期的なログ取得設定を実施しておく必要があります。&lt;/p&gt;
&lt;p&gt;本ブログ記事では、複数ございます公式ドキュメントのシステムリソース高騰のトラブルシューティングのご案内をお纏めしつつ、よくあるお問合せとトラブルシューティングの共通事項などを踏まえまして以下をご案内させていただきます。&lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="CPU" scheme="https://jpaztech.github.io/blog/tags/CPU/"/>
    
    <category term="Memory" scheme="https://jpaztech.github.io/blog/tags/Memory/"/>
    
  </entry>
  
  <entry>
    <title>サービス エンドポイントとプライベート エンドポイントの違い</title>
    <link href="https://jpaztech.github.io/blog/network/pe-difference-se/"/>
    <id>https://jpaztech.github.io/blog/network/pe-difference-se/</id>
    <published>2023-04-21T03:00:00.000Z</published>
    <updated>2023-05-26T05:14:04.555Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの箕輪です。</p><p>今回はお問い合わせを多くいただくサービス エンドポイントとプライベート エンドポイントの違いについてご紹介します。</p><span id="more"></span><h2 id="機能の違いについて"><a href="#機能の違いについて" class="headerlink" title="機能の違いについて"></a>機能の違いについて</h2><p>サービス エンドポイントとプライベートエンドポイントを端的に紹介すると、サービス エンドポイントは「Azure PaaS のパブリック IP アドレスに対する接続を最適化する」機能であり、プライベート エンドポイントは「プライベート IP アドレスで Azure PaaS に接続する」機能です。<br>サービス エンドポイントとプライベート エンドポイントの機能差分については下記の通りです。</p><table><thead><tr><th align="center"></th><th align="left">サービス エンドポイント (SE)</th><th align="left">プライベート エンドポイント (PE)</th></tr></thead><tbody><tr><td align="center">接続対象のリソース</td><td align="left">Azure PaaS</td><td align="left">Azure PaaS と PLS (*1)</td></tr><tr><td align="center">構成方法</td><td align="left">サブネット単位で有効化</td><td align="left">PE リソースの構成</td></tr><tr><td align="center">利用可能な送信元リソース</td><td align="left">SE を有効化したサブネット上のリソース</td><td align="left">PE に IP 疎通性があるリソース</td></tr><tr><td align="center">接続先の IP アドレス</td><td align="left">Azure PaaS のパブリック IP アドレス</td><td align="left">PE のプライベート IP アドレス</td></tr><tr><td align="center">接続制限</td><td align="left">Azure PaaS の設定でサブネット単位の指定 (*2)</td><td align="left">PE のサブネットの NSG で指定 (*3)</td></tr><tr><td align="center">接続元の IP アドレス(*4)</td><td align="left">サブネット上のリソースのプライベート IP アドレス</td><td align="left">PE に接続するリソースの IP アドレス</td></tr></tbody></table><p>※ 上記の表にあるサブネットは、Azure の仮想ネットワーク上のサブネットを指します。</p><p>(*1)PLS は <a href="https://learn.microsoft.com/ja-jp/azure/private-link/private-link-service-overview">Private Link Service</a> を指す。Azure 内部ロードバランサーに対して関連付けする機能。<br><br>(*2)接続制限の設定については、接続先の Azure PaaS に依存する。<br><br>(*3)PE が構成された VNet のサブネット上における<a href="https://learn.microsoft.com/ja-jp/azure/private-link/disable-private-endpoint-network-policy?tabs=network-policy-portal">ネットワーク ポリシー設定</a>が必要。<br><br>(*4)接続先の Azure PaaS によって出力されるログの形態によって異なります。</p><h2 id="接続構成について"><a href="#接続構成について" class="headerlink" title="接続構成について"></a>接続構成について</h2><p>サービス エンドポイントとプライベート エンドポイントは、Azure PaaS に対する接続を提供する機能であり、どちらのエンドポイントを利用するかは接続元のリソース (クライアント) の動作に依存します。<br>今回は Storage Account の Azure Blob (contoso.blob.windows.net) に対して接続する構成における、3 つのシナリオにおける接続イメージについてご紹介します。</p><p><br><u><strong>シナリオ 1 : サービス エンドポイントとプライベート エンドポイントが構成されていない</strong></u><br><br>この構成では、仮想マシンから Blob に対して、インターネット経由で接続します。<br>接続元のクライアントは、接続先の FQDN に対して名前解決の結果として Azure Blob のパブリック IP アドレスが応答されます。<br>接続元のクライアントは、Azure Blob のパブリック IP アドレスに対して、Azure の既定の経路 (0.0.0.0/0) に従って、インターネット経由で接続します。</p><p>下記の図は便宜上インターネットに接続している構成図としていますが、<a href="https://learn.microsoft.com/ja-jp/azure/networking/microsoft-global-network">Azure の仮想マシンから Azure PaaS へ接続は Azure バックボーン ネットワークを経由して接続する</a>ため、実際の通信はパブリック インターネットを経由しません。</p><p><img src="/blog/network/pe-difference-se/01.png"><br><br></p><p><br><u><strong>シナリオ 2 : サービス エンドポイントを有効化</strong></u><br><br>この構成では、仮想マシンから Blob に対して、サービス エンドポイントを介して接続します。<br>接続元のクライアントは、接続先の FQDN に対して名前解決の結果として Azure Blob のパブリック IP アドレスが応答されます。<br>接続元のクライアントは、Azure Blob のパブリック IP アドレスに対して、サービス エンドポイントで追加された内部経路情報 (VirtualNetworkServiceEndpoint) に従って、Azure 内部で最適化された経路で接続します。</p><p><img src="/blog/network/pe-difference-se/02.png"><br><br></p><p><br><u><strong>シナリオ 3 : プライベート エンドポイントを有効化</strong></u><br><br>この構成では、仮想マシンから Azure Blob に対して、プライベート エンドポイントを介して接続します。<br>接続元のクライアントは、接続先の FQDN に対して名前解決の結果として Blob 接続用のプライベート エンドポイントの IP アドレス (プライベート IP アドレス) が応答されます。<br>接続元のクライアントは、プライベート エンドポイントの IP アドレスに対して Blob に接続します。</p><p>なお、下記の図では便宜上、簡略していますが、プライベート DNS ゾーンを利用している構成を前提としています。</p><p><img src="/blog/network/pe-difference-se/03.png"><br><br></p><h2 id="使い分けについて"><a href="#使い分けについて" class="headerlink" title="使い分けについて"></a>使い分けについて</h2><p>上記の通り、サービス エンドポイントとプライベート エンドポイントでは、接続元のクライアントからの接続先 IP アドレスが異なるため、DNS 構成により使い分けが可能です。<br>つまり、サービス エンドポイントとプライベート エンドポイントを同時に構成することは可能で、接続先 IP アドレスを DNS レイヤーで切り替えることで接続を切り替えます。<br>サービス エンドポイントとプライベート エンドポイントの使い分けの一例としては、下記の点をご参考にしていただければ幸いです。</p><p>サービス エンドポイントは対象の仮想ネットワークのサブネットに対してのみ適用可能な機能となるため、ExpressRoute や VPN で接続されたオンプレミスのリソースはサービス エンドポイントを利用できません。しかし、強制トンネリング構成において特定の Azure PaaS に対してのパブリック エンドポイントへのアクセスを構成できることや、Azure PaaS 側でサービス エンドポイントを有効化した仮想ネットワーク上のサブネットからの接続に制限できること、これらの機能が追加費用なくご利用いただくことが特徴として挙げられます。</p><p>プライベートエンドポイントでは、プライベート エンドポイントのプライベート IP アドレスに接続性があれば利用可能なため、ExpressRoute や VPN で接続されたオンプレミスのリソースから Azure PaaS に接続するシナリオでご利用いただくことが可能です。なお、サービス エンドポイントとは異なり、<a href="https://azure.microsoft.com/ja-jp/pricing/details/private-link/">プライベート エンドポイントは費用が発生する点</a>にはご留意ください。</p><h2 id="公開情報について"><a href="#公開情報について" class="headerlink" title="公開情報について"></a>公開情報について</h2><p>サービス エンドポイントとプライベート エンドポイントの概要や、構成の手順などについては下記の公開情報に記載がございますので併せてご確認ください。</p><p>仮想ネットワーク サービス エンドポイント<br><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/virtual-network-service-endpoints-overview">https://learn.microsoft.com/ja-jp/azure/virtual-network/virtual-network-service-endpoints-overview</a></p><p>Azure Private Link とは<br><br><a href="https://learn.microsoft.com/ja-jp/azure/private-link/private-link-overview?toc=/azure/virtual-network/toc.json">https://learn.microsoft.com/ja-jp/azure/private-link/private-link-overview?toc=%2Fazure%2Fvirtual-network%2Ftoc.json</a></p><p>クイックスタート: Azure portal を使用してプライベート エンドポイントを作成する<br><br><a href="https://learn.microsoft.com/ja-jp/azure/private-link/create-private-endpoint-portal?tabs=dynamic-ip">https://learn.microsoft.com/ja-jp/azure/private-link/create-private-endpoint-portal?tabs=dynamic-ip</a></p><h2 id="よくいただくご質問"><a href="#よくいただくご質問" class="headerlink" title="よくいただくご質問"></a>よくいただくご質問</h2><p><strong>・プライベート エンドポイントに対してプライベート IP アドレスでアクセスしても接続できません</strong></p><p>Azure PaaS はホスト名を用いて通信を識別しています。プライベート エンドポイントは Azure PaaS への接続経路を提供する機能のみであり、実際のリクエストにはホスト名を含めた FQDN が必要です。</p><p><strong>・サービス エンドポイントとプライベート エンドポイントのどちらを選択しているかわかりません</strong></p><p>Azure の機能では明確に確認することはできませんが、接続元のクライアント上で、対象の FQDN に対する名前解決を実行し、パブリック IP アドレスが応答されればサービス エンドポイント、プライベート IP アドレスが応答されればプライベート エンドポイント経由で接続していると判断できます。</p><p><strong>・Azure PaaS から仮想ネットワークへの接続にサービス エンドポイントやプライベート エンドポイントは使えますか</strong></p><p>いいえ、ご利用いただけません。サービス エンドポイントとプライベート エンドポイントは、仮想ネットワークから Azure PaaS への接続時に利用可能なサービスです。Azure PaaS から仮想ネットワークの接続については、各サービスによって機能の有無がありますが、VNet 統合等の機能で利用できます。</p><p>以上、ご参考になれば幸いです。</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの箕輪です。&lt;/p&gt;
&lt;p&gt;今回はお問い合わせを多くいただくサービス エンドポイントとプライベート エンドポイントの違いについてご紹介します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Network" scheme="https://jpaztech.github.io/blog/tags/Network/"/>
    
    <category term="Private Endpoint" scheme="https://jpaztech.github.io/blog/tags/Private-Endpoint/"/>
    
    <category term="Service Endpoint" scheme="https://jpaztech.github.io/blog/tags/Service-Endpoint/"/>
    
  </entry>
  
  <entry>
    <title>Firewall からインターネットに SNAT して通信する時のパブリック IP の使われ方</title>
    <link href="https://jpaztech.github.io/blog/network/fw-snat/"/>
    <id>https://jpaztech.github.io/blog/network/fw-snat/</id>
    <published>2023-04-16T05:30:00.000Z</published>
    <updated>2023-05-26T05:14:04.555Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの薄井です。<br>今回は Azure Firewall に関連付けたパブリック IP の SNAT 時の使われ方について紹介します。</p><span id="more"></span><h2 id="Azure-Firewall-のパブリック-IP-による-SNAT-について"><a href="#Azure-Firewall-のパブリック-IP-による-SNAT-について" class="headerlink" title="Azure Firewall のパブリック IP による SNAT について"></a>Azure Firewall のパブリック IP による SNAT について</h2><p>Azure Firewall を経由してインターネット宛に通信するときは、関連付けられているパブリック IP へ送信元のアドレス変換（SNAT）が行われます。パブリック IP が 1 つしかない時はそのパブリック IP のアドレスしか使用されませんが、複数のパブリック IP アドレスが Azure Firewall に関連付けられている場合の動作について、以下のドキュメントではランダムに選択する旨の記載がございます。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/firewall/deploy-multi-public-ip-powershell">Azure PowerShell を使用して複数のパブリック IP アドレスを使用する Azure Firewall をデプロイする</a></p><blockquote><p>SNAT -送信 SNAT 接続に追加のポートを使用できるので、SNAT ポートが不足する可能性が低減されます。 現時点では、Azure Firewall は、<em><strong>接続に使用する送信元パブリック IP アドレスをランダムに選択します。</strong></em> ネットワークにダウンストリーム フィルターがある場合、ファイアウォールに関連付けられているすべてのパブリック IP アドレスを許可する必要があります。 この構成を簡略化するには、パブリック IP アドレス プレフィックスを使用することを検討してください。</p></blockquote><p>この記載は通信ごとにランダムにパブリック IP が使用される、つまり確率的に関連付けられている全てのパブリック IP が均等に使用されるかのように読み取れますが、<strong>実際のパブリック IP の使われ方は、基本的にプライマリのパブリック IP から使用されることが多く、そのパブリック IP のSNAT ポート数を使い切るまで他のパブリック IP は使用されません。</strong></p><p>通信先への送信元 IP アドレスを分散させたい場合には NAT ゲートウェイが必要となります。</p><h2 id="NAT-ゲートウェイ-による-SNAT-について"><a href="#NAT-ゲートウェイ-による-SNAT-について" class="headerlink" title="NAT ゲートウェイ による SNAT について"></a>NAT ゲートウェイ による SNAT について</h2><p>Azure Firewall Subnet に NAT ゲートウェイを関連付けることにより、Azure Firewall のパブリック IP ではなく、NAT ゲートウェイで SNAT を行うことができるようになります。NAT ゲートウェイによる SNAT では関連付けられているパブリック IP がランダムかつほぼ均等に使用されます。<br>注意点として、NAT ゲートウェイはゾーン冗長をサポートしていないため、利用する場合は Azure Firewall をゾーン冗長しないようにデプロイする必要があります。<br>Azure Firewall と NAT ゲートウェイを組み合わせて使用する方法については以下のドキュメントをご参照ください。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/firewall/integrate-with-nat-gateway">Azure Virtual Network NAT を使用した SNAT ポートのスケーリング | Microsoft Learn</a></p><p><a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/nat-gateway/tutorial-hub-spoke-nat-firewall">チュートリアル： ハブ アンド スポーク ネットワークで NAT ゲートウェイと Azure Firewall を統合する - Azure Virtual Network NAT | Microsoft Learn</a></p><h2 id="Azure-Firewall-と-NAT-Gateway-の比較表"><a href="#Azure-Firewall-と-NAT-Gateway-の比較表" class="headerlink" title="Azure Firewall と NAT Gateway の比較表"></a>Azure Firewall と NAT Gateway の比較表</h2><p>以下の表は Azure Firewall のパブリック IP による SNAT と NAT Gateway の機能比較表です。</p><table><thead><tr><th align="left">機能</th><th align="center">Firewall のパブリック IP</th><th align="center">NAT ゲートウェイ</th></tr></thead><tbody><tr><td align="left">SNAT ポート数（パブリック IP 1 つにつき）</td><td align="center">2,496 * FW 内部インスタンス数 ※1</td><td align="center">64,512</td></tr><tr><td align="left">関連付けられる パブリック IP の数</td><td align="center">250</td><td align="center">16</td></tr><tr><td align="left">パブリック IP が使用される順番</td><td align="center">基本的にプライマリから使用され、ポートが枯渇すると次が使用される</td><td align="center">ランダムかつほぼ均等に使用される</td></tr><tr><td align="left">ゾーン冗長のサポート</td><td align="center">○</td><td align="center">×</td></tr><tr><td align="left">価格</td><td align="center">FW と FW のパブリック IP の価格</td><td align="center">FW と FW のパブリック IP, NAT ゲートウェイと NAT ゲートウェイ のパブリック IP の価格</td></tr></tbody></table><p>※1 Azure Firewall の内部インスタンス数は最低 2 となり、負荷に応じてスケールアウトします。</p><p>以上、ご参考になれば幸いです。</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの薄井です。&lt;br&gt;今回は Azure Firewall に関連付けたパブリック IP の SNAT 時の使われ方について紹介します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Network" scheme="https://jpaztech.github.io/blog/tags/Network/"/>
    
    <category term="Public IP Address" scheme="https://jpaztech.github.io/blog/tags/Public-IP-Address/"/>
    
    <category term="Azure Firewall" scheme="https://jpaztech.github.io/blog/tags/Azure-Firewall/"/>
    
    <category term="NAT Gateway" scheme="https://jpaztech.github.io/blog/tags/NAT-Gateway/"/>
    
  </entry>
  
  <entry>
    <title>Azure VM の CPU コア数 / CPU の種類 / ターボブーストについての解説</title>
    <link href="https://jpaztech.github.io/blog/vm/azure-vm-cpu-htt-turbo/"/>
    <id>https://jpaztech.github.io/blog/vm/azure-vm-cpu-htt-turbo/</id>
    <published>2023-04-11T08:30:00.000Z</published>
    <updated>2023-05-26T05:14:04.635Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの富田です。<br>今回はお問い合わせいただくことの多い Azure VM の CPU に関する以下の点を解説させていただきます。  </p><ul><li>CPU の vCPU 数 / 物理コア数 / 論理スレッド数について</li><li>制約付き vCPU 対応の VM サイズについて</li><li>CPU の種類について</li><li>ターボブースト機能について</li></ul><p>まず Azure VM ではそのスペックについて VM サイズとして、<br>搭載 CPU / vCPU 数 / メモリの量 / ディスクやネットワークの帯域などの組み合わせより選んでいただくこととなります。<br>各 VM サイズの情報については、以下の資料をご参照いただけますと幸いでございます。  </p><blockquote><p>■ご参考：Azure の仮想マシンのサイズ<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/sizes">https://learn.microsoft.com/ja-jp/azure/virtual-machines/sizes</a></p></blockquote><hr><h2 id="CPU-の-vCPU-数-物理コア数-論理スレッド数について"><a href="#CPU-の-vCPU-数-物理コア数-論理スレッド数について" class="headerlink" title="CPU の vCPU 数 / 物理コア数 / 論理スレッド数について"></a>CPU の vCPU 数 / 物理コア数 / 論理スレッド数について</h2><p>ソフトウェア ライセンスの観点等により、Azure VM における vCPU 数 / 物理コア数 / 論理スレッド数についてお問い合わせをいただくことがございます。  </p><p>Azure VM では VM サイズとして vCPU 数をお客様に選んでいただくことになります。<br>では、8 vCPU の VM サイズを選んだ として、「4 物理コア / 8 論理スレッド」なのか、「8 物理コア / 8 論理スレッド」なのかという点が気になりますね。  </p><p>1 つの物理コアを 2 論理スレッドとして扱う技術として、  </p><ul><li>Intel ハイパースレッディング テクノロジ</li><li>AMD 同時実行マルチスレッド技術</li></ul><p>といった技術がございます。<br> ※ 以下「ハイパースレッド / マルチスレッド化」と記載させていたせていただきます。  </p><p>そのため、8 vCPU の VM サイズ については、  </p><ul><li>ハイパースレッド / マルチスレッド化されている VM サイズの場合は「4 物理コア / 8 論理スレッド」</li><li>ハイパースレッド / マルチスレッド化されて<strong>いない</strong> VM サイズの場合は「8 物理コア / 8 論理スレッド」</li></ul><p>となります。  </p><p>どの VM サイズがハイパースレッド / マルチスレッド化されているのかといった点は、<br>以下の Azure コンピューティング ユニット (ACU) のドキュメントより確認可能です。<br>「vCPU: コア」の表記が「2:1***」「2:1****」になっているものは、<br>ハイパースレッド / マルチスレッド化されており、1 つの物理コアを 2 論理スレッドとして扱われております。  </p><blockquote><p>■ご参考：Azure コンピューティング ユニット (ACU)<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/acu">https://learn.microsoft.com/ja-jp/azure/virtual-machines/acu</a></p></blockquote><blockquote><p>ーーーーーー抜粋ーーーーーー<br>*** ハイパースレッド化されており、入れ子になった仮想化を実行できます。<br>****AMD 同時実行マルチスレッド技術<br>ーーーーーーーーーーーーーー  </p></blockquote><p>なお、ACU に表記のない VM サイズにつきましては、各 VM サイズにおけるドキュメント等にハイパースレッド / マルチスレッド化されているかという旨が記載されておりますので、それらをご確認いただけますと幸いです。  </p><blockquote><p>■ ハイパースレッド化が有効である場合の表記の例（Dv5 および Dsv5 シリーズ）<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/dv5-dsv5-series">https://learn.microsoft.com/ja-jp/azure/virtual-machines/dv5-dsv5-series</a>  </p></blockquote><blockquote><p>ーーーーーー抜粋ーーーーーー<br>Dv5 および Dsv5 シリーズの仮想マシンは、<strong>ハイパースレッド構成の</strong>第 3 世代 Intel® Xeon® Platinum 8370C (Ice Lake) プロセッサ上で実行されます。<br>ーーーーーーーーーーーーーー</p></blockquote><blockquote><p>■ マルチスレッド化が有効である場合の表記の例（Dasv5 および Dadsv5 シリーズ）<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/dv5-dsv5-series">https://learn.microsoft.com/ja-jp/azure/virtual-machines/dv5-dsv5-series</a>  </p></blockquote><blockquote><p>ーーーーーー抜粋ーーーーーー<br>Dasv5 シリーズおよび Dadsv5 シリーズは、AMD の第 3 世代 EPYCTM 7763v プロセッサを、最大 256 MB の L3 キャッシュを備えた<strong>マルチスレッド構成で</strong>利用し、汎用ワークロードを実行するための顧客オプションを増やします。<br>ーーーーーーーーーーーーーー</p></blockquote><p>また、恐縮ながら物理ホスト サーバー 1 台に搭載された合計物理コア数やソケット数はお客様に公開が叶いません点ご理解賜りますと幸いでございます。  </p><div class="alert is-info"><p class="alert-title">Note</p><p>ソフトウェアについてはパブリック クラウド環境の場合はオンプレミスの物理サーバーと違ったライセンス ルールがある場合がございます。</p><p>「ライセンス上どのように CPU 数などをカウントするか？」「パブリッククラウドとオンプレミス環境でのライセンスの違いはあるか？」など、各ソフトウェア ライセンスの観点については、そのソフトウェア ライセンスを取り扱っている会社様にご確認をお願いいたします。  </p></div><hr><h2 id="制約付き-vCPU-対応の-VM-サイズについて"><a href="#制約付き-vCPU-対応の-VM-サイズについて" class="headerlink" title="制約付き vCPU 対応の VM サイズについて"></a>制約付き vCPU 対応の VM サイズについて</h2><p>ソフトウェアによっては vCPU の数によって、ライセンス料金が決定されるものがございます。<br>例えばその際に、  </p><blockquote><p>「メモリは 256 GB 欲しいので Standard_E32d_v5 サイズ（32 vCPU / 256 GB）が良さそうだけど、32 vCPU もあるとライセンス料金が高くなってしまう。」  </p></blockquote><p>ということがあるかと存じます。  </p><p>このようなご要望にお応えするため、Standard_E32d_v5 サイズ（32 vCPU / 256 GB）から、vCPU の数のみを減らした、<br>Standard_E32-8ds_v5 サイズ（8 vCPU / 256 GB）というサイズのご用意がございます。<br>このように vCPU 数のみを元の VM サイズから減らしているものを <strong>「制約付き vCPU 対応の VM サイズ」</strong> と定義しております。  </p><p>制約付き vCPU 対応の VM サイズには以下のような特徴がございます。  </p><ul><li>元の VM サイズから 1/2 または 1/4 に vCPU 数を減らしています。  </li><li>vCPU 数以外のスペック（メモリ容量・ディスクの仕様・NIC 数・ネットワーク帯域など）は元の VM サイズと同じ仕様です。  </li><li>全ての VM サイズに対し「制約付き vCPU 対応の VM サイズ」がご用意されているわけではございません。  </li><li>命名規則としては vCPU 数の部分が「元のvCPU数-実際のvCPU数」といった表記になっております。  </li></ul><p>制約付き vCPU 対応の VM サイズの一覧・仕様・価格などに関しては以下のドキュメントをご参照ください。  </p><blockquote><p>■ご参考：制約付き vCPU 対応の VM サイズ<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/constrained-vcpu">https://learn.microsoft.com/ja-jp/azure/virtual-machines/constrained-vcpu</a></p></blockquote><blockquote><p>■ご参考：Windows Virtual Machines の料金<br><a href="https://azure.microsoft.com/ja-jp/pricing/details/virtual-machines/windows/">https://azure.microsoft.com/ja-jp/pricing/details/virtual-machines/windows/</a></p></blockquote><hr><h2 id="CPU-の種類について"><a href="#CPU-の種類について" class="headerlink" title="CPU の種類について"></a>CPU の種類について</h2><p>同じ VM サイズでも物理ホスト サーバーに搭載された CPU の種類が異なるため、VM の実行される CPU の種類が変わるといったことがございます。<br>例えば、以下のように Dv4 および Dsv4 シリーズは、ブログ執筆の 2023 年 4 月時点では、以下 2 種類の CPU でご提供をさせていただいております。  </p><blockquote><p>■ご参考：Dv4 および Dsv4 シリーズ<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/dv4-dsv4-series">https://learn.microsoft.com/ja-jp/azure/virtual-machines/dv4-dsv4-series</a></p></blockquote><blockquote><p>ーーーーーー抜粋ーーーーーー<br>Dv4 および Dsv4 シリーズは、ハイパースレッド構成の第 3 世代 Intel® Xeon® Platinum 8370C (Ice Lake) プロセッサまたは Intel® Xeon® Platinum 8272CL (Cascade Lake) プロセッサ上で実行されます。<br>ーーーーーーーーーーーーーー</p></blockquote><p>そのため、ご利用者様から見ると、  </p><ul><li>VM を割り当て解除 / 起動したら CPU の種類が変わった。</li><li>同じ VM サイズの VM を何台が使っているが、それぞれ別の種類の CPU で実行されている。</li></ul><p> ということが発生します。  </p><p>また、「特定の CPU の種類を選んで使いたい。」といったご要望も頂くことがございます。<br>恐縮ながら、後述の Azure Dedicated Host を利用する場合の除き、特定の CPU の種類を選んでご使用いただくことは叶いません.。 </p><p>なお、異なる CPU の種類で実行された場合も大きな性能差が出ないよう、目安として以下の ACU の範囲内での性能差となるように設計されております。  </p><blockquote><p>■ご参考：Azure コンピューティング ユニット (ACU)<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/acu">https://learn.microsoft.com/ja-jp/azure/virtual-machines/acu</a></p></blockquote><div class="alert is-info"><p class="alert-title">Note</p><p>VM を割り当て解除および再デプロイしない場合は、原則 CPU の種類が変更されませんが、</p><p>予期せぬ物理ホストサーバーの不具合等で、別の CPU の種類の物理ホストサーバーに VM が移動される場合がございます。  </p></div><hr><h2 id="Azure-Dedicated-Host-で-CPU-の種類を選ぶ"><a href="#Azure-Dedicated-Host-で-CPU-の種類を選ぶ" class="headerlink" title="Azure Dedicated Host で CPU の種類を選ぶ"></a>Azure Dedicated Host で CPU の種類を選ぶ</h2><p>Azure Dedicated Host をご利用いただく場合に限り、CPU の種類を選ぶことが可能となります。<br>Azure Dedicated Host は物理ホストサーバー 1 台丸ごとをお客様に占有いただくサービスとなります。<br>物理ホストサーバーを選ぶ際に SKU として、VM ファミリと特定のハードウェア仕様の組み合わせを選択することとなり、この際にハードウェアに搭載される CPU の種類を選択することが可能です。  </p><p>例えば、Dsv4 シリーズを搭載できる Azure Dedicated Host SKU として、ブログ執筆の 2023 年 4 月時点では、以下の 2 種類があることが確認できます。  　</p><ul><li>Dsv4_Type1：Intel® Xeon® Platinum 8272CL (Cascade Lake)</li><li>Dsv4_Type2：Intel® Xeon® Platinum 8370C (Ice Lake) </li></ul><p>この占有されたホストサーバー上で稼働させれば、CPU が変更されることはないものとなります。<br>しかしながら、Azure Dedicated Host は物理ホストサーバー 1 台丸ごとをお客様に占有いただくため、通常の VM より高い利用料金が設定されております。<br>Azure Dedicated Host の概要や価格等については、以下の記事をご参照ください。  </p><blockquote><p>■ご参考：Azure 専用ホスト<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/dedicated-hosts">https://learn.microsoft.com/ja-jp/azure/virtual-machines/dedicated-hosts</a></p></blockquote><blockquote><p>■ご参考：Azure Dedicated Host の価格<br><a href="https://azure.microsoft.com/ja-jp/pricing/details/virtual-machines/dedicated-host/">https://azure.microsoft.com/ja-jp/pricing/details/virtual-machines/dedicated-host/</a></p></blockquote><blockquote><p>■ご参考：汎用 Azure Dedicated Host SKU<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/dedicated-host-general-purpose-skus">https://learn.microsoft.com/ja-jp/azure/virtual-machines/dedicated-host-general-purpose-skus</a></p></blockquote><hr><h2 id="ターボブースト機能について"><a href="#ターボブースト機能について" class="headerlink" title="ターボブースト機能について"></a>ターボブースト機能について</h2><p>一時的に CPU クロックを向上させる技術として、  </p><ul><li>Intel® Turbo テクノロジ</li><li>AMD® Boost テクノロジ</li></ul><p>といった技術がございます。<br> ※ 以下「ターボブースト機能」と記載させていたせていただきます。  </p><p>多くの VM サイズではこのターボブースト機能が有効となっております。<br>しかしながら、ターボブースト機能によって実際に CPU クロックが向上している際も、お客様のゲスト OS からは CPU クロックは固定で表示されます。<br>これは、物理ホストサーバー側にて制御が行われ、ゲスト OS は HW レジスタを直接参照できないためとなります。  </p><p>そのため恐れ入りますが、ターボブースト機能によってどの程度クロックが向上しているかについては、恐縮ながら確認が叶いません点ご理解賜りますと幸いです。<br>なお、ターボブースト機能は、あくまで余裕がある際にベースクロックよりパフォーマンスを向上させるものでございますので、ターボブースト機能が動作していない場合に性能が低下するものではなく、通常よりも性能が向上するといった機能でございます。  </p><blockquote><p>■ご参考：Azure コンピューティング ユニット (ACU)<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/acu">https://learn.microsoft.com/ja-jp/azure/virtual-machines/acu</a></p></blockquote><blockquote><p>ーーーーーー抜粋ーーーーーー<br>*ACU は、Intel® Turbo テクノロジを使用して CPU 周波数を上げ、パフォーマンスを向上させます。 パフォーマンス向上の量は、VM のサイズ、ワークロードのほか、同じホストで実行されている他のワークロードによって変動する場合があります。  </p><p>**ACU は、AMD® Boost テクノロジを使用して CPU 周波数を上げ、パフォーマンスを向上させます。 パフォーマンス向上の量は、VM のサイズ、ワークロードのほか、同じホストで実行されている他のワークロードによって変動する場合があります。<br>ーーーーーーーーーーーーーー  </p></blockquote><hr><p>以上の通り今回は Azure VM の CPU についてよくあるご質問の内容を解説させていただきました。<br>上記内容が皆様のお役に立てますと幸いでございます。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの富田です。&lt;br&gt;今回はお問い合わせいただくことの多い Azure VM の CPU に関する以下の点を解説させていただきます。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU の vCPU 数 / 物理コア数 / 論理スレッド数</summary>
      
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="Linux" scheme="https://jpaztech.github.io/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Azure から OS にコマンドを発行する実行コマンド (RunCommand) 拡張機能について解説</title>
    <link href="https://jpaztech.github.io/blog/vm/runcommand/"/>
    <id>https://jpaztech.github.io/blog/vm/runcommand/</id>
    <published>2023-03-30T04:00:00.000Z</published>
    <updated>2023-05-26T05:14:04.839Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポートチームの井上です。 </p><p>本記事では、Azure VM の拡張機能の一つである実行コマンド (RunCommand) について、<br>利用方法やアクション実行コマンドとマネージド実行コマンドの違い等を解説させていただきます。</p><span id="more"></span> <hr><h2 id="実行コマンドとは"><a href="#実行コマンドとは" class="headerlink" title="実行コマンドとは"></a>実行コマンドとは</h2><p>実行コマンドは、Azure VM の拡張機能の一つで、仮想マシン エージェントを使用して、<br>Windows または Linux の Azure VM 内でコマンドやスクリプトをリモートで実行することができる機能です。<br>特定のコマンドだけでなく、Windows の場合は PowerShell スクリプト、Linux の場合はシェル スクリプトで、<br>任意のカスタム スクリプトを指定して実行することが可能です。</p><p>例えば、接続不調となった VM に対して、疎通の状態等を確認するコマンドをリモートで実行するといったことや、<br>複数の VM に対してメンテナンス用のスクリプトを実行するといった用途にご活用いただけます。</p><blockquote><p><em><strong>実行コマンドを使用してお使いの VM でスクリプトを実行する</strong></em><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/run-command-overview">https://learn.microsoft.com/ja-jp/azure/virtual-machines/run-command-overview</a></p></blockquote><hr><h2 id="アクション実行コマンドとマネージド実行コマンド"><a href="#アクション実行コマンドとマネージド実行コマンド" class="headerlink" title="アクション実行コマンドとマネージド実行コマンド"></a>アクション実行コマンドとマネージド実行コマンド</h2><p>実行コマンドには、現在、アクション実行コマンドとマネージド実行コマンドの 2 種類があります。<br>マネージド実行コマンドは、2023 年 2 月に General Availability (GA) となっており、<br>アクション実行コマンドと比較し、以下の観点で機能が強化されています。<br>今後、実行コマンドの利用を予定されている場合は、まずはマネージド実行コマンドをご利用いただくことをご検討ください。</p><ul><li>ARM デプロイ テンプレートを介して更新された実行コマンドをサポート</li><li>複数のスクリプトの並列実行</li><li>スクリプトの順次実行</li><li>ユーザーが指定したスクリプトのタイムアウト</li><li>実行時間が長い (時間または日単位) のスクリプトをサポート</li><li>安全な方法でシークレット (パラメーター、パスワード) を渡す</li></ul><blockquote><p><em><strong>General Availability: Managed Run Command – Execute PowerShell or shell scripts on Virtual Machines and Scale Sets</strong></em><br><a href="https://azure.microsoft.com/en-us/updates/general-availability-run-command-execute-powershell-or-shell-scripts-on-virtual-machines-and-scale-sets/">https://azure.microsoft.com/en-us/updates/general-availability-run-command-execute-powershell-or-shell-scripts-on-virtual-machines-and-scale-sets/</a></p></blockquote><blockquote><p><em><strong>実行コマンドを使用してお使いの VM でスクリプトを実行する</strong></em><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/run-command-overview#compare-feature-support">https://learn.microsoft.com/ja-jp/azure/virtual-machines/run-command-overview#compare-feature-support</a></p></blockquote><div class="alert is-info"><p class="alert-title">Note</p><p>マネージド実行コマンドは、2023 年 3 月現在、Azure CLI、Azure PowerShell、REST API で使用できます。</p></div><p>基本的な利用方法につきましては、こちらの公開ドキュメントも併せてご確認ください。</p><blockquote><p><em><strong>実行コマンド アクションを使用して Linux VM でスクリプトを実行する</strong></em><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/run-command">https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/run-command</a></p><p><em><strong>アクション実行コマンドを使用して、Windows VM でスクリプトを実行する</strong></em><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command">https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command</a></p><p><em><strong>マネージド実行コマンドを使用して Linux VM でスクリプトを実行する</strong></em><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/run-command-managed">https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/run-command-managed</a></p><p><em><strong>マネージド実行コマンドを使用して Windows VM でスクリプトを実行する</strong></em><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed">https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed</a></p></blockquote><hr><h2 id="実行コマンドをデプロイする"><a href="#実行コマンドをデプロイする" class="headerlink" title="実行コマンドをデプロイする"></a>実行コマンドをデプロイする</h2><h3 id="仮想マシンで実行する"><a href="#仮想マシンで実行する" class="headerlink" title="仮想マシンで実行する"></a>仮想マシンで実行する</h3><p>マネージド実行コマンドとアクション実行コマンドでは、Azure PowerShell/CLI のコマンドに違いがあり、<br>それぞれのコマンドをご利用いただくことで使い分けることができます。<br>仮想マシンで実行コマンドを利用する際のコマンドについては、こちらの比較表をご参照ください。</p><h4 id="Azure-PowerShell"><a href="#Azure-PowerShell" class="headerlink" title="Azure PowerShell"></a>Azure PowerShell</h4><table><thead><tr><th align="left">操作</th><th align="left">アクション実行コマンド</th><th align="left">マネージド実行コマンド</th></tr></thead><tbody><tr><td align="left">実行<br>作成・更新 ※1</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command#powershell"><strong>Invoke</strong>-AzVMRunCommand</a> ※2</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#execute-a-script-with-the-vm-1"><strong>Set</strong>-AzVMRunCommand</a></td></tr><tr><td align="left">削除</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command#action-run-command-removal"><strong>Invoke</strong>-AzVMRunCommand</a> ※2</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#delete-runcommand-resource-from-the-vm-1"><strong>Remove</strong>-AzVMRunCommand</a></td></tr><tr><td align="left">一覧表示 ※1</td><td align="left">-</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#list-all-deployed-runcommand-resources-on-a-vm-1"><strong>Get</strong>-AzVMRunCommand</a> ※2</td></tr><tr><td align="left">実行状態と結果の取得 ※1</td><td align="left">-</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#get-execution-status-and-results-1"><strong>Get</strong>-AzVMRunCommand</a> ※2</td></tr></tbody></table><h4 id="Azure-CLI"><a href="#Azure-CLI" class="headerlink" title="Azure CLI"></a>Azure CLI</h4><table><thead><tr><th align="left">操作</th><th align="left">アクション実行コマンド</th><th align="left">マネージド実行コマンド</th></tr></thead><tbody><tr><td align="left">実行<br>作成・更新 ※1</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command#azure-cli">az vm run-command <strong>invoke</strong></a> ※2</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#execute-a-script-with-the-vm">az vm run-command <strong>create</strong></a><br><a href="https://learn.microsoft.com/ja-jp/cli/azure/vm/run-command?view=azure-cli-latest#az-vm-run-command-update">az vm run-command <strong>update</strong></a></td></tr><tr><td align="left">削除</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command#action-run-command-removal">az vm run-command <strong>invoke</strong></a> ※2</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#delete-runcommand-resource-from-the-vm">az vm run-command <strong>delete</strong></a></td></tr><tr><td align="left">一覧表示 ※1</td><td align="left">-</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#list-all-deployed-runcommand-resources-on-a-vm">az vm run-command <strong>list</strong></a></td></tr><tr><td align="left">実行状態と結果の取得 ※1</td><td align="left">-</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#get-execution-status-and-results">az vm run-command <strong>show</strong></a></td></tr></tbody></table><p>※1 : マネージド実行コマンドのみで実行可能な操作です。<br>※2 : パラメータで操作を使い分けます。詳細につきましては、リンク先の公開ドキュメントをご確認ください。</p><p>アクション実行コマンドで、仮想マシン上でカスタム スクリプトを実行する際のコマンド例は、以下のとおりとなります。</p><figure class="highlight powershell"><figcaption><span>Windows 仮想マシンの場合</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-AzVMRunCommand</span> `</span><br><span class="line">  <span class="literal">-ResourceGroupName</span> &lt;リソース グループ名&gt; `</span><br><span class="line">  <span class="literal">-Name</span> &lt;仮想マシン リソース名&gt; `</span><br><span class="line">  <span class="literal">-CommandId</span> <span class="string">&#x27;RunPowerShellScript&#x27;</span> `</span><br><span class="line">  <span class="literal">-ScriptPath</span> <span class="string">&#x27;&lt;実行するスクリプトのパス&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>また、アクション実行コマンドは、Azure Portal 上で実行することができます。<br>VM の <strong>[実行コマンド]</strong> ブレードから、カスタム スクリプトや組み込みのスクリプトを実行できます。</p><p><img src="/blog/vm/runcommand/001.png"></p><p>マネージド実行コマンドで、仮想マシン上でカスタム スクリプトを実行する際のコマンド例は、以下のとおりとなります。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-AzVMRunCommand</span> `</span><br><span class="line">  <span class="literal">-ResourceGroupName</span> &lt;リソース グループ名&gt; `</span><br><span class="line">  <span class="literal">-VMName</span> &lt;仮想マシン リソース名&gt; `</span><br><span class="line">  <span class="literal">-Location</span> &lt;リージョン名&gt; `</span><br><span class="line">  <span class="literal">-RunCommandName</span> &lt;任意の実行コマンド名&gt; `</span><br><span class="line">  <span class="literal">-ScriptLocalPath</span> <span class="string">&#x27;&lt;実行するスクリプトのパス&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>なお、実行コマンドをご利用いただく際は、仮想マシンが実行中の状態であることをご確認ください。</p><p>アクション実行コマンドは、一度実行すると、最終的なスクリプトの実行結果が出力されるのみでした。<br>マネージド実行コマンドでは、初回の実行時に実行コマンドが仮想マシンに登録され、<br>実行の進行状況 (最新の出力、開始/終了時刻、終了コード、および実行の終了状態など) を確認することができます。<br>また、登録された実行コマンドは更新して再実行することができ、不要になり次第、削除することができます。</p><p><img src="/blog/vm/runcommand/002.png"></p><h2 id="仮想マシン-スケール-セット-VMSS-で実行する"><a href="#仮想マシン-スケール-セット-VMSS-で実行する" class="headerlink" title="仮想マシン スケール セット (VMSS) で実行する"></a>仮想マシン スケール セット (VMSS) で実行する</h2><p>実行コマンドは、仮想マシン スケール セット (VMSS) で利用することができます。<br>仮想マシンで実行する場合と同様に、アクション実行コマンドとマネージド実行コマンドで、<br>Azure PowerShell/CLI のコマンドに違いがあります。こちらの比較表をご参照ください。</p><h4 id="Azure-PowerShell-1"><a href="#Azure-PowerShell-1" class="headerlink" title="Azure PowerShell"></a>Azure PowerShell</h4><table><thead><tr><th align="left">操作</th><th align="left">アクション実行コマンド</th><th align="left">マネージド実行コマンド</th></tr></thead><tbody><tr><td align="left">実行<br>作成・更新・追加 ※1</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/powershell/module/az.compute/invoke-azvmssvmruncommand"><strong>Invoke</strong>-AzVmssVMRunCommand</a> ※2</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/powershell/module/az.compute/set-azvmssvmruncommand"><strong>Set</strong>-AzVmssVMRunCommand</a><br><a href="https://learn.microsoft.com/ja-jp/powershell/module/az.compute/add-azvmssruncommand"><strong>Add</strong>-AzVmssRunCommand</a></td></tr><tr><td align="left">削除</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/powershell/module/az.compute/invoke-azvmssvmruncommand"><strong>Invoke</strong>-AzVmssVMRunCommand</a> ※2</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/powershell/module/az.compute/remove-azvmssvmruncommand"><strong>Remove</strong>-AzVmssVMRunCommand</a><br><a href="https://learn.microsoft.com/ja-jp/powershell/module/az.compute/remove-azvmssruncommand"><strong>Remove</strong>-AzVmssRunCommand</a></td></tr><tr><td align="left">一覧表示 ※1</td><td align="left">-</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/powershell/module/az.compute/get-azvmssvmruncommand"><strong>Get</strong>-AzVmssVMRunCommand</a> ※2</td></tr><tr><td align="left">実行状態と結果の取得 ※1</td><td align="left">-</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/powershell/module/az.compute/get-azvmssvmruncommand"><strong>Get</strong>-AzVmssVMRunCommand</a> ※2</td></tr></tbody></table><h4 id="Azure-CLI-1"><a href="#Azure-CLI-1" class="headerlink" title="Azure CLI"></a>Azure CLI</h4><table><thead><tr><th align="left">操作</th><th align="left">アクション実行コマンド</th><th align="left">マネージド実行コマンド</th></tr></thead><tbody><tr><td align="left">実行<br>作成・更新 ※1</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/cli/azure/vmss/run-command?view=azure-cli-latest#az-vmss-run-command-invoke">az vmss run-command <strong>invoke</strong></a> ※2</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/cli/azure/vmss/run-command?view=azure-cli-latest#az-vmss-run-command-create">az vmss run-command <strong>create</strong></a><br><a href="https://learn.microsoft.com/ja-jp/cli/azure/vmss/run-command?view=azure-cli-latest#az-vmss-run-command-update">az vmss run-command <strong>update</strong></a></td></tr><tr><td align="left">削除</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/cli/azure/vmss/run-command?view=azure-cli-latest#az-vmss-run-command-invoke">az vmss run-command <strong>invoke</strong></a> ※2</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/cli/azure/vmss/run-command?view=azure-cli-latest#az-vmss-run-command-delete">az vmss run-command <strong>delete</strong></a></td></tr><tr><td align="left">一覧表示 ※1</td><td align="left">-</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/cli/azure/vmss/run-command?view=azure-cli-latest#az-vmss-run-command-list">az vmss run-command <strong>list</strong></a></td></tr><tr><td align="left">実行状態と結果の取得 ※1</td><td align="left">-</td><td align="left"><a href="https://learn.microsoft.com/ja-jp/cli/azure/vmss/run-command?view=azure-cli-latest#az-vmss-run-command-show">az vmss run-command <strong>show</strong></a></td></tr></tbody></table><p>※1 : マネージド実行コマンドのみで実行可能な操作です。<br>※2 : パラメータで操作を使い分けます。詳細につきましては、リンク先の公開ドキュメントをご確認ください。</p><p>アクション実行コマンドで、VMSS 内の仮想マシン (インスタンス ID が <code>0</code> ) 上で、<br>カスタム スクリプトを実行する際のコマンド例は、以下のとおりとなります。</p><figure class="highlight powershell"><figcaption><span>Windows 仮想マシンの場合</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-AzVmssVMRunCommand</span> `</span><br><span class="line">  <span class="literal">-ResourceGroupName</span> &lt;リソース グループ名&gt; `</span><br><span class="line">  <span class="literal">-VMScaleSetName</span> &lt;VMSS リソース名&gt; `</span><br><span class="line">  <span class="literal">-InstanceId</span> <span class="number">0</span> `</span><br><span class="line">  <span class="literal">-CommandId</span> <span class="string">&#x27;RunPowerShellScript&#x27;</span> `</span><br><span class="line">  <span class="literal">-ScriptPath</span> <span class="string">&#x27;&lt;実行するスクリプトのパス&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>マネージド実行コマンドで、VMSS 内の仮想マシン (インスタンス ID が <code>0</code> ) 上で、<br>カスタム スクリプトを実行する際のコマンド例は、以下のとおりとなります。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-AzVmssVMRunCommand</span> `</span><br><span class="line">  <span class="literal">-ResourceGroupName</span> &lt;リソース グループ名&gt; `</span><br><span class="line">  <span class="literal">-VMScaleSetName</span> &lt;VMSS リソース名&gt; `</span><br><span class="line">  <span class="literal">-Location</span> &lt;リージョン名&gt; `</span><br><span class="line">  <span class="literal">-InstanceId</span> <span class="number">0</span> `</span><br><span class="line">  <span class="literal">-RunCommandName</span> &lt;任意の実行コマンド名&gt; `</span><br><span class="line">  <span class="literal">-ScriptLocalPath</span> <span class="string">&#x27;&lt;実行するスクリプトのパス&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>また、マネージド実行コマンドでは、VMSS 内の全ての仮想マシンに実行コマンドを追加する<br><code>Add-AzVmssRunCommand</code> が利用できます。<br><code>Remove-AzVmssRunCommand</code> で実行コマンドを削除することも可能です。</p><p>なお、実行コマンドをご利用いただく際は、VMSS 内の仮想マシンが実行中の状態であることをご確認ください。</p><div class="alert is-info"><p class="alert-title">Note</p><p>仮想マシン スケール セット (VMSS) のオーケストレーション モードが Uniform の場合に、VMSS のコマンド (<code>Set-AzVmssVMRunCommand</code> 等) が利用できます。</p><p>Flexible の場合は、VMSS 内の各仮想マシンに対して、仮想マシンのコマンド (<code>Set-AzVMRunCommand</code> 等) を実行する必要があります。</p></div><hr><h2 id="実行するスクリプトを指定する"><a href="#実行するスクリプトを指定する" class="headerlink" title="実行するスクリプトを指定する"></a>実行するスクリプトを指定する</h2><p>実行コマンドでは、実行するコマンドをパラメータで直接指定することができます。<br>また、カスタム スクリプトを指定する場合は、<br>アクション実行コマンドとマネージド実行コマンドで指定可能なソースに違いがあり、<br>マネージド実行コマンドでは、BLOB ストレージの SAS URL が指定可能となっています。</p><p>アクション実行コマンドの場合は、<code>Invoke-AzVMRunCommand</code> の以下のいずれかのパラメータで指定します。</p><ul><li><code>-ScriptString</code> : 実行するコマンド<br>例 : ping 10.0.0.1</li><li><code>-ScriptPath</code> : <code>Invoke-AzVMRunCommand</code> を実行する環境のローカル ファイル パス<br>例 : C:\work\test.ps1</li></ul><p>マネージド実行コマンドの場合は、<code>Set-AzVMRunCommand / Set-AzVmssVMRunCommand</code> の以下のいずれかのパラメータで指定します。</p><ul><li><code>-SourceScript</code> : 実行するコマンド<br>例 : ping 10.0.0.1</li><li><code>-ScriptLocalPath</code> : <code>Set-AzVMRunCommand / Set-AzVmssVMRunCommand</code> を実行する環境のローカル ファイル パス<br>例 : C:\work\test.ps1</li><li><code>-SourceScriptUri</code> : スクリプトを配置した BLOB ストレージ の SAS URL<br>例 : https://{ストレージ アカウント名}.blob.core.windows.net/{BLOB コンテナ名}/test.ps1?{SAS}</li></ul><hr><h2 id="スクリプトの出力内容を確認する"><a href="#スクリプトの出力内容を確認する" class="headerlink" title="スクリプトの出力内容を確認する"></a>スクリプトの出力内容を確認する</h2><p>Azure テクニカル サポートチームでは、実行コマンドの拡張機能を有効または無効とされた際のエラーや<br>拡張機能のアップデート時のエラー等につきまして、調査をご支援させていただくことが可能です。<br>その一方で、お客様にて作成されたスクリプトにつきましては、<br>お客様がご自身でトラブルシューティングを実施していただくことが必要となります。</p><p>トラブルシューティングの際に、コマンドの実行結果やエラー等を確認したい場合は、<br>アクション実行コマンドでは実行時の出力結果をご確認いただきます。<br>マネージド実行コマンドでは、状態を取得した上で、InstanceView からご確認いただけます。<br>ただし、これらの出力結果は、実際の出力内容の最後の 4 KB のみとなります。</p><p>マネージド実行コマンドで出力結果を確認する際のコマンド例は以下のとおりとなります。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">Get-AzVMRunCommand</span> <span class="literal">-ResourceGroupName</span> &lt;リソース グループ名&gt; <span class="literal">-VMName</span> &lt;仮想マシン リソース名&gt; <span class="literal">-RunCommandName</span> &lt;実行コマンド名&gt; <span class="literal">-Expand</span> InstanceView).InstanceView</span><br></pre></td></tr></table></figure><p>InstanceView の出力例はこちらになります。<br><code>ExecutionState</code> にスクリプトの実行が成功したかどうかが表示されます。<br><code>Output</code> でスクリプトが正常に終了した場合の出力結果、<br><code>Error</code> でスクリプトの途中でエラーとなった場合の出力結果が確認できます。<br><code>StartTime/EndTime</code> でスクリプトの実行開始時刻および終了時刻が確認できます。</p><p><img src="/blog/vm/runcommand/003.png" alt="デスクトップにファイルを生成するスクリプトを実行した場合の出力例"></p><blockquote><p><em><strong>実行コマンドの作成または更新後に VM の実行コマンド インスタンス ビューを取得する</strong></em><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#get-a-run-command-instance-view-for-a-vm-after-creating-or-updating-run-command">https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#get-a-run-command-instance-view-for-a-vm-after-creating-or-updating-run-command</a></p></blockquote><p>4 KB を超える出力内容をご確認いただく方法として、マネージド実行コマンドでは、<br>標準出力と標準エラー メッセージを追加 BLOB にストリーミングして、ご確認いただくことが可能です。<br>ストリーミング先の追加 BLOB は、BLOB の SAS URL を指定することができます。<br>コマンド例は、以下のとおりとなります。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-AzVMRunCommand</span> `</span><br><span class="line">  <span class="literal">-ResourceGroupName</span> &lt;リソース グループ名&gt; `</span><br><span class="line">  <span class="literal">-VMName</span> &lt;仮想マシン リソース名&gt; `</span><br><span class="line">  <span class="literal">-Location</span> &lt;リージョン名&gt; `</span><br><span class="line">  <span class="literal">-RunCommandName</span> &lt;実行コマンド名&gt; `</span><br><span class="line">  <span class="literal">-ScriptLocalPath</span> <span class="string">&quot;&lt;実行するスクリプトのパス&gt;&quot;</span> `</span><br><span class="line">  <span class="literal">-OutputBlobUri</span> <span class="string">&quot;https://&#123;出力先のストレージ アカウント名&#125;.blob.core.windows.net/&#123;BLOB コンテナ名&#125;/output.txt?&#123;SAS&#125;&quot;</span> `</span><br><span class="line">  <span class="literal">-ErrorBlobUri</span> <span class="string">&quot;https://&#123;出力先のストレージ アカウント名&#125;.blob.core.windows.net/&#123;BLOB コンテナ名&#125;/error.txt?&#123;SAS&#125;&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p><em><strong>OutputBlobUri、ErrorBlobUri を使用して VM で実行コマンドを作成または更新し、標準出力と標準エラー メッセージを出力およびエラー追加 BLOB にストリーミングする</strong></em><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#create-or-update-run-command-on-a-vm-using-outputbloburi-errorbloburi-to-stream-standard-output-and-standard-error-messages-to-output-and-error-append-blobs">https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#create-or-update-run-command-on-a-vm-using-outputbloburi-errorbloburi-to-stream-standard-output-and-standard-error-messages-to-output-and-error-append-blobs</a></p></blockquote><hr><h2 id="スクリプトを実行するユーザについて"><a href="#スクリプトを実行するユーザについて" class="headerlink" title="スクリプトを実行するユーザについて"></a>スクリプトを実行するユーザについて</h2><p>アクション実行コマンドでは、Windows の場合はシステム アカウント、Linux の場合はルート ユーザで実行されます。</p><p>マネージド実行コマンドでは、実行するユーザを指定することができます。<br>ユーザを指定しない場合は、アクション実行コマンドと同様に、<br>Windows の場合はシステム アカウント、Linux の場合はルート ユーザで実行されます。<br>実行するユーザを指定する際のコマンド例は、以下のとおりとなります。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-AzVMRunCommand</span> `</span><br><span class="line">  <span class="literal">-ResourceGroupName</span> &lt;リソース グループ名&gt; `</span><br><span class="line">  <span class="literal">-VMName</span> &lt;仮想マシン リソース名&gt; `</span><br><span class="line">  <span class="literal">-Location</span> &lt;リージョン名&gt; `</span><br><span class="line">  <span class="literal">-RunCommandName</span> &lt;任意の実行コマンド名&gt; `</span><br><span class="line">  <span class="literal">-ScriptLocalPath</span> <span class="string">&quot;&lt;実行するスクリプトのパス&gt;&quot;</span> `</span><br><span class="line">  <span class="literal">-RunAsUser</span> &lt;実行ユーザ名&gt; `</span><br><span class="line">  <span class="literal">-RunAsPassword</span> &lt;実行ユーザのパスワード&gt;</span><br></pre></td></tr></table></figure><blockquote><p><em><strong>RunAsUser および RunAsPassword パラメーターを使用して別のユーザーとして VM で実行コマンドを作成または更新する</strong></em><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#create-or-update-run-command-on-a-vm-as-a-different-user-using-runasuser-and-runaspassword-parameters">https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/run-command-managed#create-or-update-run-command-on-a-vm-as-a-different-user-using-runasuser-and-runaspassword-parameters</a></p></blockquote><hr><h2 id="複数の仮想マシンでスクリプトを実行する"><a href="#複数の仮想マシンでスクリプトを実行する" class="headerlink" title="複数の仮想マシンでスクリプトを実行する"></a>複数の仮想マシンでスクリプトを実行する</h2><p>複数の仮想マシンで同じスクリプトを実行したい場合は、スクリプトを実行する仮想マシンのリストを取得して、<br>Azure CLI または Azure PowerShell のコマンドを繰り返し実行することで実現できます。<br>REST API をご利用いただく場合も同様に実現可能です。</p><p>例えば、<code>testtag</code> というタグの値が <code>y</code> となっている全ての仮想マシンでスクリプトを実行したい場合、<br>コマンド例は以下のとおりとなります。</p><figure class="highlight powershell"><figcaption><span>マネージド実行コマンド コマンド例 (Azure PowerShell/PowerShell 7)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$VMList</span> = <span class="selector-tag">@</span>(<span class="built_in">Get-AzResource</span> <span class="literal">-Tag</span> <span class="selector-tag">@</span>&#123;<span class="string">&#x27;testtag&#x27;</span>=<span class="string">&#x27;y&#x27;</span>&#125;) </span><br><span class="line"><span class="variable">$VMList</span> | <span class="built_in">Foreach-Object</span> <span class="literal">-Parallel</span> &#123;<span class="built_in">Set-AzVMRunCommand</span> <span class="literal">-ResourceGroupName</span> <span class="variable">$_</span>.ResourceGroupName <span class="literal">-VMName</span> <span class="variable">$_</span>.name <span class="literal">-Location</span> &lt;リージョン名&gt; <span class="literal">-RunCommandName</span> <span class="string">&#x27;&lt;任意の実行コマンド名&gt;&#x27;</span> <span class="literal">-ScriptLocalPath</span> <span class="string">&#x27;&lt;実行するスクリプトのパス&gt;&#x27;</span>&#125;  </span><br></pre></td></tr></table></figure><div class="alert is-info"><p class="alert-title">Note</p><p>実行コマンドを繰り返し実行する際、Azure Resource Manager (ARM) の要求スロットルの上限に達して、要求がエラーとなる可能性があります。</p><p>複数の VM でスクリプトをリモート実行される要件がある場合は、検証等を実施していただき、問題なくスクリプトが実行できることを予めご確認いただくことを推奨します。</p><p>&emsp;</p><p><em><strong>Resource Manager の要求のスロットル</strong></em></p><p><a href="https://learn.microsoft.com/ja-jp/azure/azure-resource-manager/management/request-limits-and-throttling#error-code">https://learn.microsoft.com/ja-jp/azure/azure-resource-manager/management/request-limits-and-throttling#error-code</a></p><p><em><strong>API の調整エラーのトラブルシューティング</strong></em></p><p><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshooting-throttling-errors">https://learn.microsoft.com/ja-jp/troubleshoot/azure/virtual-machines/troubleshooting-throttling-errors</a></p></div><hr><h2 id="長時間のスクリプトを実行する"><a href="#長時間のスクリプトを実行する" class="headerlink" title="長時間のスクリプトを実行する"></a>長時間のスクリプトを実行する</h2><p>アクション実行コマンドでは、スクリプトを実行可能な最大時間が 90 分という制約がありましたが、<br>マネージド実行コマンドでは、実行時間が 90 分を超えるスクリプトの実行が可能です。<br>マネージド実行コマンドにおいて、長時間のスクリプトを実行する際には、<br>Azure PowerShell の場合は、以下のパラメータを指定する必要があります。</p><ul><li><code>timeoutInSeconds</code> パラメータを予測される実行時間よりも大きく指定する。</li><li><code>asyncExecution</code> パラメータを <code>true</code> とする。</li></ul><div class="alert is-info"><p class="alert-title">Note</p><p><code>timeoutInSeconds</code> パラメータでは、スクリプトのタイムアウト値を秒で指定します。</p><p><code>asyncExecution</code> パラメータは、デフォルトでは false となっており、スクリプトが完了するまでプロビジョニングが待機する設定となっていますので、90 分でプロビジョニングのタイムアウトが発生します。回避するためには、<code>true</code> を指定します。</p></div><p>タイムアウト値を 5 時間に指定する際のコマンド例は以下のとおりです。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-AzVMRunCommand</span> `</span><br><span class="line">  <span class="literal">-ResourceGroupName</span> &lt;リソース グループ名&gt; `</span><br><span class="line">  <span class="literal">-VMName</span> &lt;仮想マシン リソース名&gt; `</span><br><span class="line">  <span class="literal">-Location</span> &lt;リージョン名&gt; `</span><br><span class="line">  <span class="literal">-RunCommandName</span> &lt;任意の実行コマンド名&gt; `</span><br><span class="line">  <span class="literal">-ScriptLocalPath</span> <span class="string">&quot;&lt;実行するスクリプトのパス&gt;&quot;</span> `</span><br><span class="line">  <span class="literal">-TimeoutInSecond</span> <span class="number">18000</span> `</span><br><span class="line">  <span class="literal">-AsyncExecution</span> true</span><br></pre></td></tr></table></figure><hr><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>この記事では、 実行コマンドの利用方法について解説しました。<br>Azure VM にてスクリプトをリモートで実行されるご要件がある場合や、<br>アクション実行コマンドからマネージド実行コマンドに運用を移行される際のご参考としていただけますと幸いでございます。 </p><p>マネージド実行コマンドでは、本記事で解説した機能に加え、<br>1 台の VM で複数のスクリプトを同時実行する機能 (ARM テンプレート利用)やギャラリー機能等がご利用いただけます。<br>記事内でご案内いたしました公開ドキュメントも併せてご確認ください。</p><p>上記の解説内容が、皆様のお役に立てますと幸いでございます。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポートチームの井上です。 &lt;/p&gt;
&lt;p&gt;本記事では、Azure VM の拡張機能の一つである実行コマンド (RunCommand) について、&lt;br&gt;利用方法やアクション実行コマンドとマネージド実行コマンドの違い等を解説させていただきます。&lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="Linux" scheme="https://jpaztech.github.io/blog/tags/Linux/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
  </entry>
  
  <entry>
    <title>Azure マーケットプレイスのイメージの OS ディスクサイズの確認・拡張・縮小について</title>
    <link href="https://jpaztech.github.io/blog/vm/os-disk-size-of-image/"/>
    <id>https://jpaztech.github.io/blog/vm/os-disk-size-of-image/</id>
    <published>2023-02-22T08:30:00.000Z</published>
    <updated>2023-05-26T05:14:04.811Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポート チームの富田です。<br>今回はお問い合わせいただくことの多い、Azure マーケットプレイスのイメージの OS ディスクサイズについて、<br>確認方法・拡張方法・縮小不可などの点について解説させていただきます。  </p><span id="more"></span><hr><h2 id="1-イメージの-URN-を把握する"><a href="#1-イメージの-URN-を把握する" class="headerlink" title="1.イメージの URN を把握する"></a>1.イメージの URN を把握する</h2><p>イメージの OS ディスクサイズを確認や、コマンドベースでイメージを指定してデプロイを行う場合は、<br>まずは当該イメージの URN（Uniform Resource Name）を把握する必要があります。<br>イメージの URN は以下のような 4 つの情報の組み合わせで構成されています。  </p><ul><li>Publisher</li><li>Offer</li><li>Sku</li><li>Version</li></ul><p>この 4 つの情報を組み合わせることで、特定のイメージが指定できるということになります。<br>例えば、Azure マーケットプレイス に公開されている 2022/12/29 時点で最新の Windows Server 2022 Datacenter: Azure Edition の URN 以下のようになります。 </p><ul><li>Publisher : microsoftwindowsserver</li><li>Offer : windowsserver</li><li>Sku : 2022-datacenter-azure-edition</li><li>Version : 20348.1366.221207</li></ul><p>ここでひとつ注意したい点は、Azure マーケットプレイスのイメージにおける Version は、あくまでイメージの Version であって、<br>「Windows Server 2012」「Windows Server 2019」といった OS の違いは、Sku の方で定義されているということです。  </p><p>同じ Windows Server 2022 Datacenter: Azure Edition でも、イメージの Version が古いものはビルド等が古いといったこととなります。  </p><p>では、実際にこの URN をどうやって確認するのか、「Azure ポータル」「Azure PowerShell」「Azure CLI」それぞれで確認する方法から見ていきましょう。  </p><hr><h2 id="1-1-Azure-ポータルでイメージの-URN-を把握する"><a href="#1-1-Azure-ポータルでイメージの-URN-を把握する" class="headerlink" title="1-1.Azure ポータルでイメージの URN を把握する"></a>1-1.Azure ポータルでイメージの URN を把握する</h2><p>Azure ポータルにログインし、「リソースの作成」を選択します。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-11-32-56.png"></p><p>「リソースの作成」画面の検索ボックスより、Azure マーケットプレイスのイメージを検索します。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-11-33-57.png"></p><p>対象のイメージを選択します。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-11-34-57.png"></p><p>対象のイメージの画面上で、「プラン」を選択の上、「使用状況確認とサポート」タブを選択します。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-11-43-09.png"></p><p>上記のように、URN が表示されます。<br>恐縮ながら Azure ポータルでは Version の一覧の確認は叶いませんため、Version について確認が必要な場合は、後述のコマンドベースでのご確認をお願いいたします。</p><hr><h2 id="1-2-Azure-PowerShell-でイメージの-URN-を把握する"><a href="#1-2-Azure-PowerShell-でイメージの-URN-を把握する" class="headerlink" title="1-2.Azure PowerShell でイメージの URN を把握する"></a>1-2.Azure PowerShell でイメージの URN を把握する</h2><p>基本的に以下の公式ドキュメントの方法となりますが、実際にコマンドの実行結果と共に見ていきましょう。<br>Publisher → Offer → Sku → Version の順で絞り込んで検索していくような形となります。</p><blockquote><p>■ご参考：Azure PowerShell を使用して Azure Marketplace VM イメージを検索して使用する<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/cli-ps-findimage">https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/cli-ps-findimage</a></p></blockquote><p>まずは、リージョンを指定して Publisher の一覧を取得します。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p>リージョン名は下記コマンドで Location として表示されるものを使います。</p><p>Get-AzLocation | select Location, DisplayName</p></div><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$locName = &quot;リージョン名&quot;</span><br><span class="line">Get-AzVMImagePublisher -Location $locName | Select PublisherName</span><br></pre></td></tr></table></figure><p>以下が実際に実行した結果の一部です。Publisher の一覧が表示されていますね。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-12-20-08.png"></p><p>次に、確認した Publisher を指定してその Publisher が公開している Offer の一覧を表示しましょう。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$locName = &quot;リージョン名&quot;</span><br><span class="line">$pubName = &quot;パブリッシャー名&quot;</span><br><span class="line">Get-AzVMImageOffer -Location $locName -PublisherName $pubName | Select Offer</span><br></pre></td></tr></table></figure><p>以下が実際に実行した結果の一部です。Publisher が公開している Offer の一覧が表示されました。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-12-04-16.png"></p><p>次に、確認した Offer を指定してその Offer 内の Sku の一覧を表示しましょう。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$locName = &quot;リージョン名&quot;</span><br><span class="line">$pubName=&quot;パブリッシャー名&quot;</span><br><span class="line">$offerName = &quot;オファー名&quot;</span><br><span class="line">Get-AzVMImageSku -Location $locName -PublisherName $pubName -Offer $offerName | Select Skus</span><br></pre></td></tr></table></figure><p>以下が実際に実行した結果の一部です。指定した Offer 内の Sku の一覧が表示されました。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-12-06-44.png"></p><p>最後に、Sku を指定してその Sku 内の Version の一覧を調べましょう。  </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$locName = &quot;リージョン名&quot;</span><br><span class="line">$pubName=&quot;パブリッシャー名&quot;</span><br><span class="line">$offerName = &quot;オファー名&quot;</span><br><span class="line">$skuName = &quot;SKU 名&quot;</span><br><span class="line">Get-AzVMImage -Location $locName -PublisherName $pubName -Offer $offerName -Sku $skuName | Select PublisherName, Offer, Skus, Version</span><br></pre></td></tr></table></figure><p>以下が実際に実行した結果の一部です。<br>無事に Version 一覧も取得でき、Publisher, Offer, Sku, Version の組み合わせでイメージの URN が把握できました。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-12-11-28.png"></p><hr><h2 id="1-3-Azure-CLI-でイメージの-URN-を把握する"><a href="#1-3-Azure-CLI-でイメージの-URN-を把握する" class="headerlink" title="1-3.Azure CLI でイメージの URN を把握する"></a>1-3.Azure CLI でイメージの URN を把握する</h2><p>基本的に以下の公式ドキュメントの方法となりますが、実際にコマンドの実行結果と共に見ていきましょう。<br>Publisher → Offer → Sku → Version の順で絞り込んで検索していくような形となります。</p><blockquote><p>■ご参考：Azure CLI を使用して Azure Marketplace イメージ情報を検索する<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/cli-ps-findimage">https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/cli-ps-findimage</a></p></blockquote><p>まずは、リージョンを指定して Publisher の一覧を取得します。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p>リージョン名は下記コマンドで name として表示されるものを使います。</p><p>az account list-locations</p></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az vm image list-publishers --location ＜リージョン名＞ --output table</span><br></pre></td></tr></table></figure><p>以下が実際に実行した結果の一部です。Publisher の一覧が表示されていますね。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-13-38-26.png"></p><p>次に、確認した Publisher を指定してその Publisher が公開している Offer の一覧を表示しましょう。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az vm image list-offers --location ＜リージョン名＞ --publisher ＜パブリッシャー名＞ --output table</span><br></pre></td></tr></table></figure><p>以下が実際に実行した結果の一部です。Publisher が公開している Offer の一覧が表示されました。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-13-39-16.png"></p><p>次に、確認した Offer を指定してその Offer 内の Sku の一覧を表示しましょう。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az vm image list-skus --location ＜リージョン名＞ --publisher ＜パブリッシャー名＞ --offer ＜オファー名＞ --output table</span><br></pre></td></tr></table></figure><p>以下が実際に実行した結果の一部です。指定した Offer 内の Sku の一覧が表示されました。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-13-40-26.png"></p><p>最後に、Sku を指定してその Sku 内の Version の一覧を調べましょう。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">az vm image list \</span><br><span class="line">    --location ＜リージョン名＞ \</span><br><span class="line">    --publisher ＜パブリッシャー名＞ \</span><br><span class="line">    --offer ＜オファー名＞  \</span><br><span class="line">    --sku ＜SKU 名＞ \</span><br><span class="line">    --all --output table</span><br></pre></td></tr></table></figure><p>以下が実際に実行した結果の一部です。<br>無事に Version 一覧も取得でき、Publisher, Offer, Sku, Version の組み合わせでイメージの URN が把握できました。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-13-43-57.png"></p><hr><h2 id="2-イメージの-OS-ディスクサイズを確認する"><a href="#2-イメージの-OS-ディスクサイズを確認する" class="headerlink" title="2.イメージの OS ディスクサイズを確認する"></a>2.イメージの OS ディスクサイズを確認する</h2><p>上述の方法でイメージ URN を把握すれば、 Azure CLI の下記コマンド使用することで、そのイメージの OS ディスクサイズを確認することが可能です。<br>なお恐縮ながら Azure PowerShell では確認が叶いませんものと存じます。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az vm image show --location ＜リージョン名＞ --urn ＜パブリッシャー名＞:＜オファー名＞:＜SKU 名＞:＜バージョン番号＞</span><br></pre></td></tr></table></figure><div class="alert is-success"><p class="alert-title">ヒント</p><p>最新のバージョンとして ＜バージョン番号＞ に latest という文字列を使用することが可能です。</p></div><p>コマンドの実行結果を見ると以下の通り、OS ディスクサイズに関する表記が確認できます。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-14-03-40.png"></p><hr><h2 id="3-Windows-のイメージの既定-OS-ディスクサイズについて"><a href="#3-Windows-のイメージの既定-OS-ディスクサイズについて" class="headerlink" title="3.Windows のイメージの既定 OS ディスクサイズについて"></a>3.Windows のイメージの既定 OS ディスクサイズについて</h2><p>2023 年 1 月時点で、Azure マーケットプレイスで Microsoft より公開されている Windows のイメージについては、<br>OS ディスクサイズは既定で 127 GB となっております。  </p><p>しかしながら、これよりも小さな OS ディスクが必要なお客様のために、Windows Server については、<br>smalldisk というプラン（Offer）で OS ディスクが 30 GB となっているイメージをご用意しております。<br>基本的にディスクサイズが違う点以外、イメージの内容は通常版と差異は無いものと存じますため、<br>Windows Server で小さな OS ディスクが必要な場合は smalldisk のイメージをご利用くださいませ。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-14-32-25.png"></p><blockquote><p>■ご参考：New smaller Windows Server IaaS Image<br><a href="https://azure.microsoft.com/ja-jp/blog/new-smaller-windows-server-iaas-image/">https://azure.microsoft.com/ja-jp/blog/new-smaller-windows-server-iaas-image/</a></p></blockquote><hr><h2 id="4-OS-ディスクサイズの拡張について"><a href="#4-OS-ディスクサイズの拡張について" class="headerlink" title="4.OS ディスクサイズの拡張について"></a>4.OS ディスクサイズの拡張について</h2><p>OS ディスクサイズは以下の通り、VM デプロイ後に後から拡張することが可能です。</p><blockquote><p>■ご参考：Windows 仮想マシンに接続されている仮想ハード ディスクを拡張する方法<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/expand-os-disk">https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/expand-os-disk</a></p></blockquote><blockquote><p>■ご参考：Linux VM の仮想ハード ディスクを拡張する<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/expand-disks">https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/expand-disks</a></p></blockquote><p>また、Azure CLI を用いた場合、 az vm create コマンドで新規 VM をデプロイする際に、<br>–os-disk-size-gb オプションに数値を指定いただくと、指定いただいた GB のサイズで OS ディスクが作成されます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az vm create --resource-group ＜リソースグループ名＞ --name ＜VM 名＞ --image ＜パブリッシャー名＞:＜オファー名＞:＜SKU 名＞:＜バージョン番号＞ --os-disk-size-gb ＜OS ディスクサイズ GB の数値＞ </span><br></pre></td></tr></table></figure><blockquote><p>■ご参考：az vm create<br><a href="https://learn.microsoft.com/ja-jp/cli/azure/vm?view=azure-cli-latest#az-vm-create">https://learn.microsoft.com/ja-jp/cli/azure/vm?view=azure-cli-latest#az-vm-create</a></p></blockquote><div class="alert is-info"><p class="alert-title">Note</p><p>既定の OS ディスクサイズより小さな値を指定することはできません。</p><p>また、サードパーティ様のイメージでは OS ディスクの拡張がサポートされない可能性もございます点、ご了承くださいませ。</p></div><p>例としてこちらのコマンドで以下のように、300 GB の OS ディスクを持つ Windows Server がデプロイできました。</p><p><img src="/blog/vm/os-disk-size-of-image/2022-12-29-15-07-19.png"></p><p>なお恐縮ながら Azure PowerShell ではこのような VM デプロイ時の OS ディスクサイズ指定が叶いませんものと存じますため、<br>Azure PowerShell の場合はデプロイ後に OS ディスクサイズをご変更いただけますと幸いです。</p><hr><h2 id="5-OS-ディスクサイズの縮小について"><a href="#5-OS-ディスクサイズの縮小について" class="headerlink" title="5.OS ディスクサイズの縮小について"></a>5.OS ディスクサイズの縮小について</h2><p>恐縮ではございますが、OS ディスク・データディスク共に、<br>現在 Azure マネージドディスクの縮小はサポートされておりませんものとなります。</p><blockquote><p>■ご参考：マネージド ディスクを縮小またはダウンサイズできますか?<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/faq-for-disks#----------------------------">https://learn.microsoft.com/ja-jp/azure/virtual-machines/faq-for-disks#—————————-</a></p></blockquote><p>そのため小さな OS ディスクが必要なときは、Windows Server の場合は先述の smalldisk を使用することや、<br>Linux の場合オンプレミス環境等で任意の VHD のサイズをご用意いただき、Azure へアップロードしてご利用いただくといったことをご検討いただけますと幸いです。</p><p>上記の解説内容が、皆様のお役に立てますと幸いでございます。  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポート チームの富田です。&lt;br&gt;今回はお問い合わせいただくことの多い、Azure マーケットプレイスのイメージの OS ディスクサイズについて、&lt;br&gt;確認方法・拡張方法・縮小不可などの点について解説させていただきます。  &lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="Linux" scheme="https://jpaztech.github.io/blog/tags/Linux/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
    <category term="Disk" scheme="https://jpaztech.github.io/blog/tags/Disk/"/>
    
  </entry>
  
  <entry>
    <title>AKS 1.24 アップグレード時にAzure Load Balancer の正常性プローブプロトコルが変更される</title>
    <link href="https://jpaztech.github.io/blog/containers/aks-lb-probe-failed-after-upgraded-to-k8s-1.24/"/>
    <id>https://jpaztech.github.io/blog/containers/aks-lb-probe-failed-after-upgraded-to-k8s-1.24/</id>
    <published>2023-02-02T04:00:00.000Z</published>
    <updated>2023-05-26T05:14:04.515Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポートチームの小沢です。 </p><p>AKS の Kubernetes バージョンを 1.24 へアップグレードをした際に、Azure Load Balancer の正常性プローブがTCPプロ―ブから HTTP/HTTPS プローブに変更されることがあります。<br>本記事では、プローブの構成が変更された理由と影響、および対応方法について紹介します。 </p><span id="more"></span> <hr><h2 id="Azure-Load-Balancer正常性プローブ"><a href="#Azure-Load-Balancer正常性プローブ" class="headerlink" title="Azure Load Balancer正常性プローブ"></a>Azure Load Balancer正常性プローブ</h2><p>AKS クラスターに Type LoadBalancer の Service を作成すると、自動的に Azure Load Balancer に負荷分散規則が構成され、バックエンドには AKS ノードが割り当てられます。<br>また、Load Balancer のヘルスチェック機能である正常性プローブが構成されます。 </p><p>正常性プローブは、一定の間隔でバックエンドの VM インスタンスに対してヘルスチェック用のアクセスをします。<br>ヘルスチェックのアクセスが、プローブに設定された回数成功しなかった場合は、バックエンドが異常とみなされ、異常なバックエンドにはリクエストが送信されなくなります。<br>正常性プローブで利用できるプロトコルには、TCP、HTTP、HTTPSの3つがあります (Load Balancer の SKU が Standardの場合)。<br>正常性プローブで利用可能なプロトコルの種類や動作につきましては、以下のドキュメントをご参照ください。 </p><blockquote><p>ご参考) Azure Load Balancer の正常性プローブ<br><a href="https://learn.microsoft.com/ja-jp/azure/load-balancer/load-balancer-custom-probe-overview">https://learn.microsoft.com/ja-jp/azure/load-balancer/load-balancer-custom-probe-overview</a> </p></blockquote><h2 id="Service-Type-LoadBalancer-に設定される正常性プローブ"><a href="#Service-Type-LoadBalancer-に設定される正常性プローブ" class="headerlink" title="Service (Type LoadBalancer) に設定される正常性プローブ"></a>Service (Type LoadBalancer) に設定される正常性プローブ</h2><p>AKS 上で Service (Type LoadBalancer) を作成した場合には、Service オブジェクトに設定された値に基づいて、Azure Load Balancer の正常性プローブが自動的に構成されます。 </p><p>正常性プローブで使用するプロトコルは、Service の <code>spec.ports.appProtocol</code> フィールドの設定値 (tcp, http, https) が使用されます。<br>また、プロトコルが http/https の場合、<code>service.beta.kubernetes.io/azure-load-balancer-health-probe-request-path</code> アノテーションで指定されたパスに対して、正常性プローブのリクエストが送信されます。<br><code>spec.ports.appProtocol</code> が設定されていない場合は、アノテーションによるリクエスト パスの指定は無視され、tcp プロトコルを使用する正常性プローブが構成されます。</p><p>Kubernetes バージョン 1.24以降では、Service のアノテーション <code>service.beta.kubernetes.io/azure-load-balancer-health-probe-request-path</code> が設定されて<strong>いない場合</strong>に、正常性プローブの既定の構成が変更されました。<br>Kubernetes バージョン 1.23 以前と 1.24 以降では、次のような違いがあります。 </p><ul><li>Kubernetes バージョン &lt;= 1.23 の場合 <ul><li>Service のアノテーションが設定されていない場合、<strong>プローブのプロトコルに TCP が使用されます</strong> </li><li>アノテーションが設定されている場合は、プロトコルは <code>spec.ports.appProtocol</code> (http/https) が使用され、アノテーションで指定されたパスにプローブのリクエストが送信されます </li></ul></li><li>Kubernetes バージョン &gt; 1.24 の場合 <ul><li>Service のアノテーションが設定されていない場合、<strong>プローブのプロトコルに <code>spec.ports.appProtocol</code> (http/https) が使用され、リクエスト パスには <code>/</code> が使用されます</strong> </li><li>アノテーションが設定されている場合は、プロトコルは <code>spec.ports.appProtocol</code> (http/https) が使用され、アノテーションで指定されたパスにプローブのリクエストが送信されます </li></ul></li></ul><p>Load Balancer の正常性プローブで、どのプロトコルとリクエスト パスが使用されるかについては、Cloud Provider Azure のドキュメントで確認できます。 </p><blockquote><p>ご参考) Cloud Provider Azure - Custom Load Balancer health probe<br><a href="https://cloud-provider-azure.sigs.k8s.io/topics/loadbalancer/#custom-load-balancer-health-probe">https://cloud-provider-azure.sigs.k8s.io/topics/loadbalancer/#custom-load-balancer-health-probe</a> </p></blockquote><h2 id="正常性プローブの構成が変更された場合の影響"><a href="#正常性プローブの構成が変更された場合の影響" class="headerlink" title="正常性プローブの構成が変更された場合の影響"></a>正常性プローブの構成が変更された場合の影響</h2><p>Service (type: LoadBalancer) の YAML マニフェストにおいて、Service のアノテーション <code>service.beta.kubernetes.io/azure-load-balancer-health-probe-request-path</code> を記述せずに、<code>spec.ports.appProtocol</code> のみを記述している場合に、Kubernetes バージョンをアップグレードしたあとにアプリケーションへアクセスできない事象が発生する可能性があります。 </p><p>Kubernetes &lt;= 1.23 では、<code>spec.ports.appProtocol</code> にプロトコル名が記述されている場合でも、正常性プローブのプロトコルには TCP が使用されます。<br>TCP プローブでは、対象の TCP ポートへの疎通性のみをチェックします。<br>HTTP/HTTPS のリクエスト/レスポンスの成否や、レスポンスの内容 (エラーステータスであるかどうか) は、プローブの結果に影響をしません。 </p><p>一方 Kubernetes &gt; 1.24 では、<code>spec.ports.appProtocol</code> に <code>http (または　https)</code>が記述されていると、正常性プローブのプロトコルは <code>http (または https)</code> に設定されます。<br>また、アノテーションでプローブのリクエスト パスが設定されていない場合には、既定で <code>/</code> が使用されます。<br>AKS クラスターで稼働しているアプリケーションが、<code>/</code> のパスでリクエストを受け付けていない場合や、<code>/</code> にアクセスした結果、エラーステータスの HTTP レスポンスを返した場合には、正常性プローブが失敗します。 </p><p>このように、Kubernetes バージョンによって、正常性プローブで使用されるプロトコルとパスが異なります。 </p><p>Kubernetes 1.23 では、TCP プロトコルによる疎通チェックによって正常性プローブが成功していたものの、Kubernetes 1.24 にアップグレードしたあとに正常性プローブが HTTP(S) によるチェックに切り替わり、プローブの条件を満たさなくなったことでバックエンドから切り離され、Load Balancer を介したアプリケーションへのアクセスが成功しない事象が発生します。 </p><h2 id="事例-NGINX-Ingress-Controller-にアクセスできなくなる"><a href="#事例-NGINX-Ingress-Controller-にアクセスできなくなる" class="headerlink" title="事例: NGINX Ingress Controller にアクセスできなくなる"></a>事例: NGINX Ingress Controller にアクセスできなくなる</h2><p>NGINX Ingress Controller を使用しているクラスターで、Kubernetes バージョンのアップグレードを実施したあとに、本事象の影響を受ける場合があります。 </p><p>NGINX Ingress Controller では、Ingress でマッピングされていないリクエストは、全て default backend で処理されます。<br>default backend は2つのパスを公開しており、<code>/healthz</code> では HTTP 200 ステータスを返し、<code>/</code> は HTTP 404 ステータスを返します。 </p><blockquote><p>ご参考) NGINX Ingress Controller - Default backend<br><a href="https://kubernetes.github.io/ingress-nginx/user-guide/default-backend/">https://kubernetes.github.io/ingress-nginx/user-guide/default-backend/</a> </p></blockquote><p>Kubernetes 1.23 では、正常性プローブは TCP プロトコルによる疎通チェックのみを行います。<br>そのため、Ingress Controller に用意されているパスや、そのレスポンス内容にかかわらず、TCP ポートに到達できる状態であれば、正常性プローブが成功します。<br>しかし、Kubernetes 1.24 では、<code>spec.ports.appProtocol</code> が <code>http/https</code> の場合、正常性プローブは既定で <code>/</code> へリクエストを送信し、その HTTP レスポンスの結果によってプローブの結果を決定します。<br>default backend の <code>/</code> は HTTP 404 ステータスを返すために、正常性プローブは失敗の状態となり、Load Balancer からバックエンドの AKS ノードにトラフィックが流されなくなるために、アプリケーションへアクセスできなくなる事象が発生します。 </p><p>NGINX Ingress Controller の Helm Chart では、既定で Service の <code>spec.ports.appProtocol</code> を出力するように values.yaml が構成されています。<br>一方、Service のアノテーションは <code>annotations: &#123;&#125;</code> のように、値が空となっていいます。 </p><blockquote><p>ご参考) Helm Chart の該当箇所<br>values.yaml<br><a href="https://github.com/kubernetes/ingress-nginx/blob/f90f37bed66d343e6c57ea981d6c4e90e4955975/charts/ingress-nginx/values.yaml#L460-L468">https://github.com/kubernetes/ingress-nginx/blob/f90f37bed66d343e6c57ea981d6c4e90e4955975/charts/ingress-nginx/values.yaml#L460-L468</a><br>controller-service.yaml テンプレート<br><a href="https://github.com/kubernetes/ingress-nginx/blob/f90f37bed66d343e6c57ea981d6c4e90e4955975/charts/ingress-nginx/templates/controller-service.yaml#L53-L71">https://github.com/kubernetes/ingress-nginx/blob/f90f37bed66d343e6c57ea981d6c4e90e4955975/charts/ingress-nginx/templates/controller-service.yaml#L53-L71</a></p></blockquote><p>そのため、Kubernetes 1.23 以前に NGINX Ingress Controller をインストールしていた場合には、Kubernetes 1.24 にアップグレードする前に、Ingress Controller の Service に対して、プローブのリクエスト パスが <code>/heathz</code> になるように、事前にアノテーションを追加しておく必要があります。 </p><h2 id="NGINX-Ingress-Controller-にアクセスできない事象の再現"><a href="#NGINX-Ingress-Controller-にアクセスできない事象の再現" class="headerlink" title="NGINX Ingress Controller にアクセスできない事象の再現"></a>NGINX Ingress Controller にアクセスできない事象の再現</h2><p>実際に、Kubernetes 1.23 の AKS クラスターに NGINX Ingress Controller をインストールして、その後 Kubernetes 1.24 へアップグレードすることで、本事象の影響を確認します。 </p><p>まず ingress-nginx-controller Service の YAML マニフェストの内容を確認します。<br><code>metadata.annotations</code> に <code>service.beta.kubernetes.io/azure-load-balancer-health-probe-request-path</code> の設定がなく、<code>spec.ports.appProtocol</code> では <code>http/https</code> が使用されていることが確認できました。 </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">svc</span> <span class="string">ingress-nginx-controller</span> <span class="string">-o</span> <span class="string">yaml</span> <span class="string">-n</span> <span class="string">ingress-basic</span> </span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span> </span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">annotations:</span> </span><br><span class="line">    <span class="comment"># リクエスト パスのアノテーションがない </span></span><br><span class="line">    <span class="attr">meta.helm.sh/release-name:</span> <span class="string">ingress-nginx</span> </span><br><span class="line">    <span class="attr">meta.helm.sh/release-namespace:</span> <span class="string">ingress-basic</span> </span><br><span class="line">    <span class="string">…</span> </span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">　<span class="string">…</span> </span><br><span class="line">  <span class="attr">ports:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">appProtocol:</span> <span class="string">http</span>       <span class="comment"># http が指定されている </span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">http</span> </span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">32271</span> </span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span> </span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span> </span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">http</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">appProtocol:</span> <span class="string">https</span>      <span class="comment"># https が指定されている </span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">https</span> </span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30569</span> </span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span> </span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span> </span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">https</span> </span><br></pre></td></tr></table></figure><p>AKS クラスターで使用される Azure Load Balancer のリソースは、kubernetes という名前で、ノードリソースグループ (既定では MC_* という名前) に配置されています。<br>Azure Portal で Load Balancer を開き、左メニューの正常性プローブのページを開きます。<br>プローブの一覧を確認すると、プロトコル がTCP のプローブとなっていることがわかります。 </p><p><img src="/blog/containers/aks-lb-probe-failed-after-upgraded-to-k8s-1.24/aks-lb-probe-failed-after-upgraded-to-k8s-1.24-01.png"></p><p>また、左メニューの分析情報のページを開くと、ネットワーク構成の図が表示され、正常性プローブは成功していることが確認できます。 </p><p><img src="/blog/containers/aks-lb-probe-failed-after-upgraded-to-k8s-1.24/aks-lb-probe-failed-after-upgraded-to-k8s-1.24-02.png"></p><p>そのあと、対象の AKS クラスターの Kubernetes バージョンを 1.24 にアップグレードします。<br>アップグレードをした後に Azure Portal 画面から正常性プローブを確認すると、プロトコルが <code>HTTP/S</code> のプローブが作成されており、リクエスト パスが <code>/</code> に設定されていることが確認できました。<br>この場合、NGINX Ingress Controller の default Backend は、<code>/</code> に対するアクセスに HTTP 404 ステータスを返すため、正常性プローブが失敗してしまいます。 </p><p><img src="/blog/containers/aks-lb-probe-failed-after-upgraded-to-k8s-1.24/aks-lb-probe-failed-after-upgraded-to-k8s-1.24-03.png"></p><p>Azure Portal画面の分析情報の図からも、正常性プローブが失敗していることが確認できます。 </p><p><img src="/blog/containers/aks-lb-probe-failed-after-upgraded-to-k8s-1.24/aks-lb-probe-failed-after-upgraded-to-k8s-1.24-04.png"> </p><h2 id="対応方法"><a href="#対応方法" class="headerlink" title="対応方法"></a>対応方法</h2><p>Kubernetes 1.24 のクラスターで、正常性プローブの状態を回復させる対応方法について説明します。 </p><div class="alert is-important"><p class="alert-title">重要</p><p>AKS で使用される Load Balancer の正常性プローブは、 クラスター上に作成された Service の内容をもとに、自動的に構成される仕組みです。</p><p>そのため、Azure CLI や Azure Portal で Load Balancerを直接変更するのではなく、Service の設定値を変えます。 </p></div><p>Service にアノテーションを追加し、カスタム ヘルスプローブ パスを設定することで、Kubernetes 1.23 から 1.24 へアップグレードした際にも正常性プローブが成功します。 </p><figure class="highlight yaml"><figcaption><span>Service にアノテーションを設定する例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span> </span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">annotations:</span> </span><br><span class="line">    <span class="attr">service.beta.kubernetes.io/azure-load-balancer-health-probe-request-path:</span> <span class="string">/healthz</span>  <span class="comment"># HTTP 200 ステータスを返すパスを指定します </span></span><br><span class="line"><span class="string">…</span> </span><br></pre></td></tr></table></figure><p>Helm を使ってインストールした NGINX Ingress Controller は、<code>helm upgrade</code> コマンドで Service のアノテーションが設定できます。<br><code>helm ugprade</code> コマンドに <code>--set</code> オプションを付与し、<code>controller.service.annotations</code> value の値を <code>&quot;service.beta.kubernetes.io/azure-load-balancer-health-probe-request-path&quot;=/healthz</code> に設定します。 </p><p>すでに Kubernetes 1.24 にアップグレードしたクラスターや、これからアップグレードをするクラスターでは、<code>helm upgrade</code> コマンドでアノテーションを設定しましょう。<br>また、この <code>--set</code> オプションは、新規に Ingress Controller をインストールする際にも、<code>helm install</code> コマンドに付与することで利用できます。<br>今後新規に Ingress Controller をインストールする場合には、オプションでアノテーションの値を指定したうえで、インストールしましょう。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">helm upgrade ingress-nginx ingress-nginx/ingress-nginx \ </span><br><span class="line">  --create-namespace \ </span><br><span class="line">  --namespace <span class="variable">$NAMESPACE</span> \ </span><br><span class="line">  --<span class="built_in">set</span> controller.service.annotations.<span class="string">&quot;service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path&quot;</span>=/healthz </span><br><span class="line">Release <span class="string">&quot;ingress-nginx&quot;</span> has been upgraded. Happy Helming! </span><br><span class="line">NAME: ingress-nginx </span><br><span class="line">LAST DEPLOYED: Mon Jan 16 15:16:54 2023 </span><br><span class="line">NAMESPACE: ingress-basic </span><br><span class="line">STATUS: deployed </span><br><span class="line">REVISION: 2 </span><br><span class="line">TEST SUITE: None </span><br><span class="line">NOTES: </span><br><span class="line">The ingress-nginx controller has been installed. </span><br><span class="line">It may take a few minutes <span class="keyword">for</span> the LoadBalancer IP to be available. </span><br><span class="line">You can watch the status by running <span class="string">&#x27;kubectl --namespace ingress-basic get services -o wide -w ingress-nginx-controller&#x27;</span> </span><br></pre></td></tr></table></figure><p>Service の YAML マニフェストの内容を確認してみましょう。<br><code>metadata.annotations</code> フィールド内に、<code>service.beta.kubernetes.io/azure-load-balancer-health-probe-request-path: /healthz</code> が追加されたことを確認できました。 </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">svc</span> <span class="string">ingress-nginx-controller</span> <span class="string">-o</span> <span class="string">yaml</span> <span class="string">-n</span> <span class="string">ingress-basic</span> </span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span> </span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">annotations:</span> </span><br><span class="line">    <span class="attr">meta.helm.sh/release-name:</span> <span class="string">ingress-nginx</span> </span><br><span class="line">    <span class="attr">meta.helm.sh/release-namespace:</span> <span class="string">ingress-basic</span> </span><br><span class="line">    <span class="attr">service.beta.kubernetes.io/azure-load-balancer-health-probe-request-path:</span> <span class="string">/healthz</span> </span><br><span class="line">  <span class="string">...</span> </span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">　<span class="string">...</span> </span><br><span class="line">  <span class="attr">ports:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">appProtocol:</span> <span class="string">http</span> </span><br><span class="line">    <span class="attr">name:</span> <span class="string">http</span> </span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">32271</span> </span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span> </span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span> </span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">http</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">appProtocol:</span> <span class="string">https</span> </span><br><span class="line">    <span class="attr">name:</span> <span class="string">https</span> </span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30569</span> </span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span> </span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span> </span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">https</span> </span><br></pre></td></tr></table></figure><p>Azure Portal の画面上でも、プローブのリクエスト パスが <code>/</code> から <code>/healthz</code> に変わりました。 </p><p><img src="/blog/containers/aks-lb-probe-failed-after-upgraded-to-k8s-1.24/aks-lb-probe-failed-after-upgraded-to-k8s-1.24-05.png"> </p><p>また、分析情報の画面においても、正常性プローブも成功していることが確認できました。 </p><p><img src="/blog/containers/aks-lb-probe-failed-after-upgraded-to-k8s-1.24/aks-lb-probe-failed-after-upgraded-to-k8s-1.24-06.png"></p><p>このように、<code>HTTP/HTTPS</code> プローブのリクエスト先を、<code>/</code> (404 ステータスが返される) から、<code>/healthz</code> (200 ステータスが返される) に変更することで、正常性プローブの状態を回復させることが確認できました。 </p><p>今回は NGINX Ingress Controller を例に説明をしたため、リクエスト パスは <code>/healthz</code> を指定しました。<br>アプリケーションが用意するヘルスチェック用のエンドポイントは、アプリケーションの実装によってエンドポイントの有無や名称が異なる場合がございます。<br>トラブルシューティングの際は、対象のアプリケーションの仕様・実装をご確認いただき、リクエスト パスをご指定ください。 </p><h2 id="正常性プローブが失敗した時のトラブルシューティング"><a href="#正常性プローブが失敗した時のトラブルシューティング" class="headerlink" title="正常性プローブが失敗した時のトラブルシューティング"></a>正常性プローブが失敗した時のトラブルシューティング</h2><p>さいごに、正常性プローブが成功しない場合の、一般的なトラブルシューティング観点について紹介します。 </p><h3 id="1-ノードの-VM-インスタンスが起動しているか？"><a href="#1-ノードの-VM-インスタンスが起動しているか？" class="headerlink" title="1. ノードの VM インスタンスが起動しているか？"></a>1. ノードの VM インスタンスが起動しているか？</h3><p>Load Balancer の正常性プローブは、バックエンドプールのインスタンスの状態を監視しています。<br>インスタンスが起動していない場合にはヘルスチェックのリクエストが成功しないことが想定されますので、プローブの失敗を検知した際は、VM インスタンスが正常に起動しているかを確認します。<br>AKS では、ノードのステータスが NotReady となっていないかをあわせて確認しましょう。 </p><h3 id="2-NodePort-および正常性プローブのリクエスト-パス"><a href="#2-NodePort-および正常性プローブのリクエスト-パス" class="headerlink" title="2. NodePort および正常性プローブのリクエスト パス"></a>2. NodePort および正常性プローブのリクエスト パス</h3><p>Load Balancer の正常性プローブが、AKS に作成した Service の設定値と一致しているかを確認します。<br>本記事で上述したように、プローブで利用するプロトコルと、プローブのリクエスト パスが正しいかを確認しましょう。 </p><p>また、type LoadBalancer の Service を作成すると、各ノードに NodePort のポートが設定されます。ポート番号は既定で 30000-32767 の範囲となります。<br>Kubectl get svc コマンドで Service 名と NodePort のポート番号を確認し、プローブのリクエスト先と一致しているかを確認しましょう。 </p><h3 id="3-Service-の-Selector-と-Pod-の-label"><a href="#3-Service-の-Selector-と-Pod-の-label" class="headerlink" title="3. Service の Selector と Pod の label"></a>3. Service の Selector と Pod の label</h3><p>Service で指定している selector が、Pod に設定されている label と一致しているかを確認します。<br>また、selector/label が一致している場合は、Pod が正常に稼働しているかどうかを確認します。 </p><h3 id="4-Load-Balancer-からの正常性プローブの通信をブロックしていないかどうか"><a href="#4-Load-Balancer-からの正常性プローブの通信をブロックしていないかどうか" class="headerlink" title="4. Load Balancer からの正常性プローブの通信をブロックしていないかどうか"></a>4. Load Balancer からの正常性プローブの通信をブロックしていないかどうか</h3><p>正常性プローブの設定に問題がなく、ノードや Pod が起動しているにもかかわらず、正常性プローブが失敗している場合には、Load Balancer から送信された正常性プローブの通信がブロックされている可能性が考えられます。 </p><p>NetworkPolicyなどでネットワーク通信を制限している場合には、Load Balancer からの正常性プローブの通信 (送信元が 168.63.129.16) をブロックしていないか確認します。 </p><blockquote><p>ご参考) Azure Load Balancer の正常性プローブの状態に関するトラブルシューティング<br>「原因 3:ファイアウォール、またはネットワーク セキュリティ グループが Load Balancer バックエンド プール VM 上のポートをブロックしている」をご参照ください。<br><a href="https://learn.microsoft.com/ja-jp/azure/load-balancer/load-balancer-troubleshoot-health-probe-status">https://learn.microsoft.com/ja-jp/azure/load-balancer/load-balancer-troubleshoot-health-probe-status</a> </p></blockquote><p>また、Azure Portal の画面では、Load Balancerのメトリックで、正常性プローブの状態を確認できます。<br><code>Health Probe Status</code> メトリックの値から、過去の正常性プローブの状態を確認できますので、事象の発生や解消のタイミングを確認する際にご活用ください。 </p><p><img src="/blog/containers/aks-lb-probe-failed-after-upgraded-to-k8s-1.24/aks-lb-probe-failed-after-upgraded-to-k8s-1.24-07.png"></p><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>この記事では、AKS の Kubernetes バージョンを 1.24 にアップグレードした際に、Load Balancer Service の正常性プローブが成功しなくなる事象と、その対処方法について解説しました。<br>Kubernetes バージョンのアップグレード作業や、Load Balancer サービスへのアクセスが成功しない場合のトラブルシューティングのご参考にいただけますと幸いでございます。 </p><p>本稿が少しでも皆様のご参考となれば幸いです。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポートチームの小沢です。 &lt;/p&gt;
&lt;p&gt;AKS の Kubernetes バージョンを 1.24 へアップグレードをした際に、Azure Load Balancer の正常性プローブがTCPプロ―ブから HTTP/HTTPS プローブに変更されることがあります。&lt;br&gt;本記事では、プローブの構成が変更された理由と影響、および対応方法について紹介します。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="Containers" scheme="https://jpaztech.github.io/blog/tags/Containers/"/>
    
    <category term="Azure Kubernetes Service (AKS)" scheme="https://jpaztech.github.io/blog/tags/Azure-Kubernetes-Service-AKS/"/>
    
  </entry>
  
  <entry>
    <title>Project Flash : Azure 仮想マシンの可用性の監視を高める</title>
    <link href="https://jpaztech.github.io/blog/vm/vm-availability-monitoring-with-project-flash/"/>
    <id>https://jpaztech.github.io/blog/vm/vm-availability-monitoring-with-project-flash/</id>
    <published>2023-01-06T03:00:00.000Z</published>
    <updated>2023-05-26T05:14:04.891Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポート チームの鳥越です。</p><p>2022年に Azure 仮想マシンの可用性の監視を進化するプロジェクトである Project Flash について、以下のブログで紹介されました。</p><blockquote><p> <strong>Project Flash で Azure 仮想マシンの可用性の監視を進化させる</strong><br> <a href="https://azure.microsoft.com/ja-jp/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash/">https://azure.microsoft.com/ja-jp/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash/</a></p></blockquote><p>このプロジェクトは Azure 仮想マシンに対して、お客様の可用性監視ニーズを満たすために、次のようなことが行えるように進められております。</p><ul><li>VM の可用性障害 (VM のリブートや再起動のほか、ネットワーク ドライバーの更新によるアプリケーションのフリーズ、30 秒間のホスト OS の更新など) に関する正確で実用的なデータ、および障害の詳細 (プラットフォームのものかユーザー操作によるものか、リブートかフリーズか、計画的か非計画的かなど) を入手する。</li><li>VM の可用性の傾向を分析してアラートを生成し、迅速なデバッグと前月比のレポート作成を実現する。</li><li>データを定期的かつ大規模に監視し、カスタム ダッシュボードを作成して、すべてのリソースの最新の可用性状態について常に最新の情報を提供する。</li><li>影響を受けた VM、ダウンタイムの原因および期間、結果的な修正などの詳細を示す自動根本原因分析 (RCA) を受け取り、ターゲットを絞った調査および事後分析を行えるようにする。</li><li>VM の可用性に重大な変化があった場合、即座に通知を受け取り、迅速に修復アクションをトリガーし、エンドユーザーへの影響を防止する。</li><li>刻々と変化するワークロードの感度やフェールオーバーのニーズに基づき、プラットフォームの回復ポリシーを動的に調整し、自動化する。</li></ul><p>その中で、上記ブログではプレビューであった <a href="https://learn.microsoft.com/ja-jp/azure/governance/resource-graph/overview">Azure Resource Graph</a> を用いた VM の可用性情報の監視が GA として公開され、Azure Monitor による VM 可用性メトリックがパブリック プレビューとして公開されました。</p><blockquote><p> <strong>New Project Flash Update: Advancing Azure Virtual Machine availability monitoring</strong><br> <a href="https://azure.microsoft.com/en-us/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash-update/">https://azure.microsoft.com/en-us/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash-update/</a></p></blockquote><p>このブログでは、Azure Resource Graph を用いた VM の可用性情報がどのように利用できるのかを解説します。<br>本内容がお客様の VM の監視に少しでもお役に立てられれば幸いです。</p><span id="more"></span><hr><h2 id="Azure-Resource-Graph-を用いたVMの可用性情報の監視"><a href="#Azure-Resource-Graph-を用いたVMの可用性情報の監視" class="headerlink" title="Azure Resource Graph を用いたVMの可用性情報の監視"></a>Azure Resource Graph を用いたVMの可用性情報の監視</h2><p>Azure Portal より <a href="https://learn.microsoft.com/ja-jp/azure/governance/resource-graph/first-query-portal">Azure Resource Graph エクスプローラー</a>をご利用いただけます。<br>Azure Resource Graph エクスプローラーの画面を開き、テーブルから <code>healthresources</code> を選択します。</p><p><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-01.png"></p><p>たとえば、次のようなクエリで実行します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">healthresources</span><br><span class="line">| where id contains &quot;eda570ec&quot; //This is subscription id</span><br><span class="line">| project id, type, location, properties</span><br></pre></td></tr></table></figure><div class="alert is-success"><p class="alert-title">ヒント</p><p>Azure Resource Graph では、<a href="https://learn.microsoft.com/ja-jp/azure/data-explorer/kusto/query/">Kusto Query Language (KQL) クエリ</a>を用いて、情報を出力することが可能です。</p><p>上記は <a href="https://learn.microsoft.com/ja-jp/azure/data-explorer/kusto/query/whereoperator">where 演算子</a>で <code>id</code> の中に <code>&quot;eba570ec&quot;</code> があるものに限定して、<a href="https://learn.microsoft.com/ja-jp/azure/data-explorer/kusto/query/projectoperator">project 演算子</a>で表示される項目を記載しています。  </p></div><p>実行後、次のような結果を得ることができます。</p><p><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-02.png"></p><p>右側の詳細の表示を選択することで値を見やすく見ることが可能となります。</p><p><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-03.png"></p><p>この <code>healthresources</code> テーブルには次の項目が存在します。</p><ul><li><code>&quot;microsoft.resourcehealth/availabilitystatuses&quot;</code></li><li><code>&quot;microsoft.resourcehealth/resourceannotations&quot;</code></li></ul><p>それぞれについて紹介します。</p><p><code>&quot;microsoft.resourcehealth/availabilitystatuses&quot;</code> は、Azure プラットフォームによって実行された正常性チェックに基づいて、VM の最新の可用性状態を示します。<br>VM に対して現在出力されている可用性の状態を次に示します。</p><ul><li><strong>available</strong>: VM は期待どおりに稼働しています。</li><li><strong>unavailable</strong>: VM の正常な機能の中断が検出されたため、アプリケーションは期待どおりに実行されません。</li><li><strong>unknown</strong>: プラットフォームは VM の正常性を正確に検出できません。ユーザーは通常、数分後に更新された状態を確認できます。</li></ul><blockquote><p>ご参考情報:<br><strong>Resource Health の概要</strong><br><a href="https://learn.microsoft.com/ja-jp/azure/service-health/resource-health-overview">https://learn.microsoft.com/ja-jp/azure/service-health/resource-health-overview</a><br>　<br><strong>Microsoft.compute/virtualmachines</strong><br><a href="https://learn.microsoft.com/ja-jp/azure/service-health/resource-health-checks-resource-types#microsoftcomputevirtualmachines">https://learn.microsoft.com/ja-jp/azure/service-health/resource-health-checks-resource-types#microsoftcomputevirtualmachines</a></p></blockquote><p><code>&quot;microsoft.resourcehealth/resourceannotations&quot;</code>は、VM の可用性に変化があった場合、必要な障害属性を詳細に説明することで、ユーザーが必要に応じて状態を確認調査し、軽減できるようにします。</p><ul><li><strong>Downtime Annotations</strong>: プラットフォームが VM の可用性が Unavailable に遷移したことを検出すると発行されます。<ul><li>たとえば、予期しないホストのクラッシュ、リブートによる修復操作時など</li></ul></li><li><strong>Informational Annotations</strong>: VM の可用性に影響を与えない Azure 基盤に対する処理実施時に発行されます。<ul><li>VM の割り当て / 停止 / 削除 / 開始など</li><li>通常、これに対するお客様の追加アクションは必要ありません。</li></ul></li><li><strong>Degraded Annotations</strong>: VM の可用性が危険にさらされていることが検出されると発行されます。<ul><li>たとえば、故障予測モデルが、任意の時点で VM を再起動させる可能性のあるハードウェア・コンポーネントの劣化を予測した場合など</li><li>予期せぬデータ損失やダウンタイムを避けるため、アノテーション メッセージで指定された期限までに再デプロイするよう強く求めます。</li></ul></li></ul><blockquote><p>ご参考情報:<br><strong>Resource Health 仮想マシンの正常性に関する注釈</strong><br><a href="https://learn.microsoft.com/ja-jp/azure/service-health/resource-health-vm-annotation">https://learn.microsoft.com/ja-jp/azure/service-health/resource-health-vm-annotation</a></p></blockquote><p>なお、VM の停止 (割り当て解除) を行った場合には、次のような アノテーション イベントを検知することが可能となります。</p><p><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-04.png"></p><p>これらを用いることによりお客様の仮想マシンの可用性の状態を把握することが可能となります。</p><div class="alert is-info"><p class="alert-title">Note</p><p>将来的には、この HealthResources データセットに表示されるアノテーション・メタデータについて複数の機能強化が予定されています。</p><p>これらの機能強化により、ユーザーはより豊富な障害属性に確認することができるようになり、障害への対応策を決定的に準備することができるようになります。</p><p>これと並行して、履歴のルックバック期間を最低 30 日間に延長し、ユーザーが VM の可用性の過去の変化を包括的に追跡できるようにすることを目標としています。</p></div><h2 id="HealthResources-に対する便利な-クエリ"><a href="#HealthResources-に対する便利な-クエリ" class="headerlink" title="HealthResources に対する便利な クエリ"></a>HealthResources に対する便利な クエリ</h2><h3 id="可用性の状態とサブスクリプション-ID-別の仮想マシンの数"><a href="#可用性の状態とサブスクリプション-ID-別の仮想マシンの数" class="headerlink" title="可用性の状態とサブスクリプション ID 別の仮想マシンの数"></a>可用性の状態とサブスクリプション ID 別の仮想マシンの数</h3><p>各サブスクリプションの可用性の状態で集計された仮想マシン (種類 Microsoft.Compute/virtualMachines) の数を返します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type =~ &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">| summarize count() by subscriptionId, AvailabilityState = tostring(properties.availabilityState)</span><br></pre></td></tr></table></figure><p>実行結果:<br>Unknown の VM が1台あることが確認できます。<br><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-05.png"></p><h3 id="リソース-ID-別の仮想マシンおよび関連する可用性状態の一覧"><a href="#リソース-ID-別の仮想マシンおよび関連する可用性状態の一覧" class="headerlink" title="リソース ID 別の仮想マシンおよび関連する可用性状態の一覧"></a>リソース ID 別の仮想マシンおよび関連する可用性状態の一覧</h3><p>可用性の状態で集計された仮想マシン (種類 Microsoft.Compute/virtualMachines) の最新の一覧を返します。<br>また、このクエリでは、デバッグと軽減を容易にするため、properties.targetResourceId に基づいて関連付けられているリソース ID も提供されます。<br>可用性の状態は、4 つの値、Available、Unavailable、Degraded、Unknown のいずれかです。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type =~ &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">| summarize by ResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState)</span><br></pre></td></tr></table></figure><p>実行結果:<br>Unknown の対象 VM は先ほど停止を実施した VM であることが確認できました。<br><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-06.png"></p><h3 id="可用性状態と電源状態別の仮想マシンの一覧と、そのリソース-ID-およびリソース-グループ"><a href="#可用性状態と電源状態別の仮想マシンの一覧と、そのリソース-ID-およびリソース-グループ" class="headerlink" title="可用性状態と電源状態別の仮想マシンの一覧と、そのリソース ID およびリソース グループ"></a>可用性状態と電源状態別の仮想マシンの一覧と、そのリソース ID およびリソース グループ</h3><p>仮想マシンの正常性のまとまりのある状態を提供するために、電源状態と可用性状態で集計された仮想マシン (種類 Microsoft.Compute/virtualMachines) の一覧を返します。<br>また、このクエリでは、各エントリに関連付けられているリソース グループとリソース ID に関する詳細も提供され、リソースを詳細に表示できます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Resources</span><br><span class="line">| where type =~ &#x27;microsoft.compute/virtualmachines&#x27;</span><br><span class="line">| project resourceGroup, Id = tolower(id), PowerState = tostring( properties.extended.instanceView.powerState.code)</span><br><span class="line">| join kind=leftouter (</span><br><span class="line">    HealthResources</span><br><span class="line">    | where type =~ &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">    | where tostring(properties.targetResourceType) =~ &#x27;microsoft.compute/virtualmachines&#x27;</span><br><span class="line">    | project targetResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState))</span><br><span class="line">    on $left.Id == $right.targetResourceId</span><br><span class="line">| project-away targetResourceId</span><br><span class="line">| where PowerState != &#x27;PowerState/deallocated&#x27;</span><br></pre></td></tr></table></figure><p>実行結果:<br>停止 (割り当て解除) 状態の VM が除外され表示されます。<br><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-07.png"></p><h3 id="リソース-ID-別の使用できない仮想マシンの一覧"><a href="#リソース-ID-別の使用できない仮想マシンの一覧" class="headerlink" title="リソース ID 別の使用できない仮想マシンの一覧"></a>リソース ID 別の使用できない仮想マシンの一覧</h3><p>可用性の状態で集計された仮想マシン (種類 Microsoft.Compute/virtualMachines) の最新の一覧を返します。<br>表示された一覧では、可用性の状態が “Available” ではない仮想マシンだけが強調表示され、仮想マシンに関する状態すべてについて確実に認識できます。<br>すべての仮想マシンが使用可能な場合は、結果が表示されないことが想定できます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type =~ &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">| where tostring(properties.availabilityState) != &#x27;Available&#x27;</span><br><span class="line">| summarize by ResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState)</span><br></pre></td></tr></table></figure><p>実行結果:<br>Unavailable や Unknown ステータスの VM が表示されます。<br><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-08.png"></p><p>その他、次のようなクエリが利用可能です。</p><h3 id="プラットフォーム主導の計画外の正常性イベントによる影響を受けた可用性状態をもつリソースの一覧"><a href="#プラットフォーム主導の計画外の正常性イベントによる影響を受けた可用性状態をもつリソースの一覧" class="headerlink" title="プラットフォーム主導の計画外の正常性イベントによる影響を受けた可用性状態をもつリソースの一覧"></a>プラットフォーム主導の計画外の正常性イベントによる影響を受けた可用性状態をもつリソースの一覧</h3><p>Azure プラットフォームによって予期せず発生した計画外の中断の影響を受けた仮想マシンの最新の一覧を返します。<br>このクエリは、影響を受けたすべての仮想マシンを ID プロパティで集約し、対応する可用性状態と、特定の中断を要約した関連する注釈 (properties.reason) と共に返します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type == &quot;microsoft.resourcehealth/resourceannotations&quot;</span><br><span class="line">| where  properties.category == &#x27;Unplanned&#x27; and  properties.context != &#x27;Customer Initiated&#x27;</span><br><span class="line">| project ResourceId = tolower(tostring(properties.targetResourceId)), Annotation = tostring(properties.reason)</span><br><span class="line">| join (</span><br><span class="line">    HealthResources</span><br><span class="line">    | where type == &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">    | project ResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState))</span><br><span class="line">    on ResourceId</span><br><span class="line">| project ResourceId, AvailabilityState, Annotation</span><br></pre></td></tr></table></figure><h3 id="使用できないリソースとそれぞれの注釈詳細の一覧"><a href="#使用できないリソースとそれぞれの注釈詳細の一覧" class="headerlink" title="使用できないリソースとそれぞれの注釈詳細の一覧"></a>使用できないリソースとそれぞれの注釈詳細の一覧</h3><p>現在、使用可能な状態ではない仮想マシンの一覧を、ID プロパティで集約して返します。<br>また、このクエリによって、仮想マシンの実際の可用性状態と、使用できない理由を含む関連する詳細も示されます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type == &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">| where  properties.availabilityState != &#x27;Available&#x27;</span><br><span class="line">| project ResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState)</span><br><span class="line">| join ( </span><br><span class="line">     HealthResources</span><br><span class="line">    | where type == &quot;microsoft.resourcehealth/resourceannotations&quot;</span><br><span class="line">    | project ResourceId = tolower(tostring(properties.targetResourceId)), Reason = tostring(properties.reason), Context = tostring(properties.context), Category = tostring(properties.category))</span><br><span class="line">    on ResourceId</span><br><span class="line">| project ResourceId, AvailabilityState, Reason, Context, Category</span><br></pre></td></tr></table></figure><p>実行結果:<br><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-09.png"></p><h3 id="可用性の障害による影響を受けたリージョン内のリソースの数と、その影響の種類"><a href="#可用性の障害による影響を受けたリージョン内のリソースの数と、その影響の種類" class="headerlink" title="可用性の障害による影響を受けたリージョン内のリソースの数と、その影響の種類"></a>可用性の障害による影響を受けたリージョン内のリソースの数と、その影響の種類</h3><p>現在、使用可能な状態ではない仮想マシンの数を、ID プロパティで集約して返します。<br>また、クエリによって示される対応する場所と注釈の詳細には、VM が使用可能な状態ではない原因も含まれます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type == &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">| where  properties.availabilityState != &#x27;Available&#x27;</span><br><span class="line">| project ResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState), Location = location</span><br><span class="line">| join (</span><br><span class="line">    HealthResources</span><br><span class="line">    | where type == &quot;microsoft.resourcehealth/resourceannotations&quot;</span><br><span class="line">    | project ResourceId = tolower(tostring(properties.targetResourceId)), Context = tostring(properties.context), Category = tostring(properties.category), Location = location)</span><br><span class="line">    on ResourceId</span><br><span class="line">| summarize NumResources = count(ResourceId) by Location, Context, Category</span><br></pre></td></tr></table></figure><h3 id="特定の正常性イベントによる影響を受けるリソースの一覧と、影響時間、影響の詳細、可用性の状態、リージョン"><a href="#特定の正常性イベントによる影響を受けるリソースの一覧と、影響時間、影響の詳細、可用性の状態、リージョン" class="headerlink" title="特定の正常性イベントによる影響を受けるリソースの一覧と、影響時間、影響の詳細、可用性の状態、リージョン"></a>特定の正常性イベントによる影響を受けるリソースの一覧と、影響時間、影響の詳細、可用性の状態、リージョン</h3><p>VirtualMachineHostRebootedForRepair 注釈の影響を受ける仮想マシンの一覧を、その ID プロパティで集約して返します。<br>また、このクエリは、仮想マシンの対応する可用性状態、中断の時間、影響の原因を含む注釈の詳細を返します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type == &quot;microsoft.resourcehealth/resourceannotations&quot;</span><br><span class="line">| where properties.AnnotationName contains &#x27;VirtualMachineHostRebootedForRepair&#x27;</span><br><span class="line">| project ResourceId = tolower(tostring(properties.targetResourceId)), Reason = tostring(properties.reason), Context = tostring(properties.context), Category = tostring(properties.category), Location = location, Timestamp = tostring(properties.occurredTime)</span><br><span class="line">| join ( </span><br><span class="line">    HealthResources</span><br><span class="line">    | where type == &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">    | project ResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState), Location = location)</span><br><span class="line">    on ResourceId</span><br><span class="line">| project ResourceId, Reason, Context, Category, AvailabilityState, Timestamp</span><br></pre></td></tr></table></figure><h3 id="計画イベントによる影響を受けたリソースのリージョンごとの一覧"><a href="#計画イベントによる影響を受けたリソースのリージョンごとの一覧" class="headerlink" title="計画イベントによる影響を受けたリソースのリージョンごとの一覧"></a>計画イベントによる影響を受けたリソースのリージョンごとの一覧</h3><p>Azure プラットフォームによって実施された計画的なメンテナンスまたは修復操作の影響を受けた仮想マシンの一覧を、ID プロパティで集約して返します。<br>また、このクエリは、仮想マシンの対応する可用性状態、中断の時間、場所、影響の原因を含む注釈の詳細を返します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type == &quot;microsoft.resourcehealth/resourceannotations&quot;</span><br><span class="line">| where properties.category contains &#x27;Planned&#x27;</span><br><span class="line">| project ResourceId = tolower(tostring(properties.targetResourceId)), Reason = tostring(properties.reason), Location = location, Timestamp = tostring(properties.occuredTime)</span><br><span class="line">| join ( </span><br><span class="line">    HealthResources</span><br><span class="line">    | where type == &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">    | project ResourceId = tolower(tostring(properties.targetResourceId)), AvailabilityState = tostring(properties.availabilityState), Location = location)</span><br><span class="line">    on ResourceId</span><br><span class="line">| project ResourceId, Reason, AvailabilityState, Timestamp, Location</span><br></pre></td></tr></table></figure><h3 id="計画外のプラットフォーム中断の影響を受けたリソースの一覧と、可用性、電力状態、場所"><a href="#計画外のプラットフォーム中断の影響を受けたリソースの一覧と、可用性、電力状態、場所" class="headerlink" title="計画外のプラットフォーム中断の影響を受けたリソースの一覧と、可用性、電力状態、場所"></a>計画外のプラットフォーム中断の影響を受けたリソースの一覧と、可用性、電力状態、場所</h3><p>Azure プラットフォームによって実施された計画的なメンテナンスまたは修復操作の影響を受けた仮想マシンの一覧を、ID プロパティで集約して返します。<br>また、このクエリによって、仮想マシンの対応する可用性状態、電力状態、場所の詳細も示されます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HealthResources</span><br><span class="line">| where type =~ &#x27;microsoft.resourcehealth/resourceannotations&#x27;</span><br><span class="line">| where tostring(properties.context) == &#x27;Platform Initiated&#x27; and tostring(properties.category) == &#x27;Planned&#x27;</span><br><span class="line">| project ResourceId = tolower(properties.targetResourceId), Location = location</span><br><span class="line">| join (</span><br><span class="line">    HealthResources</span><br><span class="line">    | where type =~ &#x27;microsoft.resourcehealth/availabilitystatuses&#x27;</span><br><span class="line">    | project ResourceId = tolower(properties.targetResourceId), AvailabilityState = tostring(properties.availabilityState), Location = location)</span><br><span class="line">    on ResourceId</span><br><span class="line">| join (</span><br><span class="line">    Resources</span><br><span class="line">    | where type =~ &#x27;microsoft.compute/virtualmachines&#x27;</span><br><span class="line">    | project ResourceId = tolower(id), PowerState = properties.extended.instanceView.powerState.code, Location = location)</span><br><span class="line">    on ResourceId</span><br><span class="line">| project ResourceId, AvailabilityState, PowerState, Location</span><br></pre></td></tr></table></figure><p>次に Azure Monitor による VM の可用性メトリックを紹介します。</p><h2 id="Azure-Monitor-による-VM-の可用性メトリック-Preview"><a href="#Azure-Monitor-による-VM-の可用性メトリック-Preview" class="headerlink" title="Azure Monitor による VM の可用性メトリック (Preview)"></a>Azure Monitor による VM の可用性メトリック (Preview)</h2><p>VM 可用性についてのメトリックが取得できるようになりました。<br>このメトリックを用いることで、可用性が低下した場合に、しきい値ベースのメトリックアラートを設定し、適切な軽減措置を迅速にトリガーするよう設定することが可能となりました。</p><p><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-10.png"><br><img src="/blog/vm/vm-availability-monitoring-with-project-flash/vm-availability-monitoring-with-project-flash-11.png"></p><p>上記の結果より、VM を停止したことで可用性の低下が発生したことを確認できます。</p><h2 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h2><p>Azure ではこの Project Flash を通じて、お客様のエクスペリエンスの継続的な改善を目的とし監視プラットフォームの強化を実施してまいります。</p><p>以前は Azure 基盤で発生した問題について、何が起こったのかわからず大きな不安を抱えることもあったかと存じます。</p><p>Azure 基盤で発生した問題について、お客様の視認性を強化し、可能な限り迅速に情報提供をすることで、お客様への影響とご不安を最小限にするように引き続き信頼性向上に努めてまいります。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポート チームの鳥越です。&lt;/p&gt;
&lt;p&gt;2022年に Azure 仮想マシンの可用性の監視を進化するプロジェクトである Project Flash について、以下のブログで紹介されました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; &lt;strong&gt;Project Flash で Azure 仮想マシンの可用性の監視を進化させる&lt;/strong&gt;&lt;br&gt; &lt;a href=&quot;https://azure.microsoft.com/ja-jp/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash/&quot;&gt;https://azure.microsoft.com/ja-jp/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;このプロジェクトは Azure 仮想マシンに対して、お客様の可用性監視ニーズを満たすために、次のようなことが行えるように進められております。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VM の可用性障害 (VM のリブートや再起動のほか、ネットワーク ドライバーの更新によるアプリケーションのフリーズ、30 秒間のホスト OS の更新など) に関する正確で実用的なデータ、および障害の詳細 (プラットフォームのものかユーザー操作によるものか、リブートかフリーズか、計画的か非計画的かなど) を入手する。&lt;/li&gt;
&lt;li&gt;VM の可用性の傾向を分析してアラートを生成し、迅速なデバッグと前月比のレポート作成を実現する。&lt;/li&gt;
&lt;li&gt;データを定期的かつ大規模に監視し、カスタム ダッシュボードを作成して、すべてのリソースの最新の可用性状態について常に最新の情報を提供する。&lt;/li&gt;
&lt;li&gt;影響を受けた VM、ダウンタイムの原因および期間、結果的な修正などの詳細を示す自動根本原因分析 (RCA) を受け取り、ターゲットを絞った調査および事後分析を行えるようにする。&lt;/li&gt;
&lt;li&gt;VM の可用性に重大な変化があった場合、即座に通知を受け取り、迅速に修復アクションをトリガーし、エンドユーザーへの影響を防止する。&lt;/li&gt;
&lt;li&gt;刻々と変化するワークロードの感度やフェールオーバーのニーズに基づき、プラットフォームの回復ポリシーを動的に調整し、自動化する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;その中で、上記ブログではプレビューであった &lt;a href=&quot;https://learn.microsoft.com/ja-jp/azure/governance/resource-graph/overview&quot;&gt;Azure Resource Graph&lt;/a&gt; を用いた VM の可用性情報の監視が GA として公開され、Azure Monitor による VM 可用性メトリックがパブリック プレビューとして公開されました。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; &lt;strong&gt;New Project Flash Update: Advancing Azure Virtual Machine availability monitoring&lt;/strong&gt;&lt;br&gt; &lt;a href=&quot;https://azure.microsoft.com/en-us/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash-update/&quot;&gt;https://azure.microsoft.com/en-us/blog/advancing-azure-virtual-machine-availability-monitoring-with-project-flash-update/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;このブログでは、Azure Resource Graph を用いた VM の可用性情報がどのように利用できるのかを解説します。&lt;br&gt;本内容がお客様の VM の監視に少しでもお役に立てられれば幸いです。&lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Monitoring / Alert" scheme="https://jpaztech.github.io/blog/tags/Monitoring-Alert/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
  </entry>
  
  <entry>
    <title>Classic VM から ARM への移行についての注意事項 (VM、ストレージ編)</title>
    <link href="https://jpaztech.github.io/blog/vm/migrate_classic_vm_and_storage/"/>
    <id>https://jpaztech.github.io/blog/vm/migrate_classic_vm_and_storage/</id>
    <published>2022-12-29T08:30:00.000Z</published>
    <updated>2023-05-26T05:14:04.803Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポート チームの鳥越です。<br>2014年に Azure Resource Manager モデルがリリースされており、リタイアがアナウンスされた 2020 年 7 月時点ですでに 90% が Azure Resource Manager モデルで利用されておりました。</p><p>Azure 初期で利用されておりました Azure Service Manager (ASM) を介した IaaS 仮想マシン (VM) の管理を 2020 年 2 月 28 日 に 非推奨として <strong>2023 年 9 月 1 日</strong> に完全に廃止される予定です。</p><blockquote><p>■ ご参考: Migrate your IaaS resources to Azure Resource Manager by September 1, 2023<br><a href="https://learn.microsoft.com/en-us/azure/virtual-machines/classic-vm-deprecation">https://learn.microsoft.com/en-us/azure/virtual-machines/classic-vm-deprecation</a><br>(ご参考: 日本語 URL)<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/classic-vm-deprecation">https://learn.microsoft.com/ja-jp/azure/virtual-machines/classic-vm-deprecation</a></p></blockquote><div class="alert is-important"><p class="alert-title">重要</p><p><strong>(2023/01/27 Update)</strong>: 当初、2023 年 3 月 1日とご説明しておりました ASM の廃止は <strong>2023 年 9 月 1 日</strong> に延期されました。</p><p>現在これ以上の延期は計画されておりません。</p></div><p>そのため、これから 2023 年 9 月 1 日までに移行計画を立てていらっしゃるお客様に対して、移行がスムーズに行えるようにあらかじめ確認しておくべきポイントをお纏めしました。</p><p>本内容がお客様の移行作業に少しでもお役に立てば幸いでございます。</p><span id="more"></span><hr><h2 id="移行作業の全体像"><a href="#移行作業の全体像" class="headerlink" title="移行作業の全体像"></a>移行作業の全体像</h2><blockquote><p>■ ご参考: プラットフォームでサポートされているクラシックから Azure Resource Manager への移行に関する技術的な詳細<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/migration-classic-resource-manager-deep-dive">https://learn.microsoft.com/ja-jp/azure/virtual-machines/migration-classic-resource-manager-deep-dive</a></p></blockquote><p>Azure ではリソースの管理操作にかかわる Control Plane と実際のリソースに対する Data Plane が存在します。<br>ASM (Azure Service Manager) から ARM (Azure Resource Manager) への移行は Control Plane に対する操作となります。</p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image1.png"></p><p>原則として Data Plane はそのまま使用可能なので、ユーザー目線から見た場合、VM の動作状況や、ストレージアカウント上へのアクセスには影響がないように見えます。<br>しかしながら、移行非対応の機能のための構成変更に伴い、ユーザー目線でのダウンタイムが発生する可能性はございます。</p><p>たとえば、クラシック VM においては、「仮想ネットワークに配置されていない VM」という構成があり得ましたが、ARM における VM ではすべての仮想マシンが仮想ネットワーク上に配置されます。<br>従いまして、仮想ネットワークに配置されていないクラシック VM を、ARM に移行する場合、移行手順の途上で VM の停止が伴います。</p><p>また、移行中は、管理系の操作が行えないことも合わせてご理解いただく必要がございます。<br>例えば、VMのサイズ変更、開始、停止、再起動、再デプロイ、ディスクの構成変更、ネットワーク的な構成変更が実施できなくなる操作となります。<br>そのため、移行で問題が生じたときに、VM 側の操作ができないといった事態に陥る可能性もゼロではございません。</p><h3 id="移行をサポートしていないリソース"><a href="#移行をサポートしていないリソース" class="headerlink" title="移行をサポートしていないリソース"></a>移行をサポートしていないリソース</h3><p><img src="/blog/vm/migrate_classic_vm_and_storage/image2.png"></p><p><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/migration-classic-resource-manager-overview#unsupported-features-and-configurations">https://learn.microsoft.com/ja-jp/azure/virtual-machines/migration-classic-resource-manager-overview#unsupported-features-and-configurations</a></p><hr><p>全体的な移行の流れは下記の図のようになります。</p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image3.png"></p><h2 id="移行の事前準備-重要"><a href="#移行の事前準備-重要" class="headerlink" title="移行の事前準備 (重要)"></a>移行の事前準備 (重要)</h2><h3 id="1-クラシックリソースの操作に対応した、クラシック用の-Azure-PowerShell-を実施前にご用意ください。"><a href="#1-クラシックリソースの操作に対応した、クラシック用の-Azure-PowerShell-を実施前にご用意ください。" class="headerlink" title="(1) クラシックリソースの操作に対応した、クラシック用の Azure PowerShell を実施前にご用意ください。"></a>(1) クラシックリソースの操作に対応した、クラシック用の Azure PowerShell を実施前にご用意ください。</h3><p>クラシックリソース用の Azure PowerShell コマンドは、現行の ARM 対応の <code>AzureRM</code> や <code>Az</code> というモジュールではなく、<code>Azure</code> という名称で配布されています。<br>インストール方法は、以下の技術文書をご参照ください。</p><blockquote><p>■ ご参考: Azure PowerShell Service Management モジュールのインストール<br><a href="https://learn.microsoft.com/ja-jp/powershell/azure/servicemanagement/install-azure-ps?view=azuresmps-4.0.0">https://learn.microsoft.com/ja-jp/powershell/azure/servicemanagement/install-azure-ps?view=azuresmps-4.0.0 </a></p></blockquote><p>なお、クラシック Azure PowerShell によるリソース管理には、Azure サブスクリプションにおける <strong>従来の管理者</strong> の割り当てが必要になることにご注意ください。</p><blockquote><p>■ ご参考: Azure の従来のサブスクリプション管理者<br><a href="https://learn.microsoft.com/ja-jp/azure/role-based-access-control/classic-administrators">https://learn.microsoft.com/ja-jp/azure/role-based-access-control/classic-administrators</a></p></blockquote><p>多くの場合、移行が失敗した場合には、コマンドベースで回復作業を実施します。<br>そのため、事前にクラシックリソース用 Azure PowerShell を利用いただける環境をご用意いただけますと幸いです。</p><h3 id="2-クラシック-Azure-PowerShell-を用いて事前チェックをお願いいたします"><a href="#2-クラシック-Azure-PowerShell-を用いて事前チェックをお願いいたします" class="headerlink" title="(2) クラシック Azure PowerShell を用いて事前チェックをお願いいたします"></a>(2) クラシック Azure PowerShell を用いて事前チェックをお願いいたします</h3><p>たとえば、よくあるお問い合わせとして、ストレージアカウント内にディスクリソースが存在するためクラシックストレージアカウントの移行に失敗するといったお問い合わせがございます。</p><p>Portal 側の手順では、この点が考慮されていない部分がございますので、下記のように PowerShell を利用してチェックをいただけますと幸いです。<br>VM の移行が完了しておらず、クラシックストレージアカウントに VM で利用中のディスクリソースが残ってしまっていないかなどのチェック方法は以下のとおりです。</p><h4 id="2-1-ディスクがストレージ-アカウントに格納されている仮想マシンを移行する。"><a href="#2-1-ディスクがストレージ-アカウントに格納されている仮想マシンを移行する。" class="headerlink" title="(2-1) ディスクがストレージ アカウントに格納されている仮想マシンを移行する。"></a>(2-1) ディスクがストレージ アカウントに格納されている仮想マシンを移行する。</h4><p>次のコマンドは、ストレージ アカウント内のすべての VM ディスクの RoleName および DiskName プロパティを返します。RoleName はディスクが接続される仮想マシンの名前です。<br>このコマンドでディスクが返される場合、ストレージアカウントを移行する前にこれらのディスクが接続されている仮想マシンが移行されている必要があります。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$storageAccountName</span> = <span class="string">&#x27;yourStorageAccountName&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Get-AzureDisk</span> | <span class="built_in">where-Object</span> &#123;<span class="variable">$_</span>.MediaLink.Host.Contains(<span class="variable">$storageAccountName</span>)&#125; | <span class="built_in">Select-Object</span> <span class="literal">-ExpandProperty</span> AttachedTo <span class="literal">-Property</span> DiskName | <span class="built_in">Format-List</span> <span class="literal">-Property</span> RoleName, DiskName</span><br></pre></td></tr></table></figure><h4 id="2-2-ストレージ-アカウントに格納されている、接続されていない-VM-ディスクを削除する。"><a href="#2-2-ストレージ-アカウントに格納されている、接続されていない-VM-ディスクを削除する。" class="headerlink" title="(2-2) ストレージ アカウントに格納されている、接続されていない VM ディスクを削除する。"></a>(2-2) ストレージ アカウントに格納されている、接続されていない VM ディスクを削除する。</h4><p>次のコマンドを使用して、ストレージ アカウントの接続されていない VM のディスクを探します。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$storageAccountName</span> = <span class="string">&#x27;yourStorageAccountName&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Get-AzureDisk</span> | <span class="built_in">where-Object</span></span><br><span class="line">&#123;<span class="variable">$_</span>.MediaLink.Host.Contains(<span class="variable">$storageAccountName</span>)&#125; | <span class="built_in">Where-Object</span> <span class="literal">-Property</span> AttachedTo <span class="operator">-EQ</span> <span class="variable">$null</span> | <span class="built_in">Format-List</span> <span class="literal">-Property</span> DiskName</span><br></pre></td></tr></table></figure><p>上記のコマンドでディスクが返された場合、次のコマンドを使用してこれらのディスクを削除します。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Remove-AzureDisk</span> <span class="literal">-DiskName</span> <span class="string">&#x27;yourDiskName&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-ストレージ-アカウントに格納されている-VM-イメージを削除する。"><a href="#2-3-ストレージ-アカウントに格納されている-VM-イメージを削除する。" class="headerlink" title="(2-3) ストレージ アカウントに格納されている VM イメージを削除する。"></a>(2-3) ストレージ アカウントに格納されている VM イメージを削除する。</h4><p>次のコマンドは、ストレージ アカウントに格納されたすべての VM イメージと OS ディスクを返します。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-AzureVmImage</span> | <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span>.OSDiskConfiguration.MediaLink <span class="operator">-ne</span> <span class="variable">$null</span> <span class="operator">-and</span> <span class="variable">$_</span>.OSDiskConfiguration.MediaLink.Host.Contains(<span class="variable">$storageAccountName</span>)&#125; | <span class="built_in">Select-Object</span> <span class="literal">-Property</span> ImageName, ImageLabel</span><br></pre></td></tr></table></figure><p>次のコマンドは、ストレージ アカウントに格納されたすべての VM イメージとデータ ディスクを返します。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-AzureVmImage</span> | <span class="built_in">Where-Object</span> &#123;<span class="variable">$_</span>.DataDiskConfigurations <span class="operator">-ne</span> <span class="variable">$null</span> <span class="operator">-and</span> (<span class="variable">$_</span>.DataDiskConfigurations | <span class="built_in">Where-Object</span> &#123;<span class="variable">$_</span>.MediaLink <span class="operator">-ne</span> <span class="variable">$null</span> <span class="operator">-and</span> <span class="variable">$_</span>.MediaLink.Host.Contains(<span class="variable">$storageAccountName</span>)&#125;).Count <span class="operator">-gt</span> <span class="number">0</span> &#125; | <span class="built_in">Select-Object</span> <span class="literal">-Property</span> ImageName, ImageLabel</span><br></pre></td></tr></table></figure><p>次のコマンドを使用して、上記のコマンドによって返されるすべての VM イメージを削除します。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Remove-AzureVMImage</span> <span class="literal">-ImageName</span> <span class="string">&#x27;yourImageName&#x27;</span>  </span><br></pre></td></tr></table></figure><hr><h2 id="検証フェーズ-Validate"><a href="#検証フェーズ-Validate" class="headerlink" title="検証フェーズ (Validate)"></a>検証フェーズ (Validate)</h2><p>検証フェーズでは移行対象リソースが前提条件を満たしているのかチェックします。<br>ただし、この検証フェーズですべての前提条件がチェックされる訳ではない点に注意が必要です。</p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image4.png"><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/migration-classic-resource-manager-deep-dive#checks-not-done-in-the-validate-operation">https://learn.microsoft.com/ja-jp/azure/virtual-machines/migration-classic-resource-manager-deep-dive#checks-not-done-in-the-validate-operation</a></p><h2 id="準備フェーズ-Prepare"><a href="#準備フェーズ-Prepare" class="headerlink" title="準備フェーズ (Prepare)"></a>準備フェーズ (Prepare)</h2><p>準備フェーズでは、リソースの実体に対して、ASM 側にも ARM 側にもリソースが表示されるようになります。</p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image5.png"></p><p>このタイミングで管理系操作はロックされるため、Commit で実行フェーズに進むか Abort で強制終了するかのどちらかの作業が必要となります。</p><h3 id="準備フェーズでの重要な注意点"><a href="#準備フェーズでの重要な注意点" class="headerlink" title="準備フェーズでの重要な注意点"></a>準備フェーズでの重要な注意点</h3><p>注意点となりますが、ASM から ARM への移行に際し VM 単位で実施する場合に、Prepare -&gt; Commit の間に 4 分間の間隔を空けないと移行処理が失敗するという報告がございます。</p><p>このような状態に陥った場合、Portal での対処ができず、先にご案内しましたクラシック用の PowerShell により以下のコマンドで Commit を実行いただく必要がございます。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$serviceName</span> = <span class="string">&quot;My Service&quot;</span>   <span class="comment"># クラシック VM が配置されているクラウドサービス名に置き換えてください</span></span><br><span class="line"><span class="variable">$deployment</span> = <span class="built_in">Get-AzureDeployment</span> <span class="literal">-ServiceName</span> <span class="variable">$serviceName</span></span><br><span class="line"><span class="variable">$deploymentName</span> = <span class="variable">$deployment</span>.DeploymentName</span><br><span class="line"><span class="built_in">Move-AzureService</span> <span class="literal">-Commit</span> <span class="literal">-ServiceName</span> <span class="variable">$serviceName</span> <span class="literal">-DeploymentName</span> <span class="variable">$deploymentName</span></span><br></pre></td></tr></table></figure><h2 id="実行フェーズ-Commit"><a href="#実行フェーズ-Commit" class="headerlink" title="実行フェーズ (Commit)"></a>実行フェーズ (Commit)</h2><p>実行フェーズにてリソースの実体に対してクラシック側の参照が切り離される動作となります。</p><p>これにより ARM への移行が完了します。</p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image6.png"></p><hr><h2 id="ASM-から-ARM-に移行される際の-FAQ"><a href="#ASM-から-ARM-に移行される際の-FAQ" class="headerlink" title="ASM から ARM に移行される際の FAQ"></a>ASM から ARM に移行される際の FAQ</h2><p>公式ドキュメントとしては以下のご用意がございます。</p><blockquote><p>■ ご参考: クラシックから Azure Resource Manager への移行に関してよく寄せられる質問<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/migration-classic-resource-manager-faq">https://learn.microsoft.com/ja-jp/azure/virtual-machines/migration-classic-resource-manager-faq</a></p></blockquote><p>問題が発生した場合の対処コマンドについては、以下に記載させていただきます。</p><h3 id="Q1-移行の-Abort-はできますか？"><a href="#Q1-移行の-Abort-はできますか？" class="headerlink" title="Q1. 移行の Abort はできますか？"></a>Q1. 移行の Abort はできますか？</h3><p>移行作業をどうしても Abort したい場合には下記コマンドを実施ください。<br>デバッグ出力も併せて表示されますので、何らかのエラーが発生する場合は、デバッグ出力も添えて Azure サポート窓口へのお問い合わせをご検討ください。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$serviceName</span> = <span class="string">&quot;My Service&quot;</span>   <span class="comment"># クラシック VM が配置されているクラウドサービス名に置き換えてください</span></span><br><span class="line"><span class="variable">$deployment</span> = <span class="built_in">Get-AzureDeployment</span> <span class="literal">-ServiceName</span> <span class="variable">$serviceName</span>  </span><br><span class="line"><span class="variable">$deploymentName</span> = <span class="variable">$deployment</span>.DeploymentName  </span><br><span class="line"><span class="built_in">Move-AzureService</span> <span class="literal">-Abort</span> <span class="literal">-ServiceName</span> <span class="variable">$serviceName</span> <span class="literal">-DeploymentName</span> <span class="variable">$deploymentName</span> <span class="literal">-debug</span> <span class="literal">-verbose</span></span><br></pre></td></tr></table></figure><h3 id="Q2-ストレージアカウントを-Azure-PowerShell-で-Commit-する方法はありますか？"><a href="#Q2-ストレージアカウントを-Azure-PowerShell-で-Commit-する方法はありますか？" class="headerlink" title="Q2. ストレージアカウントを Azure PowerShell で Commit する方法はありますか？"></a>Q2. ストレージアカウントを Azure PowerShell で Commit する方法はありますか？</h3><p>移行作業でポータルから操作ができず、Azure PowerShell を利用して Commit が必要なケースが存在します。<br>そのような場合には以下のように Commit の実施をお願いいたします。<br>デバッグ出力も併せて表示されますので、何らかのエラーが発生する場合は、デバッグ出力も添えて Azure サポート窓口へのお問い合わせをご検討ください。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$storageAccountName</span> = <span class="string">&quot;myStorageAccount&quot;</span></span><br><span class="line"><span class="built_in">Move-AzureStorageAccount</span> <span class="literal">-Commit</span> <span class="literal">-StorageAccountName</span> <span class="variable">$storageAccountName</span> <span class="literal">-debug</span> <span class="literal">-verbose</span></span><br></pre></td></tr></table></figure><h3 id="Q3-VNET-を含んだ-VM-の移行で問題が発生したときはどうすればよいですか？"><a href="#Q3-VNET-を含んだ-VM-の移行で問題が発生したときはどうすればよいですか？" class="headerlink" title="Q3. VNET を含んだ VM の移行で問題が発生したときはどうすればよいですか？"></a>Q3. VNET を含んだ VM の移行で問題が発生したときはどうすればよいですか？</h3><p>VNET を含んだ VM の移行については今回割愛しておりますが、移行に問題が発生した際に、PowerShell を利用した切り分け作業の実施が必要となります。</p><p>上記のとおり、PowerShell 環境の事前の準備と問題が発生した際には <code>-debug</code> オプションと <code>-verbose</code> オプションを利用した原因調査の実施が必要となりますのであらかじめご承知おきいただけますと幸いです。</p><h3 id="Q4-移行がスタックした際にクラシック-VM-から新規-の-ARM-の-VM-を手動で作成できますか？"><a href="#Q4-移行がスタックした際にクラシック-VM-から新規-の-ARM-の-VM-を手動で作成できますか？" class="headerlink" title="Q4. 移行がスタックした際にクラシック VM から新規 の ARM の VM を手動で作成できますか？"></a>Q4. 移行がスタックした際にクラシック VM から新規 の ARM の VM を手動で作成できますか？</h3><p>移行が途中でスタックした際には、上述の通り管理操作を行うことができません。<br>そのため、VM の起動再開といった作業が実現できないこととなります。</p><p>この場合、VM で利用されていた VHD を利用して新たに VM を作成することで、スタックの状況を回避することが可能となります。<br>作業としては以下の流れで作業の実施をお願いいたします。</p><h4 id="4-1-コピー先-URL-を準備"><a href="#4-1-コピー先-URL-を準備" class="headerlink" title="(4-1) コピー先 URL を準備"></a>(4-1) コピー先 URL を準備</h4><h5 id="手順A-ARM-仮想マシン用のストレージ-アカウントを作成します。"><a href="#手順A-ARM-仮想マシン用のストレージ-アカウントを作成します。" class="headerlink" title="手順A. ARM 仮想マシン用のストレージ アカウントを作成します。"></a>手順A. ARM 仮想マシン用のストレージ アカウントを作成します。</h5><ol><li>Azure Portal より <strong>[ストレージ アカウント]</strong> を開き、<strong>[追加]</strong> をクリックします。<br>適宜値を設定し、ストレージ アカウントを作成します。</li><li>作成後、<strong>[ストレージ アカウント]</strong> - <strong>[&lt;当該ストレージ アカウント名&gt;]</strong> を選択し、左メニュー <strong>[Blob service]</strong> から <strong>[コンテナー]</strong> を選択します。</li><li><strong>[+ コンテナー]</strong> をクリックし <code>vhds</code> という名前でコンテナーを作成します。</li></ol><h5 id="手順B-VHD-ファイルをコピーするためのコピー先の-SAS-を発行します。"><a href="#手順B-VHD-ファイルをコピーするためのコピー先の-SAS-を発行します。" class="headerlink" title="手順B. VHD ファイルをコピーするためのコピー先の SAS を発行します。"></a>手順B. VHD ファイルをコピーするためのコピー先の SAS を発行します。</h5><ol><li><strong>手順A-1</strong> で作成した <strong>[&lt;当該ストレージ アカウント名&gt;]</strong> を選択し、左メニュー <strong>[設定]</strong> から <strong>[Shared Access Signature]</strong> を選択します。</li><li>適宜設定を行い、<strong>[SAS と接続文字列を生成する]</strong> をクリックします。</li><li><strong>[Blob service の SAS URL]</strong> をテキストエディタ等にコピーしておきます。</li></ol><h5 id="手順C-手順D-3-で取得した-URL-を下記のとおり編集し、テキスト-エディタ等にコピーしておきます。"><a href="#手順C-手順D-3-で取得した-URL-を下記のとおり編集し、テキスト-エディタ等にコピーしておきます。" class="headerlink" title="手順C. 手順D-3 で取得した URL を下記のとおり編集し、テキスト エディタ等にコピーしておきます。"></a>手順C. 手順D-3 で取得した URL を下記のとおり編集し、テキスト エディタ等にコピーしておきます。</h5><p><strong>編集前</strong>: <code>https://&#123;ストレージ アカウント名&#125;.blob.core.windows.net/?&#123;SAS&#125;</code><br><strong>編集後</strong>: <code>https://&#123;ストレージ アカウント名&#125;.blob.core.windows.net/vhds/&#123;コピー後の VHD ファイル名&#125;?&#123;SAS&#125;</code></p><p>コピー後の VHD ファイル名は「.vhd」拡張子となるようにご指定ください。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p>A から C の手順は、当初より公開しております以下の記事にも記載がございます。</p><p>Azure VM からエクスポートした VHD ファイルを用いた複製 VM の作成方法のページにおける</p><p><a href="https://jpaztech.github.io/blog/vm/create-vm-using-vhd/#1-%E3%82%B3%E3%83%94%E3%83%BC%E5%85%88%E3%81%AE%E3%82%B9%E3%83%88%E3%83%AC%E3%83%BC%E3%82%B8-%E3%82%A2%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88%E3%81%8A%E3%82%88%E3%81%B3%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E2%80%95%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B">[1] コピー先のストレージ アカウントおよびコンテナ―を作成する</a></p><p><a href="https://jpaztech.github.io/blog/vm/create-vm-using-vhd/#2-%E3%82%B3%E3%83%94%E3%83%BC%E5%85%88%E3%81%AE-SAS-%E3%82%92%E7%99%BA%E8%A1%8C%E3%81%99%E3%82%8B">[2] コピー先の SAS を発行する</a></p><p>の手順と同様です。</p><p>　</p><p>■ ご参考: Azure VM からエクスポートした VHD ファイルを用いた複製 VM の作成方法</p><p><a href="https://jpaztech.github.io/blog/vm/create-vm-using-vhd/">https://jpaztech.github.io/blog/vm/create-vm-using-vhd/</a></p></div><h4 id="4-2-コピー元のVMの停止"><a href="#4-2-コピー元のVMの停止" class="headerlink" title="(4-2) コピー元のVMの停止"></a>(4-2) コピー元のVMの停止</h4><h5 id="手順D-コピー元の仮想マシンを停止します。"><a href="#手順D-コピー元の仮想マシンを停止します。" class="headerlink" title="手順D. コピー元の仮想マシンを停止します。"></a>手順D. コピー元の仮想マシンを停止します。</h5><h4 id="4-3-コピー元-URL-を準備"><a href="#4-3-コピー元-URL-を準備" class="headerlink" title="(4-3) コピー元 URL を準備"></a>(4-3) コピー元 URL を準備</h4><p>事前に VM のディスクに関してスナップショットを取得します。</p><h5 id="手順E-クラシック仮想マシン-の-VHD-にてスナップショットを取得します。"><a href="#手順E-クラシック仮想マシン-の-VHD-にてスナップショットを取得します。" class="headerlink" title="手順E. クラシック仮想マシン の VHD にてスナップショットを取得します。"></a>手順E. クラシック仮想マシン の VHD にてスナップショットを取得します。</h5><ol><li>Azure Portal にて、<strong>[ストレージ アカウント]</strong> - <strong>[&lt;当該 (クラシック) ストレージアカウント名&gt;]</strong> を選択し、左メニュー <strong>[Blob service]</strong> から <strong>[コンテナー]</strong> を選択します。</li><li>スナップショットを作成します。<br> <strong>[vhds (コンテナー名)]</strong> - <strong>[&lt;ファイル名.vhd&gt;]</strong> の <strong>[…]</strong> をクリックし、<strong>[スナップショットの作成]</strong> をクリックします。</li><li>スナップショットを表示します。<br> <strong>[vhds (コンテナー名)]</strong> - <strong>[&lt;ファイル名.vhd&gt;]</strong> の <strong>[…]</strong> をクリックし、<strong>[スナップショットの表示]</strong> をクリックします。<br> 該当スナップショットの <strong>[…]</strong> をクリックし、ダブルクリックして表示される <strong>[スナップショットのプロパティ]</strong> から URL をテキスト エディタ等にコピーしておきます。</li></ol><h5 id="手順F-クラシック仮想マシンで作成した-VHD-ファイルをコピーするための-SAS-を発行します。"><a href="#手順F-クラシック仮想マシンで作成した-VHD-ファイルをコピーするための-SAS-を発行します。" class="headerlink" title="手順F. クラシック仮想マシンで作成した VHD ファイルをコピーするための SAS を発行します。"></a>手順F. クラシック仮想マシンで作成した VHD ファイルをコピーするための SAS を発行します。</h5><ol><li><strong>手順E-2, 3</strong> と同様に <strong>[vhds (コンテナー名)]</strong> - <strong>[&lt;ファイル名.vhd&gt;]</strong> の <strong>[…]</strong> をクリックし、<strong>[SAS の生成]</strong> をクリックします。</li><li>適宜設定を行い、<strong>[SAS トークンおよび URL を生成]</strong> をクリックします。</li><li><strong>[BLOB SAS トークン]</strong> をテキスト エディタ等にコピーしておきます。</li></ol><h5 id="手順G-コピー元の-URL-を合わせ、テキスト-エディタ等準備しておきます。"><a href="#手順G-コピー元の-URL-を合わせ、テキスト-エディタ等準備しておきます。" class="headerlink" title="手順G. コピー元の URL を合わせ、テキスト エディタ等準備しておきます。"></a>手順G. コピー元の URL を合わせ、テキスト エディタ等準備しておきます。</h5><p>スナップショットを AzCopy で複製する場合に、コピー元 URL を作成する手順は以下のようになります。</p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image7.png"></p><ol><li><p><strong>手順E-3</strong> で準備した URL を前半 (VHD のパスまで)、後半 (? マークから後ろ) に分けます。<br> <strong>例: 元々のスナップショットの URL が以下の場合</strong><br> <code>https://&#123;コピー元のストレージアカウント&#125;.blob.core.windows.net/vhds/&#123;ファイル名&#125;.vhd?snapshot=YYYY-MM-DDThhmm:ss.nnnnnnnZ</code></p><p> <strong>前半</strong>:<br> <code>https://&#123;コピー元のストレージアカウント&#125;.blob.core.windows.net/vhds/&#123;ファイル名&#125;.vhd</code></p><p> <strong>後半</strong> (? マークから後ろ):<br> <code>snapshot=YYYY-MM-DDThhmm:ss.nnnnnnnZ</code></p></li><li><p>（<strong>手順G-1</strong> の前半部分）＋ (?) + (SAS文字列) + (&amp;) +(<strong>手順G-1</strong> の後半部分）を連結し、以下のようなコピー元 URL を準備します。<br> <code>https://&#123;コピー元のストレージアカウント&#125;.blob.core.windows.net/vhds/&#123;ファイル名&#125;.vhd?&#123;SAS文字列&#125;&amp;snapshot=YYYY-MM-DDThh:mmss.nnnnnnnZ</code></p></li></ol><h4 id="4-4-AzCopy-コマンドで-VHD-ファイルをコピー"><a href="#4-4-AzCopy-コマンドで-VHD-ファイルをコピー" class="headerlink" title="(4-4) AzCopy コマンドで VHD ファイルをコピー"></a>(4-4) AzCopy コマンドで VHD ファイルをコピー</h4><h5 id="手順H-作業環境に-AzCopy-コマンドをダウンロードします。"><a href="#手順H-作業環境に-AzCopy-コマンドをダウンロードします。" class="headerlink" title="手順H. 作業環境に AzCopy コマンドをダウンロードします。"></a>手順H. 作業環境に AzCopy コマンドをダウンロードします。</h5><p>Azure Cloud Shell をご利用の場合、この手順は不要です。</p><blockquote><p>■ ご参考: AzCopy を使ってみる<br><a href="https://docs.microsoft.com/ja-jp/azure/storage/common/storage-use-azcopy-v10">https://docs.microsoft.com/ja-jp/azure/storage/common/storage-use-azcopy-v10</a></p></blockquote><h5 id="手順I-以下のようにコマンドを実行し、VHD-をコピーします。"><a href="#手順I-以下のようにコマンドを実行し、VHD-をコピーします。" class="headerlink" title="手順I. 以下のようにコマンドを実行し、VHD をコピーします。"></a>手順I. 以下のようにコマンドを実行し、VHD をコピーします。</h5><p><code>azcopy copy &quot;&#123;手順Gで準備したURLとファイル名.vhd?SAS文字列&amp;snapshot=日時を含む文字列&#125;&quot; &quot;&#123;手順CでコピーしたURL?SAS文字列&#125;&quot; --blob-type PageBlob</code></p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image8.png"></p><p>正常に転送が完了した場合は以下のような例の表示となります。</p><p><img src="/blog/vm/migrate_classic_vm_and_storage/image9.png"></p><p>これにより、ARM 環境のストレージアカウントに ASM 環境の VHD ファイルのコピーができました。</p><h4 id="4-5-vhdを元にディスクを作成、仮想マシンを作成"><a href="#4-5-vhdを元にディスクを作成、仮想マシンを作成" class="headerlink" title="(4-5) vhdを元にディスクを作成、仮想マシンを作成"></a>(4-5) vhdを元にディスクを作成、仮想マシンを作成</h4><h5 id="手順J-ARM-環境の仮想マシンを作成します。"><a href="#手順J-ARM-環境の仮想マシンを作成します。" class="headerlink" title="手順J. ARM 環境の仮想マシンを作成します。"></a>手順J. ARM 環境の仮想マシンを作成します。</h5><ol><li>Azure Portal より <strong>[ディスク]</strong> を開き、<strong>[+ 追加]</strong> をクリックします。</li><li>適宜設定を行い、<strong>[確認および作成]</strong> - <strong>[作成]</strong> をクリックします。<ol><li><code>ソースの種類</code> は <strong>[ストレージ BLOB]</strong> を選択します。</li><li><code>ソース BLOB</code> は <strong>手順C</strong> のストレージ アカウントの <code>vhds</code> にコピーした VHD ファイルを選択します。</li><li><code>OS の種類</code> は適宜選択します。<br><img src="/blog/vm/migrate_classic_vm_and_storage/image10.png"></li></ol></li><li>Azure Portal より作成した OS ディスクを開き、<strong>[+ VM の作成]</strong> をクリックします。</li><li>適宜設定を行い、<strong>[確認および作成]</strong> - <strong>[作成]</strong> をクリックします。</li></ol><h5 id="手順K-ARM-仮想マシンに接続し、必要に応じて動作を確認します。"><a href="#手順K-ARM-仮想マシンに接続し、必要に応じて動作を確認します。" class="headerlink" title="手順K. ARM 仮想マシンに接続し、必要に応じて動作を確認します。"></a>手順K. ARM 仮想マシンに接続し、必要に応じて動作を確認します。</h5><p>以上の手順で、移行がスタックした際にクラシック VM から新規 の ARM の VM を手動で作成することが可能となります。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p>J から K の手順は、当初より公開しております以下の記事にも記載がございます。</p><p>Azure VM からエクスポートした VHD ファイルを用いた複製 VM の作成方法のページにおける</p><p><a href="https://jpaztech.github.io/blog/vm/create-vm-using-vhd/#5-VHD-%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%8B%E3%82%89%E7%AE%A1%E7%90%86%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B">[5] VHD ファイルから管理ディスクを作成する</a></p><p><a href="https://jpaztech.github.io/blog/vm/create-vm-using-vhd/#6-VHD-%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%8B%E3%82%89%E4%BD%9C%E6%88%90%E3%81%97%E3%81%9F%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%81%A7-VM-%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B%E3%80%82">[6] VHD ファイルから作成したディスクで VM を作成する。</a></p><p>と同様です。</p><p>　</p><p>■ ご参考: Azure VM からエクスポートした VHD ファイルを用いた複製 VM の作成方法</p><p><a href="https://jpaztech.github.io/blog/vm/create-vm-using-vhd/">https://jpaztech.github.io/blog/vm/create-vm-using-vhd/</a></p></div><p>これらの記事の内容が皆様のお役にたてれば幸いでございます。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポート チームの鳥越です。&lt;br&gt;2014年に Azure Resource Manager モデルがリリースされており、リタイアがアナウンスされた 2020 年 7 月時点ですでに 90% が Azure Resource Manager モデルで利用されておりました。&lt;/p&gt;
&lt;p&gt;Azure 初期で利用されておりました Azure Service Manager (ASM) を介した IaaS 仮想マシン (VM) の管理を 2020 年 2 月 28 日 に 非推奨として &lt;strong&gt;2023 年 9 月 1 日&lt;/strong&gt; に完全に廃止される予定です。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;■ ご参考: Migrate your IaaS resources to Azure Resource Manager by September 1, 2023&lt;br&gt;&lt;a href=&quot;https://learn.microsoft.com/en-us/azure/virtual-machines/classic-vm-deprecation&quot;&gt;https://learn.microsoft.com/en-us/azure/virtual-machines/classic-vm-deprecation&lt;/a&gt;&lt;br&gt;(ご参考: 日本語 URL)&lt;br&gt;&lt;a href=&quot;https://learn.microsoft.com/ja-jp/azure/virtual-machines/classic-vm-deprecation&quot;&gt;https://learn.microsoft.com/ja-jp/azure/virtual-machines/classic-vm-deprecation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;[!IMPORTANT]&lt;br&gt;&lt;strong&gt;(2023/01/27 Update)&lt;/strong&gt;: 当初、2023 年 3 月 1日とご説明しておりました ASM の廃止は &lt;strong&gt;2023 年 9 月 1 日&lt;/strong&gt; に延期されました。&lt;br&gt;現在これ以上の延期は計画されておりません。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;そのため、これから 2023 年 9 月 1 日までに移行計画を立てていらっしゃるお客様に対して、移行がスムーズに行えるようにあらかじめ確認しておくべきポイントをお纏めしました。&lt;/p&gt;
&lt;p&gt;本内容がお客様の移行作業に少しでもお役に立てば幸いでございます。&lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Migration" scheme="https://jpaztech.github.io/blog/tags/Migration/"/>
    
    <category term="Storage" scheme="https://jpaztech.github.io/blog/tags/Storage/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes の監査ログで AKS クラスターで起こるすべてのことを追跡しよう</title>
    <link href="https://jpaztech.github.io/blog/containers/aks-kube-audit/"/>
    <id>https://jpaztech.github.io/blog/containers/aks-kube-audit/</id>
    <published>2022-12-24T06:00:00.000Z</published>
    <updated>2023-05-26T05:14:04.499Z</updated>
    
    <content type="html"><![CDATA[<p>この記事は <a href="https://qiita.com/advent-calendar/2022/microsoft-azure-tech">Microsoft Azure Tech Advent Calendar 2022</a> の 24 日目の記事になります🎅</p><p>こんにちは。Azure テクニカル サポートチームの桐井です。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/aks/intro-kubernetes">Azure Kubernetes Service (AKS)</a> のクラスターを利用しているときに、アプリケーションがデプロイされたタイミングや、ノードのステータスがいつどのような理由で変わったのかなど、過去にクラスターで起こったイベントの履歴を確認したい場合があります。Kubernetes の監査ログを活用すると、これらのイベントをログから確認できるようになります。</p><p>本記事では、Kubernetes の監査ログの紹介と、AKS において監査ログ利用する方法を、実例を交えて解説します。</p><span id="more"></span><hr><h2 id="Kubernetes-の監査ログ-kube-audit"><a href="#Kubernetes-の監査ログ-kube-audit" class="headerlink" title="Kubernetes の監査ログ (kube-audit)"></a>Kubernetes の監査ログ (kube-audit)</h2><p>Kubernetes のクラスターは大きく分けて、<strong>コントロール プレーン</strong> と <strong>ノード</strong> の 2 つのコンポーネントで構成されています。<br>クラスターに対する各種操作は、コントロール プレーンに存在する <strong><a href="https://kubernetes.io/ja/docs/concepts/overview/components/#kube-apiserver">API サーバー (kube-apiserver)</a></strong> が提供する Kubernetes API を介して行われます。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit01.png" alt="Kubernetes クラスターのアーキテクチャー"></p><p>クラスターの利用者が実行する <a href="https://kubernetes.io/ja/docs/reference/kubectl/overview/">kubectl コマンド</a>は、API サーバーに対してリクエストを送信することで、Pod をはじめとするクラスター内のオブジェクトの作成や変更をします。</p><p>また、ノード上で稼働する <a href="https://kubernetes.io/ja/docs/concepts/overview/components/#kubelet">kubelet</a> やシステム Pod、さらにはコントロール プレーンを構成するコンポーネントも、API サーバーに対してアクセスをしています。各コンポーネントが自身の役割を果たすことで、Kubernetes クラスターの動作が成り立っています。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p>たとえば、新しい Pod が作成された際には、<a href="https://kubernetes.io/ja/docs/concepts/overview/components/#kube-scheduler">kube-scheduler</a> が Pod のデプロイに最適なノードを決定し、その結果を API サーバーへ報告します。Pod が割り当てられたノードでは、kubelet が Pod の仕様を読み取り、その内容に従ってコンテナー ランタイムにコンテナーの起動を指示します。コンテナーの起動が成功すると、API サーバーに対して Pod ステータスの更新がリクエストされ、Pod が動作中であると記録します。</p></div><p>そのため、API サーバーにどのようなリクエストが届いて、そのレスポンス (実行結果) はどのような内容であったのか記録されたログがあれば、クラスターで過去に行われた操作や発生したイベントを追跡できます。</p><p>Kubernetes では<strong>監査ログ (kube-audit)</strong> 機能を利用することで、API サーバーのアクセス ログを得ることができます。監査ログには、クラスター内で行われた一連の操作が記録されています。</p><blockquote><p><strong>Kubernetesドキュメント / 監査</strong><br><a href="https://kubernetes.io/ja/docs/tasks/debug/debug-cluster/audit/">https://kubernetes.io/ja/docs/tasks/debug/debug-cluster/audit/</a></p></blockquote><h3 id="Kubernetes-の監査ログの内容"><a href="#Kubernetes-の監査ログの内容" class="headerlink" title="Kubernetes の監査ログの内容"></a>Kubernetes の監査ログの内容</h3><p>Kubernetes の監査ログの構造や、どのような情報が記録されているかについて、実例をもとに解説します。<br>ここでは、<code>kubectl get pod</code> コマンドで Pod の情報を取得した際のログを確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pod nginx</span></span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx   1/1     Running   0          6d4h</span><br></pre></td></tr></table></figure><p>コマンドを実行すると、<code>GET https://&#123;API Server FQDN&#125;:443/api/v1/namespaces/default/pods/nginx</code> のように、API サーバーに対して HTTPS のリクエストが送信されます。</p><p>API サーバーは、リクエストにしたがって必要な処理を行い、クライアントへレスポンスを返します。そして、監査ログにその記録を出力します。監査ログは JSON 形式で出力されます。</p><blockquote><p><strong>Kubernetes Documentation / Reference / Configuration APIs / kube-apiserver Audit Configuration (v1) - Event</strong><br><a href="https://kubernetes.io/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event">https://kubernetes.io/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event</a></p></blockquote><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit02.png" alt="Pod の情報を取得した際の kube-audit ログの例"></p><p>このログから、次のことがわかります。ログの該当箇所を抜粋して解説します。</p><h4 id="WHAT-何が起きたのか？"><a href="#WHAT-何が起きたのか？" class="headerlink" title="WHAT: 何が起きたのか？"></a>WHAT: 何が起きたのか？</h4><p><code>&quot;verb&quot;</code> は <a href="https://kubernetes.io/docs/reference/using-api/api-concepts/#single-resource-api">Kubernetes API verbs</a> を表します。個々の Pod のように、単一のオブジェクトに対して行われた操作では、get、 create、 apply、 update、 patch、 delete、 proxy といった verb が使用されます。<br>この情報から、オブジェクトの作成・削除といった、どのような操作が実行されたか判断できます。</p><p>この例では、<code>nginx</code> Pod の情報を取得したため <code>&quot;get&quot;</code> が記録されています。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;verb&quot;</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WHEN-いつ起こったのか？"><a href="#WHEN-いつ起こったのか？" class="headerlink" title="WHEN: いつ起こったのか？"></a>WHEN: いつ起こったのか？</h4><p>タイムスタンプの情報から、そのイベントがいつ起こったのかがわかります。</p><p><code>&quot;requestReceivedTimestamp&quot;</code>は、クライアントからのリクエストが API サーバーに到着した日時です。</p><p>監査ログは、API サーバーがリクエストを処理する<a href="https://kubernetes.io/docs/tasks/debug/debug-cluster/audit/">段階 (stage)</a> ごとに出力されます。<br>この例では、<code>&quot;stage&quot;</code>は<code>&quot;ResponseComplete&quot;</code>と記録されています。API サーバーがクライアントにレスポンスを転送し終わった際のログとなっており、<code>&quot;stageTimestamp&quot;</code>はレスポンスが完了した日時を表します。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;stage&quot;</span>: <span class="string">&quot;ResponseComplete&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;requestReceivedTimestamp&quot;</span>: <span class="string">&quot;2022-12-18T07:21:50.6437530Z&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;stageTimestamp&quot;</span>: <span class="string">&quot;2022-12-18T07:21:50.6480500Z&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WHO-誰がその操作を始めたのか？"><a href="#WHO-誰がその操作を始めたのか？" class="headerlink" title="WHO: 誰がその操作を始めたのか？"></a>WHO: 誰がその操作を始めたのか？</h4><p><code>&quot;user&quot;</code> の情報から、どのユーザーが行った操作であるか特定できます。<br>AKS では、<a href="https://learn.microsoft.com/ja-jp/Azure/aks/control-kubeconfig-access#available-cluster-roles-permissions"><code>az aks get-credentials</code> コマンドで取得した資格情報</a>を使ってクラスターを操作した場合に <code>&quot;user.username&quot;</code> が <code>&quot;masterclient&quot;</code> となります。</p><p><code>&quot;userAgent&quot;</code> にはリクエストを送信したクライアントの <a href="https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/User-Agent">User Agent</a> の情報が記録されます。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;user&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;masterclient&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;groups&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;system:masters&quot;</span>,</span><br><span class="line">      <span class="string">&quot;system:authenticated&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;userAgent&quot;</span>: <span class="string">&quot;kubectl/v1.26.0 (linux/amd64) kubernetes/b46a3f8&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>たとえば、<a href="https://learn.microsoft.com/ja-jp/azure/aks/kubernetes-portal?tabs=azure-cli">Azure Portal から AKS クラスター内のリソースにアクセス</a>した場合には、<code>&quot;userAgent&quot;</code> は次のように Web ブラウザーからのアクセスを示す文字列となります。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;userAgent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1462.54&quot;</span>,</span><br></pre></td></tr></table></figure><p>User Agent を調べることで、クラスター上にデプロイされているツールやコントローラーによる操作も特定できます。<br>次の例では、<a href="https://kubernetes.github.io/ingress-nginx/">NGINX Ingress Controller</a>のコントローラー Pod からリクエストされた操作であることがわかります。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;userAgent&quot;</span>: <span class="string">&quot;nginx-ingress-controller/v1.4.0 (linux/amd64) ingress-nginx/50be2bf95fd1ef480420e2aa1d6c5c7c138c95ea&quot;</span>,</span><br></pre></td></tr></table></figure><h4 id="WHERE-どこから操作をされたのか？"><a href="#WHERE-どこから操作をされたのか？" class="headerlink" title="WHERE: どこから操作をされたのか？"></a>WHERE: どこから操作をされたのか？</h4><p><code>&quot;sourceIPs&quot;</code> にはリクエスト元の IP アドレスが記録されます。IP アドレスを調べることによって、操作がどこから行われたのか特定できます。<br>(次の例では<a href="https://www.rfc-editor.org/rfc/rfc5737">例示用 IP アドレス</a>に置き換えています)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;sourceIPs&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;203.0.113.10&quot;</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WHAT-何に対する操作が行われたのか？"><a href="#WHAT-何に対する操作が行われたのか？" class="headerlink" title="WHAT: 何に対する操作が行われたのか？"></a>WHAT: 何に対する操作が行われたのか？</h4><p><code>&quot;requestURI&quot;</code> はクライアントから API サーバーに送信されたリクエスト URI を示します。</p><p><code>&quot;objectRef&quot;</code> (<a href="https://kubernetes.io/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-ObjectReference">Object Reference</a>) は、操作のターゲットとなったオブジェクトを表します。</p><p>次の例では、<code>&quot;default&quot;</code> ネームスペースに存在する <code>&quot;pods&quot;</code> リソースで、名前が <code>&quot;nginx&quot;</code> であるオブジェクトが操作対象であったことがわかります。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;requestURI&quot;</span>: <span class="string">&quot;/api/v1/namespaces/default/pods/nginx&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;objectRef&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;resource&quot;</span>: <span class="string">&quot;pods&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;namespace&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;nginx&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;apiVersion&quot;</span>: <span class="string">&quot;v1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="操作の結果はどうなったのか"><a href="#操作の結果はどうなったのか" class="headerlink" title="操作の結果はどうなったのか"></a>操作の結果はどうなったのか</h4><p><code>&quot;responseStatus&quot;</code> は、API サーバーがクライアントに返したレスポンス ステータスを表します。</p><p>次の例では、リクエスト対象の Pod がクラスターに存在し、Pod の情報を応答することが成功した (HTTP Status 200) ことがわかります。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;responseStatus&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="number">200</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>リクエストがエラーとなった場合には、エラーの内容を示すステータスが記録されます。<br>次の例では、存在しない Pod の情報を取得しようとしたために、HTTP Status 404 が返されたことがわかります。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;requestURI&quot;</span>: <span class="string">&quot;/api/v1/namespaces/default/pods/nginxxxxxx&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;responseStatus&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;Failure&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;NotFound&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="number">404</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="API-リクエストとレスポンスのオブジェクト内容"><a href="#API-リクエストとレスポンスのオブジェクト内容" class="headerlink" title="API リクエストとレスポンスのオブジェクト内容"></a>API リクエストとレスポンスのオブジェクト内容</h4><p><code>&quot;requestObject&quot;</code> には、クライアントから API サーバーに送信されたリクエストの内容が記録されています。Pod や Deployment といったオブジェクトを作成する際には、YAML 形式のマニフェスト ファイルに記載した内容が記録されます。監査ログ上では JSON 形式で記録されますが、フィールド名や値、オブジェクトの構造は YAML 形式の場合と同様です。<br>ノードや Pod などのステータスが更新された場合には、更新が必要な情報 (フィールド) のみを抜粋した patch リクエストが行われる場合もあります。</p><p>次の例は、Deployment を作成した際のログの抜粋です。<code>spec.replicas</code> に Pod のレプリカ数が指定されていることがわかります。Deployment オブジェクトはまだ作成されていない状態のため、作成日時のタイムスタンプは <code>null</code> です。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;requestObject&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;Deployment&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;apiVersion&quot;</span>: <span class="string">&quot;apps/v1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;azure-vote-back&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;namespace&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;creationTimestamp&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;spec&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;replicas&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&quot;responseObject&quot;</code> には、API サーバーからクライアントへ返されたレスポンスの内容が記録されています。</p><p>次の例は、Deployment の作成リクエストに対するレスポンスです。Deployment オブジェクトが作成されたため、作成日時のタイムスタンプ情報があり、オブジェクトの <code>&quot;uid&quot;</code> が割り当てられていることが確認できます。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;responseObject&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;Deployment&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;apiVersion&quot;</span>: <span class="string">&quot;apps/v1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;azure-vote-back&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;namespace&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;uid&quot;</span>: <span class="string">&quot;b5154018-c171-4155-8d95-2a1866a25a6b&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;resourceVersion&quot;</span>: <span class="string">&quot;144810978&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;generation&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;creationTimestamp&quot;</span>: <span class="string">&quot;2022-12-19T11:13:27.0000000Z&quot;</span>,</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このように、監査ログには、API サーバーにリクエストされた操作の内容やリクエストの発生元、そしてその結果となるレスポンスがどうなったのかについて情報が記録されています。</p><p>前述のとおり、クラスターに対する操作は、クラスターの利用者の操作、ツール / Kubernetes のコントローラーの自動化処理など、すべて API サーバーに対してリクエストが送信されます。<br>監査ログをみることで、どのような操作が行われたのかを追跡でき、過去にクラスターで何が起こったのかを手に取るように把握できます。</p><h2 id="AKS-クラスターの監査ログ出力を設定する"><a href="#AKS-クラスターの監査ログ出力を設定する" class="headerlink" title="AKS クラスターの監査ログ出力を設定する"></a>AKS クラスターの監査ログ出力を設定する</h2><p>監査ログの出力を有効化するには、kube-apiserver に対して設定が必要となります。<br>AKS はマネージドの Kubernetes サービスであるため、ご利用者様において kube-apiserver の設定を直接変更することはできませんが、AKS クラスター (managedCluster) リソースの<a href="https://learn.microsoft.com/ja-jp/azure/azure-monitor/essentials/resource-logs"><strong>診断設定</strong></a>を構成することで、Kubernetes の監査ログを Log Analytics ワークスペースやストレージ アカウントに送信できます。</p><blockquote><p><strong>AKS データの監視に関するリファレンス - リソース ログ</strong><br><a href="https://learn.microsoft.com/ja-jp/azure/aks/monitor-aks-reference#resource-logs">https://learn.microsoft.com/ja-jp/azure/aks/monitor-aks-reference#resource-logs</a></p></blockquote><p>Azure ポータルでは、対象となる AKS クラスターを開いたあと、左に表示されるメニューの <strong>[診断設定]</strong> の画面から設定できます。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit03.png" alt="ポータルの左メニューから[診断設定]を開きます"></p><p>診断設定の作成画面では、設定につける名前とログのカテゴリ、ログの転送先の選択をします。<br>次の例では、Kubernetes の監査ログを Log Analytics ワークスペースへ送信するように設定しています。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit04.png" alt="新しい診断設定を作成します"></p><p>監査ログに該当するカテゴリには、<strong>Kubernetes Audit</strong> と <strong>Kubernetes Audit Admin Logs</strong> の 2 つが存在します。それぞれ、次の違いがあります。</p><ul><li><strong>Kubernetes Audit (kube-audit)</strong><ul><li>get、list、create、update、delete、patch、post を含む、すべての監査イベントのログを出力します</li></ul></li><li><strong>Kubernetes Audit Admin Logs (kube-audit-admin)</strong><ul><li>Kubernetes Audit (kube-audit) カテゴリのログから、get および list の監査イベント (参照系のイベント) を除外したログを出力します</li></ul></li></ul><p>Kubernetes クラスターの動作は、さまざまなコントローラー (ソフトウェア) がリソース オブジェクトを操作することによって成り立っています。そのため、オブジェクトの get や list、watch といったリクエストが継続的に発生しています。<strong>Kubernetes Audit</strong> カテゴリは、コントローラーによる参照系リクエストもふくめ、すべてのイベントのログが出力されます。</p><p>一方、クラスターに対する変更系の操作のみを追跡したいというシナリオでは、get や list といった参照系のログは必要ないということがあります。その場合、<strong>Kubernetes Admit Admin Logs</strong> を選択することで、ログの数を大幅に削減でき、Log Analytics ワークスペースやストレージ アカウントの容量・料金の節約になります。</p><p>診断設定で出力できる AKS クラスターのリソース ログについては、次のドキュメントに一般的な推奨事項が記載されていますので、あわせてご参照ください。</p><blockquote><p><strong>Azure Monitor のコンテナー正常性機能を使用して Azure Kubernetes Service (AKS) を監視する - リソース ログを収集する</strong><br><a href="https://learn.microsoft.com/ja-jp/azure/aks/monitor-aks#collect-resource-logs">https://learn.microsoft.com/ja-jp/azure/aks/monitor-aks#collect-resource-logs</a><br>　<br>このドキュメントでは、kube-audit を Azure ストレージへ転送し、kube-audit-admin を Log Analytics ワークスペースへ転送する構成が紹介されています。</p></blockquote><h3 id="監査ログの取得方法"><a href="#監査ログの取得方法" class="headerlink" title="監査ログの取得方法"></a>監査ログの取得方法</h3><p>診断設定で Log Analytics ワークスペースへ送信したログは、Azure ポータルの <a href="https://portal.azure.com/#view/Microsoft_Azure_Monitoring/AzureMonitoringBrowseBlade/~/overview"><strong>[モニター]</strong></a> 画面から、<a href="https://learn.microsoft.com/ja-jp/azure/azure-monitor/logs/log-query-overview">Kusto クエリ</a>を実行することで取得できます。</p><p>左のメニューから <strong>[ログ]</strong> 画面へ移動し、ログの出力先の Log Analytics ワークスペースを選択して新しいクエリを実行します。</p><p>診断設定のログは <strong>AzureDiagnostics</strong> テーブルに格納されています。<br><code>Category</code> カラムの値が <code>kube-audit</code> となっているログを絞り込むことで、Kubernetes の監査ログが取得できます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AzureDiagnostics </span><br><span class="line">| where Category == &quot;kube-audit&quot;</span><br><span class="line">| take 10</span><br></pre></td></tr></table></figure><p>次のスクリーンショットは、クエリを実行してログを取得した画面です。<code>log_s</code> カラムに、Kubernetes の監査ログが JSON 形式で記録されています。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit05.png" alt="AzureDiagnostics テーブルで Category が &quot;kube-audit&quot; のログを取得します"></p><p><code>log_s</code> カラムの値を <a href="https://learn.microsoft.com/ja-jp/azure/data-explorer/kusto/query/parsejsonfunction">parse_json()</a> 関数で変換することで、監査ログ内部の値にアクセスしやすくなります。<br><a href="https://learn.microsoft.com/ja-jp/azure/data-explorer/kusto/query/extendoperator">extend 演算子</a>でログの項目ごとに新しい列を作成しておくと、クエリに検索条件を追加する際に便利です。また、必要な列のみに絞ってログを表示することが可能になります。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AzureDiagnostics </span><br><span class="line">| where Category == &quot;kube-audit&quot;</span><br><span class="line">| extend audit = parse_json(log_s)</span><br><span class="line">| extend Method = audit.verb</span><br><span class="line">| extend RequestURI = audit.requestURI</span><br><span class="line">| extend RequestObject = audit.requestObject</span><br><span class="line">| extend ResponseObject = audit.responseObject</span><br><span class="line">| extend ResponseStatusCode = audit.responseStatus.code</span><br><span class="line">| extend UserAgent = audit.userAgent</span><br><span class="line">| extend User = audit.user.username</span><br><span class="line">| project TimeGenerated, Method, ResponseStatusCode, RequestURI, User, UserAgent, RequestObject, ResponseObject</span><br><span class="line">| order by TimeGenerated asc</span><br></pre></td></tr></table></figure><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit06.png" alt="extend 演算子を使用したクエリ結果"></p><h2 id="クエリとログの例"><a href="#クエリとログの例" class="headerlink" title="クエリとログの例"></a>クエリとログの例</h2><p>ここまでの手順で、AKS クラスターの監査ログを Log Analytics ワークスペースへ転送し、クエリの実行でログ取得ができるようになりました。</p><p>ここでは 4 つのシナリオをもとに、監査ログの情報を取得する例を紹介します。</p><h3 id="シナリオ-1-アプリケーション-Pod-Deployment-の作成履歴を確認する"><a href="#シナリオ-1-アプリケーション-Pod-Deployment-の作成履歴を確認する" class="headerlink" title="シナリオ 1: アプリケーション (Pod/Deployment) の作成履歴を確認する"></a>シナリオ 1: アプリケーション (Pod/Deployment) の作成履歴を確認する</h3><p>AKS クラスターにアプリケーションをデプロイした際のログを見てみましょう。<a href="https://learn.microsoft.com/ja-jp/azure/aks/tutorial-kubernetes-deploy-application">AKS チュートリアル</a>で使用されている azure-vote アプリケーションをクラスターにデプロイし、Kubernetes の監査ログからDeployment の作成履歴を確認します。</p><p><code>kubectl</code> コマンドでアプリケーションの YAML マニフェストをクラスターに適用します。次のコマンド例では Deployment と Service が2つずつ作成されています。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f azure-vote-all-in-one-redis.yaml</span></span><br><span class="line">deployment.apps/azure-vote-back created</span><br><span class="line">service/azure-vote-back created</span><br><span class="line">deployment.apps/azure-vote-front created</span><br><span class="line">service/azure-vote-front created</span><br></pre></td></tr></table></figure><p>次のクエリ例では、監査ログ (<code>audit</code>) 内に <code>&quot;azure-vote&quot;</code> の文字列を含むログを抽出しています。<br>その他の条件として、create リクエスト (<code>Method</code>)、kubectl コマンドからのアクセス (<code>UserAgent</code>) を指定しています。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AzureDiagnostics </span><br><span class="line">| where Category == &quot;kube-audit&quot;</span><br><span class="line">| extend audit = parse_json(log_s)</span><br><span class="line">| extend Method = audit.verb</span><br><span class="line">| extend RequestURI = audit.requestURI</span><br><span class="line">| extend RequestObject = audit.requestObject</span><br><span class="line">| extend ResponseObject = audit.responseObject</span><br><span class="line">| extend ResponseStatusCode = audit.responseStatus.code</span><br><span class="line">| extend UserAgent = audit.userAgent</span><br><span class="line">| extend User = audit.user.username</span><br><span class="line">| where audit contains &quot;azure-vote&quot;     // 監査ログ内に &quot;azure-vote&quot; の文字列を含む</span><br><span class="line">| where Method == &quot;create&quot;              // create リクエスト</span><br><span class="line">| where UserAgent contains &quot;kubectl&quot;    // クライアントが kubectl のログ</span><br><span class="line">| project TimeGenerated, Method, ResponseStatusCode, RequestURI, User, UserAgent, RequestObject, ResponseObject</span><br><span class="line">| order by TimeGenerated asc</span><br></pre></td></tr></table></figure><p>クエリを実行すると、次のスクリーンショットのようにログが取得されました。ログの内容を表示された順に上から確認してみましょう。</p><p>まずは、 API サーバーに対して、<code>2022-12-19 11:13:27 (UTC)</code> に <code>/apis/apps/v1/namespace/default/deployments</code> のパスに <code>create</code> リクエストが送信されたことがわかります。</p><p><code>User</code> カラムの情報から、<code>az aks get-credentials</code> コマンドで取得した AKS クラスターの資格情報 (<code>masterclient</code>) が使用されていることがわかります。また、<code>UserAgent</code> カラムの情報から、<code>kubectl</code> コマンドによる操作が実行されたことがわかります。</p><p><code>RequestObject</code> には Deployment の YAML マニフェストの内容が記録されています。<code>spec</code> には Deployment の仕様が記録されており、Pod のレプリカ数 (<code>spec.replicas</code>) や Pod テンプレート (<code>spec.template</code>) の内容が含まれていることが確認できます。 </p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit07.png" alt="Deployment オブジェクトの作成ログ"></p><p>Kubernetes では、Deployment オブジェクトが作成・更新されると、その内容をもとに ReplicaSet オブジェクトが作成されます。そして、指定されたレプリカの数だけ Pod オブジェクトが作成されます。この動作は、Kubernetes クラスターを構成するコントローラーによって自動的に行われます。</p><p>上記のクエリ例では、人によって開始された Deployment 作成のログを確認しましたが、コントローラーによる自動処理についても Kubernetes の監査ログから確認できます。<br>作成した Deployment から最終的に Pod が起動するまでの様子を、実際に監査ログから追ってみましょう。ここでは、ReplicaSet が作成される箇所は割愛し、最終的に Pod が作成される様子を紹介します。</p><p>先ほど使用したクエリの条件 (kubectl によるリクエスト) を削除して、ログ内に <code>&quot;azure-vote&quot;</code> の文字列を含む create リクエストのすべてを検索します。すると、<code>/api/v1/namespaces/default/pods</code> パスに対する create リクエストが確認できます。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit08.png" alt="Pod オブジェクトの作成ログ"></p><p><code>User</code> および <code>UserAgent</code> から、<a href="https://kubernetes.io/ja/docs/concepts/overview/components/#kube-controller-manager">kube-controller-manager</a> 内の ReplicaSet Controller によって、Pod の作成がリクエストされたことがわかります。</p><p>Deployment の場合と同様に、<code>ResponseObject</code> には Pod のデプロイ内容が記録されています。<code>metadata.name</code> の情報から、<code>azure-vote-back-59d587dbb7-pjkxr</code> という名前で Pod が作成されたことがわかります。<br>また、<code>status.phase</code> が <code>Pending</code> となっています。この時点では Pod がノードにスケジューリングされておらず、ステータスが <code>Pending</code> の状態であったことがわかります。</p><p>Pod の名前が特定できました。この Pod 名を <code>RequestURI</code> に含むログを検索してみましょう。クエリを実行すると、次のリクエストのログが表示されました。</p><ul><li><code>create /api/v1/namespaces/default/pods/azure-vote-back-59d587dbb7-pjkxr/binding</code> <strong>(binding)</strong></li><li><code>patch /api/v1/namespaces/default/pods/azure-vote-back-59d587dbb7-pjkxr/status</code> <strong>(status)</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| where RequestURI contains &quot;azure-vote-back-59d587dbb7-pjkxr&quot;  // Pod 名を指定</span><br></pre></td></tr></table></figure><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit09.png" alt="ノードの割り当てと Pod ステータスが更新された際のログ"></p><p><code>RequestURI</code> の末尾が <code>/binding</code> のログは、Pod がノードにスケジューリングされた際のリクエストです。<code>UserAgent</code> から kube-scheduler によるリクエストであることが確認できます。<br>また、<code>RequestObject.target</code> の情報から、Pod がノード <code>aks-nodepool2-20356098-vmss000001</code> に割り当てられたことがわかります。</p><p><code>RequestURI</code> の末尾が <code>/status</code> のログは、Pod のステータス情報が更新された際のリクエストです。<code>User</code> と <code>UserAgent</code> から、Pod がスケジューリングされたノード <code>aks-nodepool2-20356098-vmss000001</code> の kubelet から送信されたことが確認できます。</p><p>ノード上の kubelet は、コンテナー ランタイムにコンテナーの起動を指示し、その結果を API サーバーに送信する役割を持っています。コンテナーの状態にあわせて Pod のステータスを更新しています (<code>Method</code> も <code>create</code> ではなく <code>patch</code> となっています)。</p><p><code>RequestObject</code> の <code>status</code> の情報が、kubelet から報告された Pod の状態になります。<code>status.phase</code> より、Pod が <code>Running</code> ステータスになったことがわかります。また、Pod に割り当てられた IP アドレスの情報も確認できます。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p>create リクエストでは、作成するオブジェクトがまだ存在しないため、<code>RequestURI</code> にはオブジェクト名が含まれません。たとえば、Pod の作成では <code>/api/v1/namespaces/default/pods</code> に対して create リクエストが送信され、Pod 名などの情報は <code>RequestObject</code> に含まれています。</p><p>　</p><p>オブジェクトが作成された後は、オブジェクト名を含む <code>RequestURI</code> で操作されます。たとえば、特定の Pod の削除操作では、対象となる Pod を表す <code>/api/v1/namespaces/default/pods/azure-vote-back-59d587dbb7-pjkxr</code> に対して delete リクエストが送信されます。</p><p>　</p><p>クエリの作りこみをする際には、上述のクエリ例 (<code>where audit contains &quot;azure-vote&quot;</code>) のように、監査ログ全体を絞り込みの条件にして、必要な情報がどのフィールドに存在するかを確認するとよいです。ReplicaSet によって作成された Pod のように、名前にランダムな文字列が含まれる場合もログの特定がしやすくなります。</p></div><h3 id="シナリオ-2-Pod-のステータスとノードへのスケジューリング履歴を確認"><a href="#シナリオ-2-Pod-のステータスとノードへのスケジューリング履歴を確認" class="headerlink" title="シナリオ 2: Pod のステータスとノードへのスケジューリング履歴を確認"></a>シナリオ 2: Pod のステータスとノードへのスケジューリング履歴を確認</h3><p>新しく作成された Pod が <code>Pending</code> ステータスとなり、起動しない場合があります。</p><blockquote><p>コンピュート リソースの不足によって発生する Pod の Pending ステータスについては、こちらのブログ記事もご参照ください。<br>　<br><strong>Japan Azure IaaS Core Support Blog - AKSのメモリ関連トラブルシューティング</strong><br><a href="https://jpaztech.github.io/blog/containers/aks-memory-troubleshoot/">https://jpaztech.github.io/blog/containers/aks-memory-troubleshoot/</a></p></blockquote><p>次の例では、Pod が要求する CPU リソースが、現在クラスターに存在する空きノードで提供できないために、Pod が <code>Pending</code> ステータスとなっています。<br>また、<a href="https://learn.microsoft.com/ja-jp/azure/aks/cluster-autoscaler">クラスター オートスケーラー</a>が <code>Pending</code> ステータスの Pod が存在することを検知し、ノードプールのスケール アップを実行したイベントが確認できます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -l app=azure-vote-front</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">azure-vote-front-7655fcc46d-jm5sh   0/1     Pending   0          2s</span><br><span class="line">azure-vote-front-7655fcc46d-wtfph   1/1     Running   0          31s</span><br><span class="line">azure-vote-front-7655fcc46d-zqvbc   0/1     Pending   0          2s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod azure-vote-front-7655fcc46d-jm5sh</span></span><br><span class="line">  ...</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age   From                Message</span><br><span class="line">  ----     ------            ----  ----                -------</span><br><span class="line">  Warning  FailedScheduling  35s   default-scheduler   0/2 nodes are available: 2 Insufficient cpu.</span><br><span class="line">  Normal   TriggeredScaleUp  28s   cluster-autoscaler  pod triggered scale-up: [&#123;aks-nodepool2-20356098-vmss 2-&gt;4 (max: 5)&#125;]</span><br></pre></td></tr></table></figure><p>このときの Pod のステータスの変化と、ノードの追加のイベントを、監査ログから確認してみましょう。</p><p><code>RequestURI</code> に対象の Pod 名を含むログを検索します。ステータス情報が更新されたイベントを抽出するために、<code>Method</code> が get 以外のログを取得します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AzureDiagnostics </span><br><span class="line">| where Category == &quot;kube-audit&quot;</span><br><span class="line">| extend audit = parse_json(log_s)</span><br><span class="line">| extend Method = audit.verb</span><br><span class="line">| extend RequestURI = audit.requestURI</span><br><span class="line">| extend RequestObject = audit.requestObject</span><br><span class="line">| extend ResponseStatusCode = audit.responseStatus.code</span><br><span class="line">| extend UserAgent = audit.userAgent</span><br><span class="line">| where Method != &quot;get&quot;</span><br><span class="line">| where RequestURI contains &quot;/api/v1/namespaces/default/pods/azure-vote-front-7655fcc46d-jm5sh&quot;</span><br><span class="line">| project TimeGenerated, RequestObject, Method, ResponseStatusCode, RequestURI, UserAgent</span><br><span class="line">| order by TimeGenerated asc</span><br></pre></td></tr></table></figure><p>ログを検索した結果、kube-scheduler によって Pod のステータス情報が更新されたログが見つかりました (URI 末尾が <code>/status</code>) 。<br><code>RequestObject.status.conditions[0]</code> に Pod の状態を表す情報が記録されています。<code>Unschedulable</code> のメッセージが確認でき、<code>message</code> から CPU リソースの不足が理由であることがわかります。このメッセージは <code>kubectl describe pod</code> コマンドで確認できるものと同様の内容です。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit10.png" alt="CPU リソースの不足により Pod がスケジューリングされていない状態のログ"></p><p>そのあとの時間に、Pod がノードに割り当てられたログが確認できました (URI 末尾が <code>/binding</code>) 。<code>ResponseObject.target</code> から、Pod のデプロイ先がノード <code>aks-nodepool2-20356098-vmss000005</code> になったことがわかります。クラスター オートスケーラーによって新しい空きノードが追加され、Pod がデプロイできるようになりました。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit11.png" alt="新規に追加されたノードへ Pod がスケジューリングされた際のログ"></p><p>クラスターにノードが追加された際のログをみてみましょう。<code>kubectl get nodes</code> コマンドで取得できるノードの情報は、Node オブジェクトとして管理されています。<code>/api/v1/nodes</code> に送信された create リクエストのログを検索します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AzureDiagnostics </span><br><span class="line">| where Category == &quot;kube-audit&quot;</span><br><span class="line">| extend audit = parse_json(log_s)</span><br><span class="line">| extend Method = audit.verb</span><br><span class="line">| extend RequestURI = audit.requestURI</span><br><span class="line">| extend RequestObject = audit.requestObject</span><br><span class="line">| extend ResponseStatusCode = audit.responseStatus.code</span><br><span class="line">| extend UserAgent = audit.userAgent</span><br><span class="line">| extend User = audit.user.username</span><br><span class="line">| where Method == &quot;create&quot;</span><br><span class="line">| where RequestURI contains &quot;/api/v1/nodes&quot;</span><br><span class="line">| project TimeGenerated, RequestObject, Method, ResponseStatusCode, RequestURI, User, UserAgent</span><br><span class="line">| order by TimeGenerated asc</span><br></pre></td></tr></table></figure><p>Node オブジェクトの作成ログが取得できました。<code>User</code> および <code>UserAgent</code> から、<code>aks-nodepool2-20356098-vmss000005</code> ノードの kubelet からリクエストが送信されたことがわかります。<br>新しいノード (VM) が作成され、kubelet が動作を開始すると、API サーバーにノードの情報が登録されます。<code>ResponseObject</code> の <code>spec</code> や <code>status</code> から、ノードの情報やステータスが取得できます。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit12.png" alt="新規 Node が作成された際のログ"></p><div class="alert is-success"><p class="alert-title">ヒント</p><p>クラスター オートスケーラーのログは、監査ログと同様に AKS クラスターの診断設定で <strong>Kubernetes Cluster Autoscaler (cluster-autoscaler)</strong> を出力することで、お客様にてご確認いただけます。</p><p>オートスケールによってノードが意図した通りに追加・削除されなかった際に、クラスター オートスケーラーがどのような判断をしたのかや、VMSS インスタンスの操作リクエストが失敗していないかについて、ログから確認できます。</p></div><h3 id="シナリオ-3-Node-のステータス履歴を確認"><a href="#シナリオ-3-Node-のステータス履歴を確認" class="headerlink" title="シナリオ 3: Node のステータス履歴を確認"></a>シナリオ 3: Node のステータス履歴を確認</h3><p>ノードが新規に作成されると、はじめは <code>NotReady</code> ステータスの状態でクラスターに登録されます。その後 Pod を起動する準備が完了すると <code>Ready</code> ステータスへ変化します。<br>上記例 2 のシナリオで新しいノードが作成された際のログから、ノードのステータス情報が変化した様子を確認してみましょう。</p><p><code>RequestURI</code> に文字列 <code>&quot;/api/v1/nodes&quot;</code> を含み、かつ <code>&quot;/status&quot;</code> で終わるという条件をクエリに追加します。<code>Method</code> には patch を指定しています。</p><p>ノードのステータス情報は <code>ResponseObject.status.conditions</code> の配列に含まれています。扱いやすいように <a href="https://learn.microsoft.com/ja-jp/azure/data-explorer/kusto/query/mvexpandoperator">mv-expand 演算子</a>で配列の値を複数のレコードに展開します。ノードが Ready であるかどうかを表す情報は、<code>conditions.type</code> が <code>Ready</code> のものが該当します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AzureDiagnostics </span><br><span class="line">| where Category == &quot;kube-audit&quot;</span><br><span class="line">| extend audit = parse_json(log_s)</span><br><span class="line">| extend Method = audit.verb</span><br><span class="line">| extend RequestURI = audit.requestURI</span><br><span class="line">| extend ResponseObject = audit.responseObject</span><br><span class="line">| extend UserAgent = audit.userAgent</span><br><span class="line">| where RequestURI contains &quot;/api/v1/nodes&quot; and RequestURI endswith &quot;/status&quot;</span><br><span class="line">| where Method == &quot;patch&quot;</span><br><span class="line">| mv-expand conditions = ResponseObject.status.conditions   // conditions 配列の値を複数のレコードに展開</span><br><span class="line">| where conditions.type == &quot;Ready&quot;                          // type が &quot;Ready&quot; のログを取得</span><br><span class="line">| project TimeGenerated, conditions.type, conditions.status, conditions.reason, conditions.message, RequestURI, UserAgent</span><br><span class="line">| order by TimeGenerated asc</span><br></pre></td></tr></table></figure><p>クエリを実行すると、次の例のようにログが取得できます。<br>少々わかりにくいですが、<code>conditions_status</code> が <code>False</code> となっている場合は、ノードが <code>Ready</code> <strong>ではない</strong> ことを示しています (<code>NotReady</code> ステータス) 。</p><p>そのあとの時間に <code>conditions_status</code> が <code>True</code> へと変化しています (ノードが <code>Ready</code> ステータスになった)。また、<code>kubelet is posting ready status.</code> のメッセージから、kubelet から API サーバーにノードが正常であるという情報が報告されたことがわかります。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit13.png" alt="ノードのステータスが更新された際のログ"></p><div class="alert is-success"><p class="alert-title">ヒント</p><p><a href="https://learn.microsoft.com/ja-jp/azure/azure-monitor/containers/container-insights-overview">Container Insights</a> を利用にすることで、Azure Monitor で<a href="https://learn.microsoft.com/ja-jp/azure/azure-monitor/containers/container-insights-livedata-metrics#node-count">ノードのステータス情報をメトリックとして取得</a>できます。</p><p>監査ログではクラスターのさまざまな情報が取得可能ですが、Pod や Node のステータス変化をモニタリングする目的では、クエリの作成やログ データの管理が不要なため、Container Insights で用意されたメトリックを利用することをおすすめします。メトリックから、ステータス変化が発生した事実・発生日時を把握し、具体的な理由や関連するクラスター上のイベントを調査する目的で、監査ログを併用すると良いでしょう。</p></div><h3 id="シナリオ-4-Pod-再起動のなぞを追え！"><a href="#シナリオ-4-Pod-再起動のなぞを追え！" class="headerlink" title="シナリオ 4: Pod 再起動のなぞを追え！"></a>シナリオ 4: Pod 再起動のなぞを追え！</h3><blockquote><p><strong>[Contoso 社のストーリー]</strong><br><a href="https://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%B3%E3%83%88%E3%82%BD">Contoso 社</a>では先月、AKS を使って期待の新サービスをリリースしました。年明けにはイベント開催も控えており、2022年も終わりをむかえるこの12月も、開発は鋭意進行中です。今のところ目立った問題は起きておらず、安定して稼働をしているようです。今日の AKS の調子はどうかな？<br>　<br>ところが今日、開発のエンジニアより「最近 Pod が突然再起動するようになった」との報告を受けました。リリース作業などのクラスター操作はしていないのにもかかわらず、Pod が再起動 (再作成) されるとのことです。事象は平日の夜に起こることが多く、再作成された Pod の情報から、直近では <code>2022/12/21 21:47:39 (JST)</code> 頃に起きたようです。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod azure-vote-front-7655fcc46d-zp9v7</span></span><br><span class="line">  ...</span><br><span class="line">Start Time:       Wed, 21 Dec 2022 21:47:39 +0900</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>同じノードの Pod が一斉に再起動するため、開発のエンジニアはノードの調子が悪いのではないかと心配しています。事象は開発環境で発生したため、現時点でサービス影響は出ていないですが、今後の開発やサービス提供のために原因を突き止めたいとのことでした。<br>　<br>さてどうしましょう？ こんなこともあろうかと、監査ログの出力を有効にしていたのでした！</p></blockquote><p>Contoso 社では開発に kubectl と <a href="https://helm.sh/ja/">Helm</a> を使っています。事象の発生時間帯を調べると、これらのツールによる Pod 操作は見つからず、たしかにクラスター利用者の操作は無いようでした。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| where TimeGenerated between(datetime(2022/12/21 12:00:00) .. 1h)  // 21:00 - 22:00 (JST) のログを検索。クエリ上では UTC 表記</span><br><span class="line">| where RequestURI contains &quot;/api/v1/namespaces/default/pods&quot;       // default ネームスペースの Pod 操作に絞り込み</span><br><span class="line">| where Method !in (&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;)                         // 参照系リクエストは除く</span><br><span class="line">| where UserAgent contains &quot;kubectl&quot; or UserAgent contains &quot;helm&quot;   // kubectl もしくは helm による操作に絞り込み</span><br></pre></td></tr></table></figure><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit14.png" alt="kubectl や Helm による操作は見つからない"></p><p>Pod の delete リクエストのログを検索します。すると、事象の時間帯に複数の Pod が削除されていることがわかりました。<br>Pod が存在していたノードは <code>ResponseObject.spec.nodeName</code> から確認できます。ノード名がすべて <code>aks-nodepool2-20356098-vmss000001</code> となっており、同じノードの Pod が再起動するという開発エンジニアの証言とも一致します。<br><code>UserAgent</code> が kubelet と kube-controller-manager となっていることから、何らかの理由により Kubernetes 側から Pod の削除がリクエストされたと推察されます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| where TimeGenerated between(datetime(2022/12/21 12:00:00) .. 1h)</span><br><span class="line">| where RequestURI contains &quot;pods&quot;</span><br><span class="line">| where Method == &quot;delete&quot;</span><br><span class="line">| project TimeGenerated, Method, ResponseStatusCode, RequestURI, UserAgent, ResponseObject.spec.nodeName</span><br></pre></td></tr></table></figure><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit15.png" alt="ノード aks-nodepool2-20356098-vmss000001 の Pod が delete されている"></p><p>ノード <code>aks-nodepool2-20356098-vmss000001</code> に何が起きたのか手がかりを探します。このノードに関するリクエストを調べると、ノードに対して <code>unschedulable</code>フラグを設定・解除しているリクエストが見つかりました。<code>UserAgent</code> は <code>kured/v0.0.0</code> になっています。<code>unschedulable</code> は対象のノードへの Pod のスケジューリングを無効化する際に利用される設定値です (<code>kubectl cordon / uncordon</code> コマンドの操作に該当します)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| where TimeGenerated between(datetime(2022/12/21 12:00:00) .. 1h)</span><br><span class="line">| where RequestURI == &quot;/api/v1/nodes/aks-nodepool2-20356098-vmss000001&quot;</span><br><span class="line">| where Method !in (&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;)</span><br><span class="line">| where RequestObject != &quot;&#123;&#125;&quot; and RequestObject != &quot;skipped-too-big-size-object&quot;  // RequestObject が空、もしくは省略された場合 (後述) を除外</span><br></pre></td></tr></table></figure><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit16.png" alt="kured によってノードの unschedulable フラグが設定・解除されている"></p><p><code>UserAgent</code> に <code>kured/v0.0.0</code> を含むログを検索してみます。すると、今回削除された Pod に対して退避のリクエストを送っていることがわかりました (URI 末尾が <code>/evictions</code>) 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| where TimeGenerated between(datetime(2022/12/21 12:00:00) .. 1h)</span><br><span class="line">| where UserAgent contains &quot;kured/v0.0.0&quot;</span><br><span class="line">| where Method !in (&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;)</span><br></pre></td></tr></table></figure><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit17.png" alt="Kured によって Pod の eviction がリクエストされている"></p><p><a href="https://github.com/kubereboot/kured">Kured</a> はオープンソースのツールです。Linux OS のパッケージ アップデートの状態を確認し、アップデートの反映のために OS の再起動が必要となった場合に、自動的に OS を再起動します。</p><blockquote><p><strong>kured を使用した Linux ノードの再起動の処理 - Azure Kubernetes Service - Microsoft Learn</strong><br><a href="https://learn.microsoft.com/ja-JP/azure/aks/node-updates-kured">https://learn.microsoft.com/ja-JP/azure/aks/node-updates-kured</a></p></blockquote><p>Kured はノードを再起動する前に、対象ノードへの Pod スケジューリングを停止し、稼働中の Pod を別のノードへ退避させます (<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#drain">ノードのドレイン</a>)。今回発生した事象は、Kured によるノードの自動再起動が実施され、Pod の停止と別ノードでの再作成が発生したためであると判断できそうです。<br>(正確な判断には、Kured 自体が出力した動作ログをあわせて確認するのがよいでしょう)</p><p>Kured はいつクラスターにインストールされたのでしょうか？ 直近 1 週間でログを検索すると、関連するとみられるリソースが <code>kured</code> ネームスペースに作成されていることがわかりました。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| where TimeGenerated &gt;= ago(7d)</span><br><span class="line">| where audit contains &quot;kured&quot;</span><br><span class="line">| where Method !in (&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;)</span><br></pre></td></tr></table></figure><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit18.png" alt="Kured 関連リソースの作成リクエスト"></p><p>Kured は DaemonSet を利用して各ノードへ配置されます。作成された DaemonSet の内容を確認してみます。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit19.png" alt="DaemonSet の作成リクエスト"></p><p>コンテナー内で実行される <code>kured</code> コマンドにいくつかのオプションが渡されています (<code>spec.template.spec.containers[0].args</code>)。<code>--start-time=9pm</code> と<a href="https://kured.dev/docs/configuration/#setting-a-schedule">時間が指定</a>されており、この時間以降でノードの再起動が開始される設定になっていました。Pod 再起動の事象が、夜の時間帯に発生するという証言の裏付けが取れました。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;DaemonSet&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;apiVersion&quot;</span>: <span class="string">&quot;apps/v1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;my-release-kured&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;namespace&quot;</span>: <span class="string">&quot;kured&quot;</span>,</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;spec&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;template&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;spec&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;containers&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;kured&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;image&quot;</span>: <span class="string">&quot;ghcr.io/kubereboot/kured:1.12.0&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: [</span><br><span class="line">              <span class="string">&quot;/usr/bin/kured&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">              <span class="string">&quot;--ds-name=my-release-kured&quot;</span>,</span><br><span class="line">              <span class="string">&quot;--ds-namespace=kured&quot;</span>,</span><br><span class="line">              <span class="string">&quot;--reboot-command=/bin/systemctl reboot&quot;</span>,</span><br><span class="line">              <span class="string">&quot;--start-time=9pm&quot;</span>,         <span class="comment">// 夜9時以降にノード再起動を開始 (タイムウィンドウの設定)</span></span><br><span class="line">              <span class="string">&quot;--time-zone=Asia/Tokyo&quot;</span>,   <span class="comment">// タイムゾーン</span></span><br><span class="line">              <span class="string">&quot;--log-format=text&quot;</span></span><br><span class="line">            ],</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>[Contoso 社のストーリー - 後日談]</strong><br>後日、チームメンバーにヒアリングをしたところ、クラスター運用の効率化のために、<a href="https://learn.microsoft.com/ja-JP/azure/aks/node-updates-kured">AKS ドキュメントで紹介されていた Kured</a> の検証を行っていたことがわかりました。Pod 再起動の理由が解明でき、ノードの不調ではないことがわかったことで、開発のエンジニアも安心したようでした。<br>その後、Contoso 社ではクラスターの運用方法について検討が行われ、AKS のマネージド機能である<a href="https://learn.microsoft.com/ja-jp/azure/aks/auto-upgrade-cluster">自動アップグレード</a>や、<a href="https://learn.microsoft.com/ja-jp/azure/aks/planned-maintenance">計画メンテナンス機能</a> についても試してみることになりました。</p></blockquote><div class="alert is-success"><p class="alert-title">ヒント</p><p>ノードプールに VMSS を利用しているクラスターでは、ノードを最新状態にするために、<a href="https://learn.microsoft.com/ja-JP/azure/aks/node-image-upgrade">ノードイメージのアップグレード</a>が利用可能です。</p><p>スケール操作によって新規追加されたノードは、使用されているノードイメージをもとにインスタンスが起動します。そのため、古いバージョンのノードイメージが使用されている場合、日次で実行されるパッケージ アップデートまでの間は、ノードが最新状態ではない可能性がある点に留意しましょう。</p><p>VMSS を利用しているクラスターでは、定期的にノードイメージのアップグレード作業を実施する、もしくは自動アップグレード機能を利用することをおすすめします。</p><p>以前の AKS の既定である、ノードに可用性セットを使用するクラスターでは、ノードイメージが利用できないため、運用の自動化と OS を最新状態へ維持するために、Kured の利用が手段の 1 つとして挙げられます。</p></div><h3 id="注意点-RequestObject-ResponseObject-のサイズ制限"><a href="#注意点-RequestObject-ResponseObject-のサイズ制限" class="headerlink" title="注意点: RequestObject / ResponseObject のサイズ制限"></a>注意点: RequestObject / ResponseObject のサイズ制限</h3><p><code>RequestObject</code> および <code>ResponseObject</code> カラムは、値が Log Analytics カラムのサイズ上限に達している場合に記録されません。</p><blockquote><p><strong>Azure/AKS - Release 2022-08-14</strong><br>Remove responseObject from kube-audit logs when its size is reaching log analytics column size limit (32K) and customer enables kube-audit/kube-audit-admin diagnostics.<br><a href="https://github.com/Azure/AKS/releases/tag/2022-08-14">https://github.com/Azure/AKS/releases/tag/2022-08-14</a></p></blockquote><p>サイズ上限に達した場合は <code>&quot;skipped-too-big-size-object&quot;</code> というメッセージに置き換えられます。監査ログによる調査やクエリの作成時には、<code>RequestObject</code> と <code>ResponseObject</code> の情報が取得できない場合があることに注意しましょう。</p><p><img src="/blog/containers/aks-kube-audit/aks-kube-audit20.png" alt="サイズ上限に達したログの例"></p><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>本記事では、Kubernetes の監査ログの紹介と、AKS・Azure Monitor で実際にログ情報を利用する様子を紹介しました。監査ログを活用することで、過去にクラスターで発生した操作やオブジェクトの変更履歴を調べることができます。我々サポート エンジニアも AKS クラスターの調査をする際に、Kusto のクエリを利用して Kubernetes や AKS 基盤のさまざまなログを調査しています。</p><p>監査ログを活用するために、Request / Response Object の構造や、ある操作をしたときに何の API リクエストが送信されるのかについて把握していると役立ちます。Kubernetes API のリファレンスが参考になります。</p><blockquote><p><strong>Kubernetes Documentation / Reference / Kubernetes API</strong><br><a href="https://kubernetes.io/docs/reference/kubernetes-api/">https://kubernetes.io/docs/reference/kubernetes-api/</a></p></blockquote><p>また、kubectl コマンドのデバッグ出力 (<code>kubectl --v=8</code>) を有効にすると、API サーバーへのリクエスト内容が確認できるため、ログと照らし合わせて動作を確認するのに便利です。ログ出力を有効にして、クラスターを操作しながら実際にどのようなログが出力されるか試してみるとわかりやすいです。監査ログをみることで、トラブルシューティングだけではなく、Kubernetes クラスターがどのように動作をしているのか、理解をより深めることができるでしょう。</p><p>今回紹介しました監査ログが、AKS をよりご活用いただくうえでのご参考になりましたら幸いです。また、AKS のご利用において、お困りの点やご不明点がありました際は、いつでも Azure サポートまでお気兼ねなくご相談ください。</p><h2 id="参考リンク"><a href="#参考リンク" class="headerlink" title="参考リンク"></a>参考リンク</h2><ul><li>Kubernetes に Audit log を求めるのは間違っているだろうか？<ul><li>@makocchi さんによる CloudNative Days 2019 / OpenStack Days 2019 (コンテナー / クラウド ネイティブに関する国内カンファレンス) の発表資料</li><li><a href="https://speakerdeck.com/makocchi/cndt2019-kubernetes-audit-log-c4d4c5f6-6058-40f9-a5fc-abbb36073a19">https://speakerdeck.com/makocchi/cndt2019-kubernetes-audit-log-c4d4c5f6-6058-40f9-a5fc-abbb36073a19</a></li></ul></li></ul><hr><p>最後まで読んでいただきありがとうございました！<br><a href="https://qiita.com/advent-calendar/2022/microsoft-azure-tech">Microsoft Azure Tech Advent Calendar 2022</a> は明日が最終日となります。是非ご覧くださいー！</p><p>本年は多くのお客様にお世話になりました。ありがとうございました。<br>来年もみなさまにとって素晴らしい年でありますように、心よりお祈り申し上げます。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;この記事は &lt;a href=&quot;https://qiita.com/advent-calendar/2022/microsoft-azure-tech&quot;&gt;Microsoft Azure Tech Advent Calendar 2022&lt;/a&gt; の 24 日目の記事になります🎅&lt;/p&gt;
&lt;p&gt;こんにちは。Azure テクニカル サポートチームの桐井です。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://learn.microsoft.com/ja-jp/azure/aks/intro-kubernetes&quot;&gt;Azure Kubernetes Service (AKS)&lt;/a&gt; のクラスターを利用しているときに、アプリケーションがデプロイされたタイミングや、ノードのステータスがいつどのような理由で変わったのかなど、過去にクラスターで起こったイベントの履歴を確認したい場合があります。Kubernetes の監査ログを活用すると、これらのイベントをログから確認できるようになります。&lt;/p&gt;
&lt;p&gt;本記事では、Kubernetes の監査ログの紹介と、AKS において監査ログ利用する方法を、実例を交えて解説します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Containers" scheme="https://jpaztech.github.io/blog/tags/Containers/"/>
    
    <category term="Azure Kubernetes Service (AKS)" scheme="https://jpaztech.github.io/blog/tags/Azure-Kubernetes-Service-AKS/"/>
    
  </entry>
  
  <entry>
    <title>AKS で利用可能なオートスケールについて</title>
    <link href="https://jpaztech.github.io/blog/containers/aks-autoscaling/"/>
    <id>https://jpaztech.github.io/blog/containers/aks-autoscaling/</id>
    <published>2022-12-24T03:00:00.000Z</published>
    <updated>2023-05-26T05:14:04.499Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは！ Azure テクニカル サポート チームの川畑です。</p><p>Kubernetes を利用するにあたり、負荷に応じてワークロードを動的に増減させるオートスケーリングの構成を取ることがあります。</p><p>この記事では、 Azure Kubernetes Service (AKS) を利用している環境を想定し、Pod およびノードのオートスケーリングの設定と動作についてご紹介します。</p><span id="more"></span><hr><h2 id="スケーリングとは？水平オートスケーラー-HPA"><a href="#スケーリングとは？水平オートスケーラー-HPA" class="headerlink" title="スケーリングとは？水平オートスケーラー (HPA)"></a>スケーリングとは？水平オートスケーラー (HPA)</h2><p>スケーリングには、スケールアップ / スケールダウンとスケールアウト / スケール インの 2 種類があります。</p><p>スケールアップは、垂直スケールとも呼ばれ、1 台あたりのコンピュート リソースを増やすことでシステムの性能を上げる手段となります。<br>AKS では、AKS ノードとして利用している Azure 仮想マシンのサイズ (vCPU 数) を増やす、Pod に割り当てるリソース量を増やすなど、ノードや Podのコンピュート リソースを増やす方法が挙げられます。</p><p>次に、スケールアウトは、水平スケールとも呼ばれ、コンピュート リソースは変えず、ノードの数や Pod のレプリカ数を増やすことでシステムの性能を上げる手段となります。</p><p>これらのスケーリングの操作は、クラスターの利用者によって手動で実施される場合と、オートスケールの機能によって自動で実施される場合があります。<br>表でまとめると次のような形となります。</p><table><thead><tr><th></th><th>自動/手動</th><th>水平/垂直</th><th>Pod/ノード</th></tr></thead><tbody><tr><td><a href="https://learn.microsoft.com/ja-jp/azure/aks/concepts-scale#horizontal-pod-autoscaler">水平オートスケーラー (HPA)</a></td><td>自動</td><td>水平</td><td>Pod</td></tr><tr><td><a href="https://learn.microsoft.com/ja-jp/azure/aks/cluster-autoscaler">クラスター オートスケーラー</a></td><td>自動</td><td>水平</td><td>ノード</td></tr><tr><td><a href="https://learn.microsoft.com/ja-JP/azure/aks/keda-about">KEDA</a> *1</td><td>自動</td><td>水平</td><td>Pod</td></tr><tr><td><a href="https://learn.microsoft.com/ja-jp/azure/aks/vertical-pod-autoscaler">垂直オートスケーラー (VPA)</a> *1</td><td>自動</td><td>垂直</td><td>Pod</td></tr><tr><td>レプリカ数の定義変更</td><td>手動</td><td>水平</td><td>Pod</td></tr><tr><td><a href="https://learn.microsoft.com/ja-jp/azure/aks/scale-cluster?tabs=azure-cli">Azure CLI (az aks acale) / Azure Portal</a></td><td>手動</td><td>水平</td><td>ノード</td></tr><tr><td><a href="https://learn.microsoft.com/ja-jp/azure/aks/resize-node-pool?tabs=azure-cli">ノード プールのサイズ変更</a> *2</td><td>手動</td><td>垂直</td><td>ノード</td></tr></tbody></table><p>*1 2022.12.24 時点ではプレビューの機能です。<br>*2 ドキュメントのタイトルは「変更」となっていますが、新しいサイズでノードプールを作成・削除する手順となります。</p><p>今回はこれらの方法のうち、自動でスケーリング可能な水平オートスケーラー (HPA) とクラスター オートスケーラーについて紹介します。</p><h2 id="Pod-のオートスケーリング-HPA"><a href="#Pod-のオートスケーリング-HPA" class="headerlink" title="Pod のオートスケーリング (HPA)"></a>Pod のオートスケーリング (HPA)</h2><p>AKS では、Pod のレプリカ数を負荷に応じてスケーリングする Pod の水平オートスケーラー (HPA) が使用できます。<br>HPA は、Kubernetes の標準 API リソースであり、AKS 固有の機能ではありません。<br>そのため、HPA の内容に関しましては、下記 Kubernetes 公式ドキュメントの内容に準拠します。</p><blockquote><p>ご参考情報：Horizontal Pod Autoscalerウォークスルー | Kubernetes<br><a href="https://kubernetes.io/ja/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/">https://kubernetes.io/ja/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/</a></p></blockquote><p>HPA では、ノード上のメトリクス情報を kubelet を経由して Kubernetes クラスター内に存在するメトリクス サーバーに収集します。<br>なお、このメトリクス サーバーは現時点でサポートされている AKS クラスターでは標準でデプロイされております。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -n kube-system -l k8s-app=metrics-server</span></span><br><span class="line">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">metrics-server-5f87fccc7d-724vf   2/2     Running   0          2d11h</span><br><span class="line">metrics-server-5f87fccc7d-bl2d4   2/2     Running   0          2d11h</span><br></pre></td></tr></table></figure><p>メトリクス サーバーは収集された情報より、Pod が使用している CPU やメモリ等のメトリクス情報に基づき Deployment、ReplicaSet または StatefulSet といったレプリケーション コントローラー内のPodのレプリカ数をスケーリングします。</p><p>これによって、負荷に応じて Pod のレプリカ数が増減します。</p><p>それでは、実際に AKS クラスターを利用して HPA の設定をします。</p><h3 id="HPA-の挙動を確認してみる"><a href="#HPA-の挙動を確認してみる" class="headerlink" title="HPA の挙動を確認してみる"></a>HPA の挙動を確認してみる</h3><p>ここでは、AKS のチュートリアルで利用されているサンプル アプリケーション (azure-vote) を用いて確認します。<br>サンプル アプリケーションをローカル端末にクローンします。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/Azure-Samples/azure-voting-app-redis.git</span></span><br></pre></td></tr></table></figure><p>上記コマンドによってクローンされたマニフェスト ファイルを確認し、コンテナーにリソース要求が設定されていることを確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> less ./azure-voting-app-redis/azure-vote-all-in-one-redis.yaml</span></span><br></pre></td></tr></table></figure><p>azure-vote-front コンテナーでは、次のようにリソース要求が設定されていることが確認できます。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">azure-vote-front</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">mcr.microsoft.com/azuredocs/azure-vote-front:v1</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">250m</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">500m</span></span><br></pre></td></tr></table></figure><p>上記リソース要求を確認すると、コンテナーをデプロイするために必要なリソースは、250 ミリ CPU であり、制限は 500 ミリ CPU となっていることが確認できました。<br>HPA では、対象のレプリケーション コントローラー内の Pod に設定された、リソース要求に対する使用率の平均を計算します。</p><p>それでは、当該 Pod をデプロイします。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f ./azure-voting-app-redis/azure-vote-all-in-one-redis.yaml</span></span><br></pre></td></tr></table></figure><p>デプロイされた Pod を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">azure-vote-back-5fb9656dff-6ln9w    1/1     Running   0          47s</span><br><span class="line">azure-vote-front-7589b695dd-wb7mq   1/1     Running   0          47s</span><br></pre></td></tr></table></figure><p>azure-vote-front の Pod が作成されていることを確認できました。</p><p>それでは、ここから HPA の設定をします。</p><p>HPA の設定は、HorizontalPodAutoscaler リソースを用いて定義することが可能となり、kubectl autoscale コマンドもしくは、マニフェスト ファイルを用いて作成することが可能となります。</p><p>今回の検証では、Deplyoment “azure-vote-front” 内の全 Pod の平均 CPU 使用率が 50% を目標に、最小 3 台、最大 10 台まで Pod のレプリカ数を増減させるように設定します。</p><p>この設定を kubectl autoscale コマンドにて実施する場合は、下記コマンドとなります。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl autoscale deployment azure-vote-front --cpu-percent=50 --min=3 --max=10</span></span><br></pre></td></tr></table></figure><p>この HPA によって Deplyoment “azure-vote-front” 内の Pod のレプリカ数は最小 3 台となるため、先ほど確認した Pod のレプリカ数は 1 台でしたが、3 台に増えていることが確認できます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -l app=azure-vote-front</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">azure-vote-front-7589b695dd-d7psh   1/1     Running   0          98s</span><br><span class="line">azure-vote-front-7589b695dd-km4hq   1/1     Running   0          98s</span><br><span class="line">azure-vote-front-7589b695dd-wb7mq   1/1     Running   0          11m</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get hpa</span></span><br><span class="line">NAME               REFERENCE                     TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">azure-vote-front   Deployment/azure-vote-front   2%/50%    3         10        3          110s</span><br></pre></td></tr></table></figure><p>想定どおり、Pod のレプリカ数が HPA の設定にしたがって Pod のレプリカ数が増えたことが確認できました。</p><p>次に、Pod に負荷をかけることで、HPA によって Pod のレプリカ数が増えることを確認します。<br>まずは、事前に現在の Pod の CPU 負荷状況を kubectl top pods コマンドを用いて確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl top pods -l app=azure-vote-front</span></span><br><span class="line">NAME                                CPU(cores)   MEMORY(bytes)</span><br><span class="line">azure-vote-front-7589b695dd-d7psh   1m           60Mi</span><br><span class="line">azure-vote-front-7589b695dd-km4hq   1m           58Mi</span><br><span class="line">azure-vote-front-7589b695dd-wb7mq   1m           45Mi</span><br></pre></td></tr></table></figure><p>現在の Pod の CPU 使用量が低い状況であることが確認できました。<br>次に、CPU に負荷をかけるために、今回は stress コマンドを用います。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> -it azure-vote-front-7589b695dd-d7psh -- stress -c 1</span></span><br><span class="line">stress: info: [330] dispatching hogs: 1 cpu, 0 io, 0 vm, 0 hdd</span><br></pre></td></tr></table></figure><p>stress コマンドによって、Pod “azure-vote-front-7589b695dd-d7psh” の CPU に負荷をかけ始めました。再度 kubectl top pods コマンドを用いて CPU の負荷状況を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl top pods -l app=azure-vote-front</span></span><br><span class="line">NAME                                CPU(cores)   MEMORY(bytes)</span><br><span class="line">azure-vote-front-7589b695dd-d7psh   312m         65Mi</span><br><span class="line">azure-vote-front-7589b695dd-km4hq   1m           58Mi</span><br><span class="line">azure-vote-front-7589b695dd-wb7mq   1m           45Mi</span><br></pre></td></tr></table></figure><p>先ほど 2 ミリ CPU 程度であったのに対して、312 ミリ CPU 程リソースを消費していることが確認できました。<br>ここで HPA の状況ならびに Pod の稼働状況を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get hpa</span></span><br><span class="line">NAME               REFERENCE                     TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">azure-vote-front   Deployment/azure-vote-front   67%/50%   3         10        4          30m</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -l app=azure-vote-front</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">azure-vote-front-7589b695dd-4q79q   1/1     Running   0          101s</span><br><span class="line">azure-vote-front-7589b695dd-d7psh   1/1     Running   0          30m</span><br><span class="line">azure-vote-front-7589b695dd-km4hq   1/1     Running   0          30m</span><br><span class="line">azure-vote-front-7589b695dd-wb7mq   1/1     Running   0          39m</span><br></pre></td></tr></table></figure><p>stress コマンドを用いて CPU の負荷をかけたことによって、Pod のレプリカ数が 3 から 4 に増えたことが確認できました。<br>最後に stress コマンドを停止し、増えた Pod が自動で削除されることも確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt; - Control + Cキー によってプロセスを終了する</span><br><span class="line">command terminated with exit code 130</span><br></pre></td></tr></table></figure><p>再度 kubectl top pods コマンドを用いて CPU の負荷状況を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl top pods -l app=azure-vote-front</span></span><br><span class="line">NAME                                CPU(cores)   MEMORY(bytes)</span><br><span class="line">azure-vote-front-7589b695dd-4q79q   1m           39Mi</span><br><span class="line">azure-vote-front-7589b695dd-d7psh   1m           65Mi</span><br><span class="line">azure-vote-front-7589b695dd-km4hq   1m           58Mi</span><br><span class="line">azure-vote-front-7589b695dd-wb7mq   1m           45Mi</span><br></pre></td></tr></table></figure><p>Pod “azure-vote-front-7589b695dd-d7psh” の CPU 使用量が減少したことが確認できました。<br>その後、しばらくした後に、次のように Pod のレプリカ数が最小の 3 に戻ることが確認できます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get hpa</span></span><br><span class="line">NAME               REFERENCE                     TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">azure-vote-front   Deployment/azure-vote-front   0%/50%    3         10        4          38m</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get hpa</span></span><br><span class="line">NAME               REFERENCE                     TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">azure-vote-front   Deployment/azure-vote-front   0%/50%    3         10        3          38m</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">azure-vote-front-7589b695dd-d7psh   1/1     Running   0          39m</span><br><span class="line">azure-vote-front-7589b695dd-km4hq   1/1     Running   0          39m</span><br><span class="line">azure-vote-front-7589b695dd-wb7mq   1/1     Running   0          48m</span><br></pre></td></tr></table></figure><p>このように HPA を利用することで、Pod の負荷状況に応じて Pod のレプリカ数を自動で増減可能なことを確認しました。</p><h2 id="クラスター-オートスケーラーについて"><a href="#クラスター-オートスケーラーについて" class="headerlink" title="クラスター オートスケーラーについて"></a>クラスター オートスケーラーについて</h2><p>AKS では、ノードをオートスケールするための機能として、クラスター オートスケーラーが提供されています。<br>クラスター オートスケーラーを利用することで、新規 Pod がデプロイ可能な空きノードが不足し、Pending (割り当て不可) 状態となった際にノードである Azure 仮想マシンの数を自動で増減することが可能となります。<br>これによって、Pod のデプロイに必要なノード数のみ稼働させることで、コストの最適化などが期待されます。</p><div class="alert is-important"><p class="alert-title">重要</p><p>クラスター オートスケーラーは、CPU やメモリ等のリソースの使用率を監視し自動でスケールする機能ではありません。</p><p>新規 Pod がデプロイ可能な空きノードが不足し、Pending (割り当て不可) 状態となった際に自動でスケールアウトする機能となります。</p></div><div class="alert is-warning"><p class="alert-title">警告</p><p>AKS のクラスター オートスケーラーを利用する場合、VMSS のオートスケール機能を有効にしないでください。</p><p>AKS では、VMSS などの IaaS リソースの API を用いて直接変更することはサポート外となります。</p><p>いずれの機能も有効にした場合は、 VMSS へ直接変更を加えたことにより、AKS クラスターがサポートされない状態になる恐れや、2 つのオートスケ</p><p>ールの処理が競合することで、ノードの増減が想定通りに動作しない可能性がございます。</p><blockquote><p>ご参考情報：エージェント ノードのユーザー カスタマイズ</p><p><a href="https://learn.microsoft.com/ja-jp/azure/aks/support-policies#user-customization-of-agent-nodes">https://learn.microsoft.com/ja-jp/azure/aks/support-policies#user-customization-of-agent-nodes</a></p><p>　</p><p>ご参考情報： AKS クラスターの作成とクラスター オートスケーラーの有効化</p><p><a href="https://learn.microsoft.com/ja-jp/azure/aks/cluster-autoscaler#create-an-aks-cluster-and-enable-the-cluster-autoscaler">https://learn.microsoft.com/ja-jp/azure/aks/cluster-autoscaler#create-an-aks-cluster-and-enable-the-cluster-autoscaler</a></p></div></blockquote><p>そのため、適切にクラスター オートスケーラーを利用するためには、各 Pod に適切なリソース要求を設定することが重要となります。</p><p>それでは、実際に AKS クラスターを利用してクラスター オートスケーラーの挙動を確認します。</p><h3 id="クラスター-オートスケーラーの挙動を確認してみる"><a href="#クラスター-オートスケーラーの挙動を確認してみる" class="headerlink" title="クラスター オートスケーラーの挙動を確認してみる"></a>クラスター オートスケーラーの挙動を確認してみる</h3><p>クラスター オートスケーラーの挙動を確認するにあたり、まずはユーザー ノードプールを追加します。<br>ここでは、ノード数が 1、仮想マシンのサイズが Standard_DS2_v2 (2vCPU, 7GiB) のノード プールを追加します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az aks nodepool add \</span></span><br><span class="line"><span class="bash">    --resource-group &lt;リソースグループ名&gt; \</span></span><br><span class="line"><span class="bash">    --cluster-name &lt;クラスター名&gt; \</span></span><br><span class="line"><span class="bash">    --name usernp1 \</span></span><br><span class="line"><span class="bash">    --node-count 1 \</span></span><br><span class="line"><span class="bash">    --mode User \</span></span><br><span class="line"><span class="bash">    --node-vm-size Standard_ DS2_v2 \</span></span><br><span class="line"><span class="bash">    --labels nodelabel=catest</span></span><br></pre></td></tr></table></figure><p>追加されたノードの情報を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get nodes</span></span><br><span class="line">NAME                                STATUS   ROLES   AGE     VERSION</span><br><span class="line">aks-nodepool1-12285779-vmss000000   Ready    agent   4h14m   v1.24.6</span><br><span class="line">aks-nodepool1-12285779-vmss000001   Ready    agent   4h13m   v1.24.6</span><br><span class="line">aks-nodepool1-12285779-vmss000002   Ready    agent   4h13m   v1.24.6</span><br><span class="line">aks-usernp1-70474131-vmss000000     Ready    agent   3m      v1.24.6</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe node aks-usernp1-70474131-vmss000000</span></span><br><span class="line">&lt;中略&gt;</span><br><span class="line">Allocatable:</span><br><span class="line">  cpu:                1900m</span><br><span class="line">  ephemeral-storage:  119703055367</span><br><span class="line">  hugepages-1Gi:      0</span><br><span class="line">  hugepages-2Mi:      0</span><br><span class="line">  memory:             4670956Ki</span><br><span class="line">  pods:               110</span><br><span class="line">&lt;中略&gt;</span><br></pre></td></tr></table></figure><p>ノードが追加されていることを確認しました。<br>それでは、このノード プールにリソース要求を設定した Pod をデプロイするために、Deployments のマニフェスト ファイルを作成します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat &lt;&lt; <span class="string">EOF &gt;&gt; ca-test-pod.yaml</span></span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        nodelabel: catest</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 2.5Gi</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>上記定義によって、nodelabel キーにcatest を持つノードにのみ nginx Pod が配置されます。これによって、他のノードに Pod がデプロイされることを防げます。<br>それでは、このマニフェスト ファイルに従い、Deployment を作成します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f ca-test-pod.yaml</span></span><br><span class="line">deployment.apps/nginx created</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -o wide</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP           NODE                              NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-67d6486785-7rj7r   0/1     Pending   0          18s   &lt;none&gt;       &lt;none&gt;                            &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-67d6486785-hfcmw   1/1     Running   0          18s   10.244.3.5   aks-usernp1-70474131-vmss000000   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p>Pod “nginx-67d6486785-7rj7r” が Pending 状態であることが確認できました。 原因を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod nginx-67d6486785-7rj7r</span></span><br><span class="line"></span><br><span class="line">&lt;中略&gt;</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age    From               Message</span><br><span class="line">  ----     ------            ----   ----               -------</span><br><span class="line">  Warning  FailedScheduling  2m54s  default-scheduler  0/4 nodes are available: 1 Insufficient memory, 3 node(s) didn&#x27;t match Pod&#x27;s node affinity/selector. preemption: 0/4 nodes are available: 1 No preemption victims found for incoming pod, 3 Preemption is not helpful for scheduling.</span><br></pre></td></tr></table></figure><p>このメッセージは、クラスター内の全 4 台のノードのうち、1 ノードはメモリの空き容量が不足しており、他 3 ノードがセレクターを満たさず、Pod をスケジューリング可能なノードが見つからなかったことを示します。</p><p>これによって、ノード プール “usernp1” では、リソースの不足に伴い Pod が Pending となる状況となりました。</p><p>この状態で、ノード プール “usernp1” に対して、クラスター オートスケーラーを有効にします。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az aks nodepool update \</span></span><br><span class="line"><span class="bash">  --resource-group &lt;リソースグループ名&gt; \</span></span><br><span class="line"><span class="bash">  --cluster-name &lt;クラスター名&gt; \</span></span><br><span class="line"><span class="bash">  --name usernp1 \</span></span><br><span class="line"><span class="bash">  --enable-cluster-autoscaler \</span></span><br><span class="line"><span class="bash">  --min-count 1 \</span></span><br><span class="line"><span class="bash">  --max-count 3</span></span><br></pre></td></tr></table></figure><p>クラスター オートスケーラーを有効化したので、ノードが追加されていることを確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get nodes</span></span><br><span class="line">NAME                                STATUS   ROLES   AGE     VERSION</span><br><span class="line">aks-nodepool1-12285779-vmss000000   Ready    agent   4h47m   v1.24.6</span><br><span class="line">aks-nodepool1-12285779-vmss000001   Ready    agent   4h47m   v1.24.6</span><br><span class="line">aks-nodepool1-12285779-vmss000002   Ready    agent   4h46m   v1.24.6</span><br><span class="line">aks-usernp1-70474131-vmss000000     Ready    agent   36m     v1.24.6</span><br><span class="line">aks-usernp1-70474131-vmss000001     Ready    agent   34s     v1.24.6</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -o wide</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP           NODE                              NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-67d6486785-7rj7r   1/1     Running   0          14m   10.244.4.2   aks-usernp1-70474131-vmss000001   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-67d6486785-hfcmw   1/1     Running   0          14m   10.244.3.5   aks-usernp1-70474131-vmss000000   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p>期待どおりノード プール “usernp1” に新規ノード “usernp1-70474131-vmss000001”が作成され、Pod “nginx-67d6486785-7rj7r” がデプロイされていることが確認できました。</p><p>最後に Pod のレプリカ数を 1 に減らし、ノードが自動削除されることを確認します。<br>マニフェスト ファイルを修正し、Pod のレプリカ数を 1 に減らした後に、再度マニフェスト ファイルを適用します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f ca-test-pod.yaml</span></span><br><span class="line">deployment.apps/nginx configured</span><br></pre></td></tr></table></figure><p>これによって、Pod のレプリカ数およびノードが減っていることを確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -o wide</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP           NODE                              NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-67d6486785-hfcmw   1/1     Running   0          19m   10.244.3.5   aks-usernp1-70474131-vmss000000   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get nodes</span></span><br><span class="line">NAME                                STATUS   ROLES   AGE    VERSION</span><br><span class="line">aks-nodepool1-12285779-vmss000000   Ready    agent   5h3m   v1.24.6</span><br><span class="line">aks-nodepool1-12285779-vmss000001   Ready    agent   5h3m   v1.24.6</span><br><span class="line">aks-nodepool1-12285779-vmss000002   Ready    agent   5h3m   v1.24.6</span><br><span class="line">aks-usernp1-70474131-vmss000000     Ready    agent   52m    v1.24.6</span><br></pre></td></tr></table></figure><p>このように クラスター オートスケーラーを利用することで、ノード上のリソース不足が原因で Pending となった Pod が発生した際にノード プール内のノードの数を自動で増え、リソースの使用率が低下した際にノードの数が自動で減ることが確認できました。</p><h3 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h3><p>この記事では、HPA とクラスター オートスケーラーによる Pod とノードのオートスケーリングのしくみについて、サンプル アプリケーションを例にご紹介しました。設定した条件に応じて、自動でスケールアウトされることが確認いただけたかと思います。<br>こういったオートスケールの設定を適切にお使いいただくことで、お客様のワークロードの可用性を高めることができるかと存じますので、ご参考にいただけますと幸いです。</p><p>本稿が皆様のお役に立ちましたら幸いです。</p><p>最後まで読んでいただきありがとうございました！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは！ Azure テクニカル サポート チームの川畑です。&lt;/p&gt;
&lt;p&gt;Kubernetes を利用するにあたり、負荷に応じてワークロードを動的に増減させるオートスケーリングの構成を取ることがあります。&lt;/p&gt;
&lt;p&gt;この記事では、 Azure Kubernetes Service (AKS) を利用している環境を想定し、Pod およびノードのオートスケーリングの設定と動作についてご紹介します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Containers" scheme="https://jpaztech.github.io/blog/tags/Containers/"/>
    
    <category term="Azure Kubernetes Service (AKS)" scheme="https://jpaztech.github.io/blog/tags/Azure-Kubernetes-Service-AKS/"/>
    
  </entry>
  
  <entry>
    <title>Azure Linux エージェント (waagent) に出力されるメッセージについて</title>
    <link href="https://jpaztech.github.io/blog/vm/vmagent-error/"/>
    <id>https://jpaztech.github.io/blog/vm/vmagent-error/</id>
    <published>2022-12-23T03:00:00.000Z</published>
    <updated>2023-05-26T05:14:04.919Z</updated>
    
    <content type="html"><![CDATA[<p>この記事は <a href="https://qiita.com/advent-calendar/2022/microsoft-azure-tech">Microsoft Azure Tech Advent Calendar 2022</a> の 23 日目の記事です。</p><p>こんにちは、Azure テクニカル サポートの木下です。<br>今回は、よくお問い合わせいただきます、Azure Linux エージェント (waagent) に出力されるメッセージについてご紹介いたします。 </p><span id="more"></span> <p>Azure Linux VM の /var/log/messages において、以下のような Error 句を含むメッセージが出力されたため、原因を知りたいというお問い合わせをいただくことがございます。 </p><p>メッセージ例） </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dec 11 06:16:46 testvm python: 2022-12-15T21:16:46.414141Z ERROR MonitorHandler ExtHandler An error occurred <span class="keyword">in</span> the monitor thread main loop; will skip the current iteration. </span><br><span class="line">Dec 11 06:16:46 testvm python: [ProtocolError] Error fetching goal state </span><br><span class="line">Dec 11 06:16:46 testvm python: Inner error: [ResourceGoneError] [HTTP Failed] [410: Gone] The page you requested was removed. </span><br></pre></td></tr></table></figure><h2 id="1-Error-句を含むメッセージの内容について"><a href="#1-Error-句を含むメッセージの内容について" class="headerlink" title="1. Error 句を含むメッセージの内容について"></a>1. Error 句を含むメッセージの内容について</h2><p>Azure Linux エージェントは新しい更新情報などがないかの確認のため、VM と拡張機能の状態を物理ホストへ報告し、定期的に目標状態 (Goal State) の取得を行っております。<br>上記のような Error 句を含むメッセージは、この目標状態の取得に失敗した場合に出力されるエラーならびに関連のメッセージとなります。<br>目標状態の取得は、Azure 基盤内部の専用のエンドポイントとのやり取りで行われておりますが、このエンドポイントについては、稼働率が 100 % とすることは叶わず、拡張機能などの動作に支障がない範囲でメンテナンスが行われております。 </p><p>そのため、これらの Error 句を含むメッセージは、エンドポイントまでの通信経路で何らかの一時的な接続断やエンドポイント側のメンテナンスなどが発生し、目標状態の取得に失敗した際に発生することが想定となります。 </p><p>Azure Linux エージェント (waagent) については、以下公開情報におまとめしておりますので、詳細については、こちらをご参照ください。 </p><blockquote><p>参考） </p><ul><li><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/extensions/agent-linux">Azure Linux エージェントの理解と使用</a> </li></ul></blockquote><h2 id="2-影響の有無について"><a href="#2-影響の有無について" class="headerlink" title="2. 影響の有無について"></a>2. 影響の有無について</h2><p>Azure Linux エージェントの更新情報の確認は、数秒間隔で常に行われております。一時的に失敗していた期間が存在していたとしても、VM の動作へ影響を与えるものではないため、その後成功 (=Error 句を含むメッセージの出力が停止) していれば問題のないものと判断いただくことが可能です。<br>従いまして、このメッセージの出力が一時的なものであれば、基本的にはご放念いただいて問題なく、また、お客様側で何らかの対処をいただく必要はございません。 </p><p>一方で、Azure Linux エージェント自体が何らかの動作不具合となってしまった等が原因で恒常的にエンドポイントとの通信に失敗している場合、Azure 基盤側が「Azure Linux エージェント (waagent) と通信ができない状態」とみなし、エージェントが管理している拡張機能の動作 、例えば、Azure Backup の取得等に失敗してしまうケースがあります。この場合は、是正を行う必要がある状態となります。 </p><p>まずは、Error 句を含むメッセージが出力された VM のエージェントの状態が Ready なのか、Not Ready となってしまっているのかを Azure ポータル や Azure PowerShell / Azure CLI のコマンドの実行結果よりご確認ください。 </p><h2 id="3-エージェントの状態の確認方法について"><a href="#3-エージェントの状態の確認方法について" class="headerlink" title="3. エージェントの状態の確認方法について"></a>3. エージェントの状態の確認方法について</h2><h3 id="▼Azure-ポータルの場合"><a href="#▼Azure-ポータルの場合" class="headerlink" title="▼Azure ポータルの場合"></a>▼Azure ポータルの場合</h3><p><img src="/blog/vm/vmagent-error/vmagent-error01.png"> </p><h3 id="▼Azure-PowerShell-の場合"><a href="#▼Azure-PowerShell-の場合" class="headerlink" title="▼Azure PowerShell の場合"></a>▼Azure PowerShell の場合</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PS &gt; <span class="variable">$vm</span> = Get-AzVm -ResourceGroupName &lt;RGName&gt; -Name &lt;VMName&gt; -Status </span><br><span class="line"></span><br><span class="line"><span class="comment"># エージェントの状態表示 (DisplayStatus が Ready であるかを確認) </span></span><br><span class="line">PS &gt; <span class="variable">$vm</span>.VMAgent.Statuses[0] </span><br><span class="line"></span><br><span class="line">Code          : ProvisioningState/succeeded </span><br><span class="line">Level         : Info </span><br><span class="line">DisplayStatus : Ready </span><br><span class="line">Message       : GuestAgent is running and processing the extensions. </span><br><span class="line">Time          : 11/28/2022 3:53:17 AM </span><br></pre></td></tr></table></figure><h3 id="▼Azure-CLI-の場合"><a href="#▼Azure-CLI-の場合" class="headerlink" title="▼Azure CLI の場合"></a>▼Azure CLI の場合</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># VM の状態情報を取得し、エージェントの状態を抽出して表示 (displayStatus が Ready であるかを確認) </span></span><br><span class="line">az vm get-instance-view -g &lt;RGName&gt; -n &lt;VMName&gt; --query <span class="string">&#x27;&#123;AgentStatus:instanceView.vmAgent.statuses&#125;&#x27;</span> </span><br><span class="line">&#123; </span><br><span class="line">  <span class="string">&quot;AgentStatus&quot;</span>: [ </span><br><span class="line">    &#123; </span><br><span class="line">      <span class="string">&quot;code&quot;</span>: <span class="string">&quot;ProvisioningState/succeeded&quot;</span>, </span><br><span class="line">      <span class="string">&quot;displayStatus&quot;</span>: <span class="string">&quot;Ready&quot;</span>, </span><br><span class="line">      <span class="string">&quot;level&quot;</span>: <span class="string">&quot;Info&quot;</span>, </span><br><span class="line">      <span class="string">&quot;message&quot;</span>: <span class="string">&quot;GuestAgent is running and processing the extensions.&quot;</span>, </span><br><span class="line">      <span class="string">&quot;time&quot;</span>: <span class="string">&quot;2022-11-28T03:56:17.923000+00:00&quot;</span> </span><br><span class="line">    &#125; </span><br><span class="line">  ] </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Not Readyの状態が継続して発生している場合の想定されるシナリオと対処策をおまとめしたブログ記事もございますので、想定されるシナリオに該当するかの切り分け方法としてご参照くださいませ。 </p><blockquote><p>参考） </p><ul><li><a href="https://jpaztech.github.io/blog/vm/vmagent-notready/">「仮想マシン エージェントの状態が準備できていません」について</a> </li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;この記事は &lt;a href=&quot;https://qiita.com/advent-calendar/2022/microsoft-azure-tech&quot;&gt;Microsoft Azure Tech Advent Calendar 2022&lt;/a&gt; の 23 日目の記事です。&lt;/p&gt;
&lt;p&gt;こんにちは、Azure テクニカル サポートの木下です。&lt;br&gt;今回は、よくお問い合わせいただきます、Azure Linux エージェント (waagent) に出力されるメッセージについてご紹介いたします。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Linux" scheme="https://jpaztech.github.io/blog/tags/Linux/"/>
    
    <category term="VM Agent" scheme="https://jpaztech.github.io/blog/tags/VM-Agent/"/>
    
  </entry>
  
  <entry>
    <title>Windows VM のビルトイン Administrator アカウントの名前変更について</title>
    <link href="https://jpaztech.github.io/blog/vm/vm-administrator-username-change/"/>
    <id>https://jpaztech.github.io/blog/vm/vm-administrator-username-change/</id>
    <published>2022-12-21T15:00:00.000Z</published>
    <updated>2023-05-26T05:14:04.875Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの洪です。<br>Azure VM (Windows OS) 作成時には、OS 内で “ビルトイン Administrator” として <strong>管理者アカウント</strong> のユーザー名をご指定いただくことになりますが、こちらのユーザー名の変更が可能であるかとのお問い合わせをいただくことがございます。<br>本記事ではそのユーザー名を OS 上から変更する方法および関連の留意事項 についてご案内いたします。</p><span id="more"></span><hr><h2 id="変更対象"><a href="#変更対象" class="headerlink" title="変更対象"></a>変更対象</h2><p>本記事にて案内しております手順は、以下のように作成されたユーザーを後から変更するものとなります。</p><p>■ 確認例 - Azure ポータル画面<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-01.png"><br>※ Azure VM の管理者アカウントのユーザー名として、azureadmin を指定します。</p><p>■ 確認例 - OS 上の画面<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-02.png"><br>※ Windows OS のビルトイン Administrator として azureadmin のユーザーが生成されます。<br>※ こちらのユーザー名の変更に関しまして、以下にご案内いたします。  </p><h2 id="管理者アカウント-ユーザー名を変更する"><a href="#管理者アカウント-ユーザー名を変更する" class="headerlink" title="管理者アカウント ユーザー名を変更する"></a>管理者アカウント ユーザー名を変更する</h2><p>管理者アカウントのユーザー名は従来の Windows の動作のように Windows の [コンピューターの管理] で変更可能でございます。<br>詳細手順に関しましては以下をご確認ください。</p><h2 id="■-手順"><a href="#■-手順" class="headerlink" title="■ 手順"></a>■ 手順</h2><h3 id="1-現在の管理者-ビルドイン-Administrator-のユーザー名を確認します。"><a href="#1-現在の管理者-ビルドイン-Administrator-のユーザー名を確認します。" class="headerlink" title="1. 現在の管理者 (ビルドイン Administrator) のユーザー名を確認します。"></a>1. 現在の管理者 (ビルドイン Administrator) のユーザー名を確認します。</h3><p>1-1. 画面左下側の Windows アイコンを右クリックし、[コンピューターの管理] を開きます。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-03.png"></p><p>1-2. [ローカル ユーザーとグループ] - [ユーザー] を選択し、”Built-in account for administering the computer” にて 該当するユーザー名を確認します。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-04.png"><br>※ この例では、[azureadmin] になります。</p><h3 id="2-管理者のユーザー名を変更します。"><a href="#2-管理者のユーザー名を変更します。" class="headerlink" title="2. 管理者のユーザー名を変更します。"></a>2. 管理者のユーザー名を変更します。</h3><p>2-1. 当該名前を右クリックし、[名前の変更] をクリックします。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-05.png"></p><p>2-2. ご希望のユーザー名を入力し、変更が可能です。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-06.png"><br>※ この例では、[azureadminnew] に変更しました。</p><h2 id="ユーザー名変更の影響および対処について"><a href="#ユーザー名変更の影響および対処について" class="headerlink" title="ユーザー名変更の影響および対処について"></a>ユーザー名変更の影響および対処について</h2><p>Windows OS のユーザーにつきましては、[C:\ユーザー] 配下にユーザー名でフォルダーが作成されますが、上記の手順で管理者のユーザー名をご変更いただいた際に、フォルダーの名前が自動で変更される動作はございません。<br>フォルダ名とログオン ユーザー名が異なっていても通常は問題ないためご放念いただく形となりますが、もしアプリケーションが動作しないなどやむを得ない理由があれば以下の手順で変更することは可能です。<br>フォルダー名を新しいユーザー名に変更する場合には、手動にてレジストリをご変更いただく必要がございます。<br>具体的な手順を下記にご案内いたします。</p><blockquote><p>[!CAUTION]<br>レジストリを誤って変更すると、深刻な問題が発生することがございます。<br>レジストリを編集する際には十分に注意してください。<br>万一に備えて、編集の前にはレジストリのバックアップまたは仮想マシンのバックアップ (Azure Backup やディ&gt; スクのスナップショット) をご取得いただきますようお願いします。<br>レジストリのバックアップおよび復元方法の詳細を参照するには、以下のサポート技術情報をご確認ください。<br>ご参考) <a href="https://support.microsoft.com/ja-jp/help/322756/">Windows でレジストリをバックアップおよび復元する方法</a></p></blockquote><h2 id="■-手順-1"><a href="#■-手順-1" class="headerlink" title="■ 手順"></a>■ 手順</h2><p>※ 仮想マシン作成時に指定した管理者のユーザー名 azureadmin を azureadminnew に変更する場合を例にご説明いたします。</p><h3 id="1-新しいローカル管理者アカウント-例-tempaccount-を作成します。"><a href="#1-新しいローカル管理者アカウント-例-tempaccount-を作成します。" class="headerlink" title="1. 新しいローカル管理者アカウント (例 tempaccount) を作成します。"></a>1. 新しいローカル管理者アカウント (例 tempaccount) を作成します。</h3><p>1-1. Windows で、[コントロール パネル] を検索し、開きます。</p><p>1-2. [ユーザー アカウント] &gt; [ユーザー アカウント] &gt; [別のアカウントの管理] を選択し、[ユーザー アカウントの追加] から新しいアカウントを作成します。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-07.png"><br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-08.png"><br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-09.png"></p><p>1-3. 新しいローカル アカウントをクリックし、[アカウントの種類の変更] をクリックします。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-10.png"></p><p>1-4. [管理者] を選択し、[アカウントの種類の変更]をクリックします。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-11.png"></p><p>1-5. 新しいローカルアカウントが、[ローカル アカウント Administrator] に表示されることを確認します。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-12.png"></p><p>1-6. VMを再起動します。</p><h3 id="2-Windows-ユーザー-フォルダーの名前を変更します。"><a href="#2-Windows-ユーザー-フォルダーの名前を変更します。" class="headerlink" title="2. Windows ユーザー フォルダーの名前を変更します。"></a>2. Windows ユーザー フォルダーの名前を変更します。</h3><p>2-1. 対象仮想マシンに、新しいローカル アカウント (例 tempaccount) にてログインします。(コマンド プロンプトの whoami から確認可能です。)<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-13.png"></p><p>2-2. エクスプローラーを開き、C:\ユーザー から仮想マシン作成時に指定した管理者のユーザー フォルダーを右クリックし、[名前の変更] をクリックします。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-14.png"></p><p>2-3. フォルダー名を変更したユーザー名(例. C:\Users\azureadminnew) に変更します。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-15.png"></p><h3 id="3-ユーザーの-SID-を確認します。"><a href="#3-ユーザーの-SID-を確認します。" class="headerlink" title="3. ユーザーの SID を確認します。"></a>3. ユーザーの SID を確認します。</h3><p>3-1. コマンド プロンプトを開き、以下のコマンドを実行します。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WMIC useraccount get name,sid</span><br></pre></td></tr></table></figure><p>3-2. 出力結果から、仮想マシン作成時に指定したユーザー名の SID を確認します。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-16.png"></p><h3 id="4-レジストリ-エディターを使用して名前を変更したフォルダーをマップします。"><a href="#4-レジストリ-エディターを使用して名前を変更したフォルダーをマップします。" class="headerlink" title="4. レジストリ エディターを使用して名前を変更したフォルダーをマップします。"></a>4. レジストリ エディターを使用して名前を変更したフォルダーをマップします。</h3><p>4-1. キーボードの Windows キーと R キーを同時に押し、[ファイル名を指定して実行] を開きます。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-17.png"></p><p>4-2. 「regedit」 を入力し、[OK] を押下します。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-18.png"></p><p>4-3. [レジストリ エディター] にて、下記のパスに移動します。</p><blockquote><p>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList</p></blockquote><p><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-19.png"></p><p>4-4. [ProfileList] 配下から、手順 3 で確認した SID を選択します。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-20.png"></p><p>4-5. [ProfileImagePath] をダブル クリックします。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-21.png"></p><p>4-6. [値のデータ] へ [C:\Users&lt;変更したユーザー名&gt;] (例 C:\Users\azureadminnew) を入力し、[OK] をクリックします。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-22.png"><br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-23.png"></p><p>4-7. 当該仮想マシンを再起動します。</p><h3 id="5-新しいローカル管理者アカウントを無効にします。"><a href="#5-新しいローカル管理者アカウントを無効にします。" class="headerlink" title="5. 新しいローカル管理者アカウントを無効にします。"></a>5. 新しいローカル管理者アカウントを無効にします。</h3><p>5-1. 対象仮想マシンに、変更後の管理者アカウント(例 azureadminnew) にてログインします。</p><p>5-2. 管理者権限にてコマンドプロンプトを開きます。<br><img src="/blog/vm/vm-administrator-username-change/vm-administrator-username-change-24.png"></p><p>5-3. 以下のコマンドを入力すると、新しいローカル管理者アカウント (例 tempaccount) が無効になります。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> user &lt;新しいローカル管理者アカウント名&gt; /active:no</span><br></pre></td></tr></table></figure><p>※ 本手順では無効の方法を案内しておりますが、今後ご利用されない場合は削除していただいても問題ございません。</p><h2 id="管理者アカウント名の注意事項"><a href="#管理者アカウント名の注意事項" class="headerlink" title="管理者アカウント名の注意事項"></a>管理者アカウント名の注意事項</h2><p>ユーザー名をご指定いただく際の注意事項に関しましては、以下のドキュメントにてご案内しております。<br>詳細内容をご確認いただいた上で、変更する名前をご決定いただけますようお願い申し上げます。</p><blockquote><p>ご参考) <a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/faq#vm----------------------">VM を作成する際のユーザー名の要件は何ですか。</a><br>ユーザー名は最大 20 文字の長さまで指定できますが、末尾を句点 (“.”) にすることはできません。<br>次のユーザー名を指定することはできません。</p></blockquote><p>一方で、VM 作成後にゲスト OS 上の操作でユーザー名を変更した場合には、Azure としての制約が適用されないため、上記の要件以外のユーザー名を指定しても OS の動作は可能です。</p><p>ただし、Azure VM 作成時に登録する管理者アカウントは、Azure Portal からそのパスワードをリセットする機能がございますが、ドキュメントに記載のユーザー名の要件に従っていない場合にはその操作が不可になりますため、その点ご留意いただけますようお願いいたします。</p><h2 id="管理者アカウントの追加"><a href="#管理者アカウントの追加" class="headerlink" title="管理者アカウントの追加"></a>管理者アカウントの追加</h2><p>なお、 VM 構築後にゲスト OS 上の操作にて Administrator ユーザーを追加で作成いただくことも Azure としての制約はなく、ご利用いただける方法となります。</p><p>ただし、ゲスト OS 上で “Administrator” ユーザーを作成いただいた場合に関しましても、Azure Portal にて当該ユーザーのパスワードリセットの操作は叶いませんので、その点についてご留意いただけますようお願いいたします。</p><p>本稿が皆様のお役に立てれば幸いです。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの洪です。&lt;br&gt;Azure VM (Windows OS) 作成時には、OS 内で “ビルトイン Administrator” として &lt;strong&gt;管理者アカウント&lt;/strong&gt; のユーザー名をご指定いただくことになりますが、こちらのユーザー名の変更が可能であるかとのお問い合わせをいただくことがございます。&lt;br&gt;本記事ではそのユーザー名を OS 上から変更する方法および関連の留意事項 についてご案内いたします。&lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
  </entry>
  
  <entry>
    <title>Azure Windows VM でクラスター サイズが拡張したいボリューム サイズに対応してない場合について</title>
    <link href="https://jpaztech.github.io/blog/vm/extend-data-disk-related-to-a-cluster-size/"/>
    <id>https://jpaztech.github.io/blog/vm/extend-data-disk-related-to-a-cluster-size/</id>
    <published>2022-12-21T05:00:00.000Z</published>
    <updated>2023-05-26T05:14:04.679Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポート チームの新見です。</p><p>Azure Windows VM において、データ ディスクの拡張方法に関してお問い合わせをいただくことがあります。<br>今回はディスク拡張前の Windows NTFS のクラスター サイズ（アロケーション ユニットサイズ）が、ディスク拡張後のボリューム サイズに対応していない際に、ディスクを拡張する方法をご案内させていただきます。</p><span id="more"></span><h2 id="注意事項"><a href="#注意事項" class="headerlink" title="注意事項"></a>注意事項</h2><p>念のため、作業の実施前には、予期せぬご状況に備えてバックアップやスナップショットの取得をご実施いただければと存じます。<br><a href="https://learn.microsoft.com/ja-jp/azure/backup/backup-azure-vms-introduction">公開情報：Azure VM バックアップについて - Azure Backup | Microsoft Docs</a><br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/snapshot-copy-managed-disk?tabs=portal">公開情報：仮想ハード ディスクの Azure スナップショットを作成する - Azure Virtual Machines | Microsoft Docs</a></p><p>また、記憶域スペースをご利用をいただいている場合においては、以下の手順をご参照ください。<br><a href="https://jpaztech.github.io/blog/vm/extend-storage-space-on-azure-windows-vm/">公開情報：Azure Windows VM で記憶域スペースを拡張する | Japan Azure IaaS Core Support Blog (jpaztech.github.io)</a></p><h2 id="クラスター-サイズが拡張したいボリューム-サイズに対応している場合"><a href="#クラスター-サイズが拡張したいボリューム-サイズに対応している場合" class="headerlink" title="クラスター サイズが拡張したいボリューム サイズに対応している場合"></a>クラスター サイズが拡張したいボリューム サイズに対応している場合</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>データ ディスクを拡張する際には、クラスター サイズが拡張したいボリューム サイズに対応している場合、Azure Portal 等にてディスクのサイズを拡張いただいた後、ゲスト OS 上の操作にてボリュームを拡張する必要があります。</p><h3 id="手順"><a href="#手順" class="headerlink" title="手順"></a>手順</h3><h4 id="1-仮想マシンを停止し、ディスクのサイズを拡張する"><a href="#1-仮想マシンを停止し、ディスクのサイズを拡張する" class="headerlink" title="1. 仮想マシンを停止し、ディスクのサイズを拡張する"></a>1. 仮想マシンを停止し、ディスクのサイズを拡張する</h4><p><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/expand-os-disk#resize-a-managed-disk-in-the-azure-portal">公開情報：Azure 内の Windows VM に接続されている仮想ハード ディスクを拡張する - Azure Virtual Machines | Microsoft Docs</a><br>参照箇所：Azure portal でマネージド ディスクのサイズを変更する</p><h4 id="2-仮想マシン内からボリュームを拡張する"><a href="#2-仮想マシン内からボリュームを拡張する" class="headerlink" title="2. 仮想マシン内からボリュームを拡張する"></a>2. 仮想マシン内からボリュームを拡張する</h4><p><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/expand-os-disk#using-disk-manager">公開情報：Azure 内の Windows VM に接続されている仮想ハード ディスクを拡張する - Azure Virtual Machines | Microsoft Docs</a><br>参照箇所：ディスク マネージャーの使用</p><p>しかしながら、この手順を実行する際にクラスター サイズが対応していない場合はエラーが発生するため、対処方法を以下の通りお伝えします。</p><h2 id="クラスター-サイズが拡張したいボリューム-サイズに対応していない場合"><a href="#クラスター-サイズが拡張したいボリューム-サイズに対応していない場合" class="headerlink" title="クラスター サイズが拡張したいボリューム サイズに対応していない場合"></a>クラスター サイズが拡張したいボリューム サイズに対応していない場合</h2><h3 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h3><p>そのまま既存のデータ ディスクを拡張することができないため、データ ディスクを新規で作成して仮想マシンに接続し、クラスター サイズが対応しているサイズでボリュームを作成した上で、既存ボリューム上のデータを新規ボリュームにコピーする必要があります。</p><h3 id="解説"><a href="#解説" class="headerlink" title="解説"></a>解説</h3><p>クラスター サイズが拡張したいボリューム サイズに対応している場合の手順で拡張した場合、クラスター サイズは拡張前のデフォルトのサイズのままなので、拡張したいボリュームのサイズに対応していない場合はクラスター サイズを対応させる必要があります。<br>しかし、クラスター サイズを変えてしまうと、ボリュームのフォーマットが実施されデータが消えてしまうため、新規でデータ ディスクを作成することでご対応いただければと存じます。</p><p>P70 で作成したディスクの 16TB のボリュームを、 32TB に拡張したい場合を例として説明します。</p><h4 id="デフォルトのクラスター-サイズと必要なクラスター-サイズ"><a href="#デフォルトのクラスター-サイズと必要なクラスター-サイズ" class="headerlink" title="デフォルトのクラスター サイズと必要なクラスター サイズ"></a>デフォルトのクラスター サイズと必要なクラスター サイズ</h4><p>作成するボリュームのサイズによって、デフォルトのクラスター サイズは以下のように異なります。<br><a href="https://support.microsoft.com/ja-jp/topic/ntfs-fat-%E3%81%8A%E3%82%88%E3%81%B3-exfat-%E3%81%AE%E3%83%87%E3%83%95%E3%82%A9%E3%83%AB%E3%83%88%E3%81%AE%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%BF%E3%83%BC-%E3%82%B5%E3%82%A4%E3%82%BA-9772e6f1-e31a-00d7-e18f-73169155af95">公開情報：NTFS、FAT、および exFAT のデフォルトのクラスター サイズ (microsoft.com)</a></p><table><thead><tr><th align="left">ボリュームのサイズ</th><th align="left">Windows 7、Windows Server 2008 R2、Windows Server 2008、Windows Vista、Windows Server 2003、Windows XP、Windows 2000</th></tr></thead><tbody><tr><td align="left">2TB – 16TB</td><td align="left">4KB</td></tr><tr><td align="left">16TB – 32TB</td><td align="left">8KB</td></tr></tbody></table><p>P70(16TB) でディスクを作成し、16TB でボリュームを作成した場合、デフォルトのクラスター サイズは 4KB になります。<br>クラスター サイズ が 4KB の場合、ボリュームは 16TB までしか対応していません。<br>32TB のボリュームを作成するには、8KB のクラスター サイズが必要になります。</p><p><a href="https://learn.microsoft.com/ja-jp/windows-server/storage/file-server/ntfs-overview#support-for-large-volumes">公開情報：NTFS の概要 | Microsoft Docs</a></p><table><thead><tr><th align="left">クラスター サイズ</th><th align="left">最大ボリュームおよびファイル</th></tr></thead><tbody><tr><td align="left">4KB (既定のサイズ)</td><td align="left">16TB</td></tr><tr><td align="left">8KB</td><td align="left">32TB</td></tr></tbody></table><p>クラスター サイズが拡張したいボリューム サイズに対応している場合の手順で、P70(16TB) のディスクを P80(32TB) に拡張した場合、16TB で作成済のボリュームのクラスター サイズはデフォルトと変わらず 4KB のままです。<br>そのため、この作成済の 16TB ボリュームを 32TB にしたい場合、 8KB のクラスター サイズが必要となるので、クラスター サイズが 4KBのままでは 32TB に拡張することができず、実際実行した場合以下のようにエラーメッセージが表示されます。</p><p><img src="/blog/vm/extend-data-disk-related-to-a-cluster-size/extend-data-disk-related-to-a-cluster-size-01.png">    </p><h4 id="クラスター-サイズの変更はフォーマットが伴う"><a href="#クラスター-サイズの変更はフォーマットが伴う" class="headerlink" title="クラスター サイズの変更はフォーマットが伴う"></a>クラスター サイズの変更はフォーマットが伴う</h4><p>上記の通り、32TB のボリュームを利用するためには、クラスター サイズを 8KB 以上に変更する必要がありますが、クラスター サイズを変更してしまうと、ボリュームのフォーマットが実施されることとなってしまいます。<br>（ P70(16TB) のディスク上でクラスター サイズを 8KB に変更してしまうと、データが消えてしまいます。）</p><h4 id="ディスク内の既存のデータに影響を与えない方法"><a href="#ディスク内の既存のデータに影響を与えない方法" class="headerlink" title="ディスク内の既存のデータに影響を与えない方法"></a>ディスク内の既存のデータに影響を与えない方法</h4><p>P80 のデータ ディスクを新規作成して仮想マシンに接続し、16TB 以上のサイズでボリュームを作成した上で、既存ボリューム上のデータを新規ボリュームにコピーします。<br>16TB ~ 32TB のサイズでボリュームを新規で作成した場合は、デフォルトのクラスター サイズが 8KB となるため、そのままご利用いただくことができます。</p><h3 id="手順-1"><a href="#手順-1" class="headerlink" title="手順"></a>手順</h3><h4 id="1-対応しているサイズのデータ-ディスクを新規作成して、仮想マシンにアタッチする"><a href="#1-対応しているサイズのデータ-ディスクを新規作成して、仮想マシンにアタッチする" class="headerlink" title="1. 対応しているサイズのデータ ディスクを新規作成して、仮想マシンにアタッチする"></a>1. 対応しているサイズのデータ ディスクを新規作成して、仮想マシンにアタッチする</h4><p><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/attach-managed-disk-portal">公開情報：マネージド データ ディスクを Windows VM に接続する - Azure - Azure Virtual Machines | Microsoft Docs</a></p><p>Azure portal にて、対象の VM を選択します。<br>左のメニューから [ディスク] を選択し、[新しいディスクを作成し接続する] を選択します。<br>[保存] を選択したら、新しいデータ ディスクの作成と VM への接続の完了です。</p><p><img src="/blog/vm/extend-data-disk-related-to-a-cluster-size/extend-data-disk-related-to-a-cluster-size-02.png"></p><h4 id="2-新規ボリュームを作成する"><a href="#2-新規ボリュームを作成する" class="headerlink" title="2. 新規ボリュームを作成する"></a>2. 新規ボリュームを作成する</h4><p><a href="https://support.microsoft.com/ja-jp/windows/%E3%83%8F%E3%83%BC%E3%83%89-%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF-%E3%83%91%E3%83%BC%E3%83%86%E3%82%A3%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E4%BD%9C%E6%88%90%E3%81%97%E3%81%A6%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%83%E3%83%88%E3%81%99%E3%82%8B-bbb8e185-1bda-ecd1-3465-c9728f7d7d2e">公開情報：ハード ディスク パーティションを作成してフォーマットする (microsoft.com)</a></p><p>まず、対象の VM に接続します。<br>まず、[スタート]  ボタンを右クリックし、 [コンピューターの管理] を開きます。<br>新規でアタッチしたディスクの上で右クリックし、[新しいボリューム]を選択し、希望のサイズで新規ボリュームを作成します。</p><p><img src="/blog/vm/extend-data-disk-related-to-a-cluster-size/extend-data-disk-related-to-a-cluster-size-03.png"></p><p>しばらくすると、フォーマットが完了し、ボリュームが新規作成されます。</p><p><img src="/blog/vm/extend-data-disk-related-to-a-cluster-size/extend-data-disk-related-to-a-cluster-size-04.png"></p><p>エクスプローラーでもボリュームが作成できたことを確認できます。</p><p><img src="/blog/vm/extend-data-disk-related-to-a-cluster-size/extend-data-disk-related-to-a-cluster-size-05.png"></p><h4 id="3-既存ボリューム上のデータを新規ボリュームにコピーする"><a href="#3-既存ボリューム上のデータを新規ボリュームにコピーする" class="headerlink" title="3. 既存ボリューム上のデータを新規ボリュームにコピーする"></a>3. 既存ボリューム上のデータを新規ボリュームにコピーする</h4><p><a href="https://learn.microsoft.com/ja-jp/windows-server/administration/windows-commands/robocopy">公開情報：robocopy | Microsoft Docs</a></p><p>新規ボリュームに既存のボリュームのデータをコピーします。</p><p>例）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">robocopy F:\ G:\ /copyall</span><br></pre></td></tr></table></figure><h4 id="4-既存ディスクをデタッチする"><a href="#4-既存ディスクをデタッチする" class="headerlink" title="4. 既存ディスクをデタッチする"></a>4. 既存ディスクをデタッチする</h4><p><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/detach-disk#detach-a-data-disk-using-the-portal">公開情報：Windows VM からデータ ディスクを切断する - Azure - Azure Virtual Machines | Microsoft Docs</a></p><p>Azure portal にて、対象の仮想マシンを選択します。<br>左のメニューから [ディスク] を選択し、既存のデータ ディスクの右端にある [X] ボタンを選択します。<br>[保存] を選択したら、既存のデータ ディスクが VM から接続解除されます。<br>※デタッチしたディスクはストレージに残ります。 ディスクが削除されるわけではありません。</p><p><img src="/blog/vm/extend-data-disk-related-to-a-cluster-size/extend-data-disk-related-to-a-cluster-size-06.png"></p><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>Azure Windows VM において、データ ディスク拡張前の Windows NTFS のクラスター サイズが、ディスク拡張後のボリューム サイズに対応していない際は、ディスクを拡張する方法にご留意ください。<br>本記事が、皆様の運用に役立つことを願っています。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポート チームの新見です。&lt;/p&gt;
&lt;p&gt;Azure Windows VM において、データ ディスクの拡張方法に関してお問い合わせをいただくことがあります。&lt;br&gt;今回はディスク拡張前の Windows NTFS のクラスター サイズ（アロケーション ユニットサイズ）が、ディスク拡張後のボリューム サイズに対応していない際に、ディスクを拡張する方法をご案内させていただきます。&lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Data Disk" scheme="https://jpaztech.github.io/blog/tags/Data-Disk/"/>
    
  </entry>
  
  <entry>
    <title>AKSのメモリ関連トラブルシューティング</title>
    <link href="https://jpaztech.github.io/blog/containers/aks-memory-troubleshoot/"/>
    <id>https://jpaztech.github.io/blog/containers/aks-memory-troubleshoot/</id>
    <published>2022-12-21T03:00:00.000Z</published>
    <updated>2023-05-26T05:14:04.527Z</updated>
    
    <content type="html"><![CDATA[<p>この記事は<a href="https://qiita.com/advent-calendar/2022/microsoft-azure-tech">Microsoft Azure Tech Advent Calendar 2022</a>の21日目の記事です。</p><p>Azureテクニカルサポートチームの高田です。</p><p>Azure Kubernetes Service(AKS)の運用に際して、メモリ関連の要因によりワークロードが期待通りに実行されない…という方向けに、下記の典型的な事例と対処方法を紹介させて頂きます。</p><ul><li>事例1: Podが配置・実行されない</li><li>事例2: 実行中のPodが終了され、Failed状態となる(または削除・再作成される)</li><li>事例3: 実行中のPodにてOOMKillが発生する</li></ul><span id="more"></span><h2 id="事例1-Podが配置・実行されない"><a href="#事例1-Podが配置・実行されない" class="headerlink" title="事例1: Podが配置・実行されない"></a>事例1: Podが配置・実行されない</h2><p>これは、新たに作成されたPodのメモリ要求(requests)を満たすノードが存在せず、Podがどのノードにも配置(スケジューリング)されない = 実行が開始されない、というものとなります。</p><p><a href="https://kubernetes.io/ja/docs/concepts/configuration/manage-resources-containers/#my-pods-are-pending-with-event-message-failedscheduling">Kubernetes の公式ドキュメント</a>でも同様の事例が紹介されておりますが、簡単に解説します。</p><p>PodがRunning状態とならず、<code>kubectl describe pod</code>コマンドにてStatusがPendingとなっており、Eventsが下記のような表示となっていた場合に、このケースに該当します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod &lt;pod名&gt;</span></span><br><span class="line">(略)</span><br><span class="line">Status:       Pending</span><br><span class="line">(略)</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason            Age   From               Message</span><br><span class="line">  ----     ------            ----  ----               -------</span><br><span class="line">  Warning  FailedScheduling  7s    default-scheduler  0/3 nodes are available: 3 Insufficient memory.</span><br></pre></td></tr></table></figure><p>メモリ要求を満たすノードが存在しない、ということは、言い換えると、このPodをどのノードに配置しても、そのノード上のPodのメモリ要求の合計がそのノードの割当可能な(allocatable)メモリ量を超えてしまう、という意味となります。</p><p>実際には、メモリ「のみ」に関しては条件を満たすノードがあるものの、その他の条件(例:Pod のマニフェストにて指定されている配置条件、CPU等他リソースの状況、ノードのTaint等)により、それらを同時に満たすノードが存在しない、というケースもあります。</p><p>Podのメモリ要求値、各ノードのメモリ割り当て状況は、各々<code>kubectl describe pods</code> <code>kubectl describe nodes</code>コマンドで確認できます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod &lt;pod名&gt;</span></span><br><span class="line">(略)</span><br><span class="line">Containers:</span><br><span class="line">  podcontainer:</span><br><span class="line">    Image:      podimage</span><br><span class="line">    Port:       &lt;none&gt;</span><br><span class="line">    Host Port:  &lt;none&gt;</span><br><span class="line">    Requests:</span><br><span class="line">      memory:     2Gi                    &lt;- 2GiBのメモリを要求</span><br><span class="line">    Environment:  &lt;none&gt;</span><br></pre></td></tr></table></figure><p>この例では、Pod内のコンテナーに設定されているメモリ要求値が2Giになっています。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe node &lt;node名&gt;</span></span><br><span class="line">(略)</span><br><span class="line">Capacity:</span><br><span class="line">  cpu:                2</span><br><span class="line">  ephemeral-storage:  129886128Ki</span><br><span class="line">  hugepages-1Gi:      0</span><br><span class="line">  hugepages-2Mi:      0</span><br><span class="line">  memory:             4025844Ki          &lt;-ノードの全メモリは4,025,844KiB</span><br><span class="line">  pods:               30</span><br><span class="line">Allocatable:</span><br><span class="line">  cpu:                1900m</span><br><span class="line">  ephemeral-storage:  119703055367</span><br><span class="line">  hugepages-1Gi:      0</span><br><span class="line">  hugepages-2Mi:      0</span><br><span class="line">  memory:             2209268Ki          &lt;-Podに割当可能なメモリは2,209,268KiB</span><br><span class="line">  pods:               30</span><br><span class="line">(略)</span><br><span class="line">Allocated resources:</span><br><span class="line">  (Total limits may be over 100 percent, i.e., overcommitted.)</span><br><span class="line">  Resource           Requests     Limits</span><br><span class="line">  --------           --------     ------</span><br><span class="line">  cpu                430m (22%)   4500m (236%)</span><br><span class="line">  memory             310Mi (14%)  3286Mi (152%)    &lt;- 310MiB (Allocatable の14%) が割当済み</span><br><span class="line">  ephemeral-storage  0 (0%)       0 (0%)</span><br><span class="line">  hugepages-1Gi      0 (0%)       0 (0%)</span><br><span class="line">  hugepages-2Mi      0 (0%)       0 (0%)</span><br><span class="line">Events:              &lt;none&gt;</span><br></pre></td></tr></table></figure><p>ノードに残されている割当可能なメモリ2209268Ki - 310Mi よりもPodの要求値 (2Gi) が大きいため、このノードには配置できない、ということがわかります。</p><p>ここでご注意頂きたい点として、配置時に関しては、ノード上で実際に使用されているメモリ量、Pod/コンテナーが実際に使用しているメモリ量は直接関係なく、あくまでもPod/コンテナーが(マニフェスト内の指定にて)<strong>要求する</strong>メモリ量、ノード上のそれらの<strong>要求</strong>の合計により判定される、というものがあります。<br>ノード上の既存のPod/コンテナーが実際にはほとんどメモリを使用していない場合でも、それらの<strong>要求</strong>値が高い場合には、配置時の観点ではそのノードは「メモリに余裕がない」扱いとなります。<br>この問題のトラブルシューティングの際には、(後述するワーキングセットメモリの監視など)実際のメモリ使用量ではなく、<strong>要求</strong>量を確認しましょう。</p><h3 id="対処方法"><a href="#対処方法" class="headerlink" title="対処方法"></a>対処方法</h3><p>これを解消するには、メモリ割り当てに余裕のあるノードを確保するか、あるいは、Podのメモリ要求を既存のノードで賄える程度まで小さくする必要があります。</p><p>前者に関しては、不要なPodの削除による割り当ての開放、または、<a href="https://learn.microsoft.com/ja-jp/azure/aks/use-multiple-node-pools#scale-a-node-pool-manually">ノードプールのスケーリング</a>、<a href="https://learn.microsoft.com/ja-jp/azure/aks/use-multiple-node-pools#add-a-node-pool">ノードプールの追加</a>、<a href="https://learn.microsoft.com/ja-jp/azure/aks/resize-node-pool">ノードのVMサイズの変更</a>、等によるノードの増強、といった方法があります。</p><p>後者に関しては、Pod のメモリ要求の値、すなわち、Podのマニフェストの<code>spec.containers[].resources.requests.memory</code>の値を減らすこととなります。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="string">(略)</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">podimage</span></span><br><span class="line"><span class="string">(略)</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">2Gi</span> <span class="comment"># &lt;- これを減らす</span></span><br></pre></td></tr></table></figure><p>ただし、Podが実際に使用するメモリ量を考慮せずにこの値を減らした場合、後述するOOMKillやEvictが発生するリスクが生じますのでご注意下さい。</p><h3 id="補足-詰め込みの是非"><a href="#補足-詰め込みの是非" class="headerlink" title="補足:詰め込みの是非"></a>補足:詰め込みの是非</h3><p>Podのメモリ要求に対して必要最小限のノードにてAKSクラスターを運用したい、という方も多いかと思います。<br>しかしながら、平常時にて未割当のメモリが少ない場合、Deployment の更新によるローリングアップデートの際等に、メモリが割当不能になるリスクがあります。</p><p>AKSでは、ユーザのPodの他に、CoreDNS等のシステムPodが配置され、動作しています。<br>これらは随時アップデートが行われることがあります。<br>また、AKSに関するアドオンの有効化等により、システムPodが追加で配置されることもあります。<br>このとき、既に各ノードのメモリのほぼ全てが割り当てられていた場合、システムPodの配置失敗や、システムPodの配置のために既存Podが<a href="https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/#preemption">Preemption</a>の対象となることがあり得ます。<br>このような事態を避けるため、少なくとも<a href="https://learn.microsoft.com/ja-jp/azure/aks/use-system-pools?tabs=azure-cli">システムノードプール</a>内のノードに関してはある程度の余裕を確保することをご検討下さい。</p><p>ちなみに、配置の際にはCPUとメモリの扱いに本質的な違いはないので、上記の考え方はCPUに関してもそのまま適用可能です。</p><h2 id="事例2-実行中のPodが終了され、Failed状態となる-または削除・再作成される"><a href="#事例2-実行中のPodが終了され、Failed状態となる-または削除・再作成される" class="headerlink" title="事例2: 実行中のPodが終了され、Failed状態となる(または削除・再作成される)"></a>事例2: 実行中のPodが終了され、Failed状態となる(または削除・再作成される)</h2><p>これは、実行中のPodがノードのメモリ不足によりEvict(退去)の対象となった場合に発生します。<br><code>kubectl describe pod</code>コマンドの結果にて下記のような記録があった場合にこのケースに該当します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod &lt;pod名&gt;</span></span><br><span class="line">(略)</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason               Age   From     Message</span><br><span class="line">  ----     ------               ----  ----     -------</span><br><span class="line">(略)</span><br><span class="line">  Warning  Evicted              110s  kubelet  The node was low on resource: memory. Container &lt;container名&gt; was using 3256Ki, which exceeds its request of 2048Ki.</span><br><span class="line">  Normal   Killing              110s  kubelet  Stopping container &lt;container名&gt;</span><br></pre></td></tr></table></figure><p>Podのマニフェストに記載するメモリ要求(<code>spec.containers[].requests.memory</code>)はあくまでも「予算」のようなものであり、Podはこの値を超えてメモリを確保・使用できます。<br>このため、要求の合計がノードの割当可能なメモリ量の範囲に収まるようにPodが配置されていても、それらのPod(の一部)が要求値を超えてメモリを確保・使用した場合には、ノードにてメモリ不足が発生します。<br>このとき、要求を超えてメモリを使用しているPodの中から、Podに設定されている優先等を考慮して選択されたものが<a href="https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/">evict</a>(退去)されます。<br>(メモリ使用量が急激に増加した場合など、Evictが発生せずに後述するOOMKillが発生する場合もあります)</p><h3 id="対処方法-1"><a href="#対処方法-1" class="headerlink" title="対処方法"></a>対処方法</h3><p>メモリ不足によるEvictを防ぐには、ノード上でメモリ不足が発生しないようにする必要があります。<br>必ずしもPod・コンテナーが使用するメモリの最大値を要求に記載する必要はありませんが、Pod・コンテナーのメモリ使用量が定常的に要求値を超える場合は、そのようなPodの要求値(Podマニフェスト中の<code>pod.spec.containers[].resources.requests.memory</code>の値)をより大きなものに変更することで、対象のPodがよりメモリ割当に余裕のあるノードに配置されることとなり、ノード上でのメモリ不足が発生しにくくなります。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">(略)</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: podimage</span><br><span class="line">(略)</span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        memory: 1Gi # &lt;- これを増やす</span><br></pre></td></tr></table></figure><p>なお、この変更によりPodの配置が行えなくなる可能性もありますので、必要に応じて「Podが配置・実行されない」のトラブルシューティングも実施しましょう。</p><h3 id="補足-コンテナー分析情報"><a href="#補足-コンテナー分析情報" class="headerlink" title="補足:コンテナー分析情報"></a>補足:コンテナー分析情報</h3><p>実際のノードやPod・コンテナーのメモリ消費量は、<a href="https://learn.microsoft.com/ja-jp/azure/azure-monitor/containers/container-insights-enable-aks?tabs=azure-cli">コンテナー分析情報</a>を有効にすることで監視できます。</p><p>コンテナー分析情報は、AzureポータルのAKSクラスターの画面中、「監視」内「分析情報」のタブから利用できます。<br>コンテナー分析情報ではRSS(プロセスが直接明示的に使用しているメモリ領域の大きさ)とワーキングセット(RSS以外の、ファイルキャッシュ等の間接的なメモリ消費を含んだ値)を確認できますが、Evictや後述するOOMKillはワーキングセットに基づいて行われますため、メモリ不足発生の有無の観点ではワーキングセットを確認するようにしましょう。</p><p><img src="/blog/containers/aks-memory-troubleshoot/aks-memory-troubleshoot01.png" alt="ノードのワーキングセット"><br><img src="/blog/containers/aks-memory-troubleshoot/aks-memory-troubleshoot02.png" alt="Pod/コンテナーのワーキングセット"></p><h2 id="事例3-実行中のPodにてOOMKillが発生する"><a href="#事例3-実行中のPodにてOOMKillが発生する" class="headerlink" title="事例3: 実行中のPodにてOOMKillが発生する"></a>事例3: 実行中のPodにてOOMKillが発生する</h2><p>OOM(Out Of Memory)Kill は、ノードに配置され実行中のPodによるメモリ使用量が「制限値」を超過した(正確には、超過してメモリを使用しようとした)ときに発生します。</p><p><code>kubectl describe pod</code>コマンドにて、 Last State 等のReasonに”OOMKilled”と書かれている場合が該当します。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe pod &lt;pod名&gt;</span><br><span class="line">(略)</span><br><span class="line">Containers:</span><br><span class="line">(略)</span><br><span class="line">    Last State:     Terminated</span><br><span class="line">      Reason:       OOMKilled</span><br><span class="line">      Exit Code:    1</span><br><span class="line">      Started:      Fri, 16 Dec 2022 09:57:41 +0000</span><br><span class="line">      Finished:     Fri, 16 Dec 2022 09:57:44 +0000</span><br><span class="line">    Ready:          False</span><br><span class="line">    Restart Count:  1</span><br></pre></td></tr></table></figure><p>制限値には、Pod/コンテナーレベルのものと、ノードレベルのものがあります。<br>(ノード上でのPod合計のメモリ使用量増加する=ノードがメモリ不足となる場合は前項で解説したEvictも発生し得ますが、メモリ増加ペース等によりEvictが発生せずいきなりOOMKillとなる場合もあります)<br>ノード全体のメモリ使用量等から、どちらの制限値に抵触したか判断可能な場合が多いですが、後述の、OOMKillの詳細情報にて判断することも可能です。</p><h3 id="Pod-コンテナーレベルのOOMKillの原因と対処方法"><a href="#Pod-コンテナーレベルのOOMKillの原因と対処方法" class="headerlink" title="Pod/コンテナーレベルのOOMKillの原因と対処方法"></a>Pod/コンテナーレベルのOOMKillの原因と対処方法</h3><p>Pod/コンテナーレベルのOOMKillは、Podのマニフェスト中、<code>spec.containers[].resources.limits.memory</code>にてメモリ制限値が指定されていた場合に、Pod/コンテナーのメモリ使用量がこれに抵触することで発生します。</p><p>したがって、Pod/コンテナーレベルのOOMKillが発生した場合、その原因はPod/コンテナーのメモリ使用量に問題がある(=Pod/コンテナー内アプリケーションの何らかの異常等により、メモリ使用量が想定を超えて増大している)か、メモリ制限値に問題がある(=Pod/コンテナー内のワークロードの使用するメモリ量を低く見積もり過ぎている)か、のどちらかとなります。</p><p>ワークロードの種類によっては判断が難しい場合もありますが、もしメモリ制限値が厳しすぎた可能性があると考える場合は、limitsの値を増やしましょう。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">(略)</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: podimage</span><br><span class="line">(略)</span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        memory: 500Mi</span><br><span class="line">      limits:</span><br><span class="line">        memory: 1Gi  # &lt;- これを増やす</span><br></pre></td></tr></table></figure><p>なお、Pod/コンテナーのメモリ使用量はワーキングセット(RSS以外のファイルキャッシュ等も<br>含んだ値)に関して評価されます。<br>psコマンド等で確認できるプロセスのメモリ使用量(RSS)の合計よりも大きな値となりますので、コンテナー分析情報等にてワーキングセットの値も確認しましょう。</p><h3 id="ノードレベルのOOMKillの原因と対処方法"><a href="#ノードレベルのOOMKillの原因と対処方法" class="headerlink" title="ノードレベルのOOMKillの原因と対処方法"></a>ノードレベルのOOMKillの原因と対処方法</h3><p>ノードレベルにて、「割当可能なメモリ量」の値 + evictionのための猶予値が制限値として設定されているため、これに抵触した場合に(たとえPod/コンテナーレベルの制限値に抵触しなくても)OOMKillが発生します。</p><p>この場合、原因はメモリ不足によるEvictと同様のため、対処方法も同様に各Podのメモリ要求の見直しと、必要に応じたノードの増強等となります。</p><h3 id="補足-OOMKillの詳細情報"><a href="#補足-OOMKillの詳細情報" class="headerlink" title="補足: OOMKillの詳細情報"></a>補足: OOMKillの詳細情報</h3><p>OOMKillはLinux Kernelのメモリ関連機能である<a href="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v1/memcg_test.html">memcg</a>により駆動されるため、発生時のカーネルメッセージを参照することでさまざまな情報が得られます。<br>例えば、下記メッセージ中のoom_memcgにはOOMKillの原因となった制限値が設定されていたmemcg(memory cgroup、プロセスの集合)が記載されているため、これが下記のように<code>/kubepods</code>となっていた場合はノードレベルのOOMKill、 <code>/kubepods/....</code>と続いていた場合はPod/コンテナーレベルのOOMKillとなります。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dec 16 09:37:31 aks-nodepool1-32235639-vmss000002 kernel: [376723.579928] oom-kill:constraint=CONSTRAINT_MEMCG,nodemask=(null),cpuset=d9a4f01c5cfe15ee88972f51557b3395ea6f8d0f31a93d7ef19c64459085a156,mems_allowed=0,oom_memcg=/kubepods,task_memcg=/kubepods/besteffort/pod325d3265-721f-4032-a97b-b3caa6e51859/d9a4f01c5cfe15ee88972f51557b3395ea6f8d0f31a93d7ef19c64459085a156,task=stress,pid=2268420,uid=0</span><br></pre></td></tr></table></figure><p>この他、メッセージにはOOMKillが発生したときのメモリ使用状況等も含まれており、これがメモリ使用内訳の調査等にも役に立つことがあります。<br>カーネルメッセージは、ノードの<code>/var/log/syslog</code>等に記録されるため、 <a href="https://learn.microsoft.com/ja-jp/azure/aks/node-access">ノードにログイン</a>した後に <code>/host/var/log/syslog</code>等を参照することで確認できます。</p><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>AKSはワークロードの配置や実行、問題発生時の復旧を自動的に行ってくれる一方、与える情報や設定が不十分であったり、実態と乖離した場合には予期しない動作となることもあります。<br>今回ご紹介した事例が、皆様のAKSの運用に役立つことを願っています。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;この記事は&lt;a href=&quot;https://qiita.com/advent-calendar/2022/microsoft-azure-tech&quot;&gt;Microsoft Azure Tech Advent Calendar 2022&lt;/a&gt;の21日目の記事です。&lt;/p&gt;
&lt;p&gt;Azureテクニカルサポートチームの高田です。&lt;/p&gt;
&lt;p&gt;Azure Kubernetes Service(AKS)の運用に際して、メモリ関連の要因によりワークロードが期待通りに実行されない…という方向けに、下記の典型的な事例と対処方法を紹介させて頂きます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事例1: Podが配置・実行されない&lt;/li&gt;
&lt;li&gt;事例2: 実行中のPodが終了され、Failed状態となる(または削除・再作成される)&lt;/li&gt;
&lt;li&gt;事例3: 実行中のPodにてOOMKillが発生する&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Containers" scheme="https://jpaztech.github.io/blog/tags/Containers/"/>
    
    <category term="Azure Kubernetes Service (AKS)" scheme="https://jpaztech.github.io/blog/tags/Azure-Kubernetes-Service-AKS/"/>
    
  </entry>
  
  <entry>
    <title>Microsoft Azure の歴史</title>
    <link href="https://jpaztech.github.io/blog/other/azure_history_and_career_in_support/"/>
    <id>https://jpaztech.github.io/blog/other/azure_history_and_career_in_support/</id>
    <published>2022-12-14T03:00:00.000Z</published>
    <updated>2023-05-26T05:14:04.567Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure サポータビリティチームの平原です。現在、私はグローバルエスカレーションチームに所属しており、世界の各国からのエスカレーションや、サポートプロセス改善、製品改善について仕事していますが、2010 年の Azure リリース当初から一貫してビジネスに関わってきました。</p><p>今回は通常の技術ブログとは毛色が異なる内容となりますが、2022 年 12 月の Advent Calender 用に、 Microsoft Azure の歴史 (主にコンピュートとネットワークのコアサービス観点)、私の仕事やキャリアの話を絡めてお話しできたらな、と思います。私の所属がサポートですので、恐縮ながらその観点での記述が多くなってしまいますが、少しでもクラウドコンピューティングに関わる方々の参考になれば幸いです。また Microsoft もしくは外資系でサポートエンジニアを考えられている方は、どういう仕事をするのかも、参考になるのではと思います。</p><h2 id="黎明期-2008-–-2012"><a href="#黎明期-2008-–-2012" class="headerlink" title="黎明期 (2008 – 2012)"></a>黎明期 (2008 – 2012)</h2><p>現在 Microsoft Azure と呼ばれているもののコアとなるサービスは、2008 年の PDC (Professional Developer Conference) にて初めて公に発表されました。コードネームは Reddog 、私もおぼろげながらの当時の印象は、インターネット上にある Windows OS/Server という印象でした。当時私はデベロッパーサポートにおり、C/C++/C# のコンパイラーやライブラリ、.NET Framework や Visual Studio、開発アドバイスの技術者支援をしておりました。サポートエンジニアというポジションで、主にお客様からの .NET や Visual Studio を使った際の開発時の質問やアドバイスをする仕事でした。今のサポートエンジニアも製品は違えど、基本的にはお客様からの質問を電話・メールでお受けして、対応するというものです。その当時の私が、まさか自分が Azure を担当することになるとは全く思っていませんでした。</p><p>2009 年の暮れごろでしょうか、当時の私のマネージャーから打診があり、新サービスのサポートをしてみないかとのことでした。それが Azure であり、当時言われたこととして覚えているのは、「全く新しいものなので、もしかしたら今のチームには戻れないかもしれない」、という話でした。当時の印象では、「インターネット上の Windows OS/Server」という認識しかなかったものの、内容自体は面白そうでしたので、二つ返事で引き受けました。その後、まさか本当に元の担当に戻らずに、それから 10 年以上も Azure のビジネスに関わる仕事をすることになるとは、その時は、全く考えていませんでした。その後、すぐに米国での出張が手配されトレーニングが開始され、Beta エンジニアとしてまず 1 人から Beta サポートを開始したのでした。</p><p>2010 年秋ごろになり、Azure が Beta から正式リリースされました。当初「Windows Azure」という製品名でリリースされ、主に 4 つのサービスからスタートしました。これらは、Cloud Service (当時の名前では Hosted Service )、SQL Azure、Storage Service、AppFabric (Service Bus、Access Control Service; ACS など)です。すべて、PaaS のサービスであり、当初の利用方法はユーザーに Visual Studio を利用して、.NET ベース テクノロジーで配置パッケージを作成してもらい、それを Azure 上にアップデート・配置して使ってもらう、という形でリリースされました。今から考えると、当時の PaaS サービスは少し時代を先取りしすぎており、またアプリケーションの乗り換え (マイグレーション) のハードルがかなり高かったのだと思います。</p><p>Microsoft では、この期間、上記サービスをベースに様々な面から継続的な機能拡張をしており、トラブルシュート用に RDP 機能を追加したり、OS の初期構成できるようになったり、VM Role (ユーザーが自身でイメージを作成してそれをイメージとして利用) が Beta として利用できるようになったりとしましたが、依然IaaS の要望は根強かったように感じます。</p><blockquote><p>補足：Cloud Service 上に展開できたVM Roleは、IaaS製品とは違い事前に作成したイメージから仮想マシンが作成されますが、仮想マシン内部に恒久的なデータを保存できません (non-persistent)。恒久的なデータは別途ストレージサービス等に保存する必要があります。 </p></blockquote><p>サポートチームの観点で言うと、当時はまだチームの規模も小さいものでした。営業チームやマーケティングチームとも案件関連で頻繁にやり取りしており、パートナー支援・営業支援、他企業とアライアンスなどもあり、それらも含め様々やり取りが多かったです。その当時かかわったお客様・社内の皆さんには大変お世話になりました。また、ご利用いただくお客様はほぼ固定化されており、お客様とも仲良くなったりして対応を進めていましたが、新規のお客様はなかなかに開発コンセプトを受け入れていただくのは難しそうでした。オンプレミスのサービスを移行するとなると、イメージとして一番しやすいのは、IaaS 製品をイメージするようで、「OS を自分で構成したい」、というお客様が多い印象でした。PaaS 環境は基本的に、OS はサービスプロバイダー (Azure の場合は Microsoft) が管理しており、ユーザー側でカスタマイズするというのは当初は NG でした (後ほど機能拡張で構成する方法がリリースされます)。PaaS のようにパッケージと構成ファイルを作ってデプロイする、というのは、かなりのパラダイムシフトが必要なようでした。しばらくして 2012 年ごろには、自ら進んで名乗りを上げてくれた意欲のある同僚や、興味を持ってサポートチームに新しく入社した方、マネージャーとで比較的小さなサイズでサポートチームは運営されていました。</p><p>余談ですが、2010 年は「日本のクラウド元年」と呼ばれています。各所でクラウド関連のイベントや社内マーケティングイベントなどがあり、私も何度か参加したりはしましたが、まだ当時は一部のアーリーアダプターで使われている状況であり、世の中広く使われているとはいいがたい状況でした。当時、「クラウドコンピューティング」に関するトレーニングにも参加してみたのですが、既存のホスティングサーバービジネスを焦点においた話題が多く、あまり概念として社会で固定化されていなかったのではと思います。文字や定義という意味では、Eric Schmidt が 2006 年に言及した Cloud Computing という概念 (*1) や、NIST の Cloud Computing の定義 (*2) などもその当時からもありました。10 年以上経って 4 度にわたるポータルの変遷などを経て、現在、此処其処で利用されている状況を見ると、それがイメージできるようになるのは、ある程度、時間をかけた市場でのデザインの洗練化が必要なものだったのかもしれません。</p><p>*1 <a href="https://www.technologyreview.com/2011/10/31/257406/who-coined-cloud-computing/">MIT Technology Review - Who coined ‘Cloud Computing’</a></p><p>*2 <a href="https://csrc.nist.gov/publications/detail/sp/800-145/final">The NIST Definition of Cloud Computing</a></p><p>また当時日本マイクロソフト株式会社独自のマーケティング施策の一環として「クラウディア」というキャラクターがいましたが、古くから Azure に携わられている方には覚えている方もいらっしゃるかもしれません。社員がコミックマーケットに参加したりなどして、コミュニティ活動では JAZUG (Japan Azure User Group) 活動 (*3) があったりと、日本マイクロソフトとしては、自由な発想で様々な活動しておりました。</p><p>*3 <a href="https://r.jazug.jp/">Japan Azure User Group</a></p><h2 id="転換期-2013-–-2015"><a href="#転換期-2013-–-2015" class="headerlink" title="転換期 (2013 – 2015)"></a>転換期 (2013 – 2015)</h2><p>2013 年から 2015 年までの期間は Azure と Microsoft にとっても、大きなニュースが多いのではないかと思います。</p><p>2013 年にリリースされた IaaS 関連の製品群である仮想マシン (Virtual Machine: Persistent VM Role) や仮想ネットワーク (Codename: Brooklyn) は製品としてかなり大きな転換となる製品でした。これまでの PaaS 製品群では OS 内部にデータを保存しても、再イメージ化などでOSの内部がリフレッシュされデータが削除されてしまうものでしたが、IaaS 仮想マシンでは、指定されたディスク内に恒久データの保存が可能になりました。仮想ネットワークでは、それまではロードバランサーから直接仮想マシンに接続していたものが、(ある程度は制約がありましたが) 多くのユーザーが直接仮想マシンやネットワークを操作・構成できるようになりました。また、仮想ネットワークを構成することにより、関連するコンピュートリソースをネットワーク的に分離することが可能となり、VPN や専用線 (Express Route) 等も使ってより自由度が高く、複雑なネットワーク構成が可能となりました。</p><p>2013 年には、Backup サービスや復旧サービス (Recovery Service) などが提供開始されました。それ以前にはバックアップする場合には、ストレージデータのコピーにて対応していたものが、バックアップの観点で可用性のオプションが増えました。</p><p>2014 年には、日本では新たにデータセンターが開設になりました。お客様によっては、データを日本国内に配置しなければいけないビジネス要件等もあるため、日本にデータをおけないことに懸念を示すお客様にとっては大きな朗報になったと思います。またこの年は、Azure の名称が Windows Azure から Microsoft Azure に変更になりました (*4)。</p><blockquote><p>Today we are announcing that Windows Azure will be renamed to Microsoft Azure, beginning April 3, 2014. This change reflects Microsoft’s strategy and focus on Azure as the public cloud platform for customers as well as for our own services Office 365, Dynamics CRM, Bing, OneDrive, Skype, and Xbox Live. Our commitment to deliver an enterprise-grade cloud platform for the world’s applications is greater than ever.  ..</p></blockquote><p>*4 <a href="https://azure.microsoft.com/en-us/blog/upcoming-name-change-for-windows-azure/">Upcoming Name Change for Windows Azure</a></p><p>ただの名称変更のようにも見えるのですが、これは Azure が Microsoft にとって今後の戦略的位置付けになる決意表明のようなものでもありました。「Windows Azure」は、当初のコンセプトとして Windows テクノロジーとの結びつきが強いものでしたが、2010 年代から Microsoft はオープンソース活動にもかなり力を入れていました。実際、仮想マシンでも Linux OS を利用することが可能でした。Windows だけでなく、他社開発プロバイダーやオープンソース業界含めたプラットフォームとなる決意でありました。</p><p>またいろいろなサービスがより様々なサービスが Azure の名のもとにオンライン展開、再ブランディングされていくことになります。特に新たなサービスとして、Azure Active Directory (AAD) や AI 関連の技術 (Machine Learning) なども、この時期に登場しています。</p><p>2015 年に 4 代目となる現在のポータル (Codename: Ibiza, 2022 現在のポータル) がリリースされ、Azure のリソース管理システムも Azure Resource Manager (ARM) をベースとしたリソース管理システムに移行しました。それ以前は RDFE (Reddog Frontend)、Azure Service Management (ASM) と呼ばれるものでリソース管理されていましたが、Role Base Access Control (RBAC) によるユーザー管理などがなく、非常に限られたユーザー権限でしか操作ができず、またリソース管理機能も内部的な制限が多かったため、この ARM による新しいリソース管理システム、および、AAD のユーザーにより、Azure リソース管理の自由度がかなり上がりました。</p><p>また仮想マシンの可用性の観点で言えば、以前はホスト OS のメンテナンスが定期的に停止を伴うものでありましたが、2013 年ごろからメモリ保護メンテナンス (Memory-Preserving Maintenance) (*5) や、新たに Live Migration (*5) なども導入し始め、現状では一部の大きなメンテナンスを除き、大きな停止のないメンテナンスが主流となっています。可用性面については、外部のお客様の声を真摯に受け止めて製品改善を進めていきました。この点は、サポートチームによるお客様の声のフィードバックと、継続的な製品改善プロセスが大きく貢献したと思います。</p><p>*5 <a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-and-updates#maintenance-that-doesnt-require-a-reboot">Azure での仮想マシンのメンテナンス - 再起動を必要としないメンテナンス</a></p><p>サポート部門では、この当時、私も IaaS 製品が Beta の頃にちょうど米国での出張が重なりサポート体制の刷新や、新たな製品サポートの準備をしていました。当時はまだサポート部門としては小さくはありましたが、各人やる気に満ち溢れていました。私自身はリードとして、課金のシステムからコンピュート系のサービスにわたるまで見ていましたが、ここから急激に拡大していくことになり、サポートのチームの体制もより大きなものに変わっていきます。</p><p>Azure とは直接関係はありませんが、2014 年に Satya Nadera が新しい Microsoft の CEO になりました。対外的にもニュースになりましたが、これに伴って Microsoft のカルチャーが大きく変わる転換点となりました。このあたりの話は、Satya 自身が「Hit Refresh」という本を出して当時の状況についても説明しているので、ここで言及するよりも、そちらを読むことをお勧めします。Microsoft Teams が社内ハッカソンにて構築されたのは有名な話ではありますが、このカルチャーの転換がイノベーションの誘発に少なからず関連しているのではと思います。</p><h2 id="成長期-2016年-–-現在"><a href="#成長期-2016年-–-現在" class="headerlink" title="成長期 (2016年 – 現在)"></a>成長期 (2016年 – 現在)</h2><p>これ以降はさらに Azure が様々製品に拡張されていっており、新たな機能拡張や新製品の提供などを継続しています。コンピュート系の話題で言えば、ユーザー自身で再デプロイ (Redeploy: 2016) が実装されたり、Azure Monitor / Resource Health (2017)、管理ディスク (Managed Disk: 2017)、Azure Kubernetes Services (2018)、VM 用Serial Console (2018)、可用性 ゾーン (Azure Availability Zone: 2018)、専用ホスト (Dedicated Host: 2019) 等々、可用性と拡張性をベースに機能拡張されています (もちろんこれ以外にもたくさんの製品が出ています)。またこれからさらに多くのサービスが Azure 上に展開されてくるのではないかと思います。</p><p>サポート観点からは IaaS、Network、データベース、AI 系、など複数の部門に分かれ、Microsoft 365 のサポートも含めると、現在は多くの人がオンライン製品系のサポートに従事するようになっています。</p><h2 id="補足：テクニカルサポートについて"><a href="#補足：テクニカルサポートについて" class="headerlink" title="補足：テクニカルサポートについて"></a>補足：テクニカルサポートについて</h2><p>また、最後にせっかくの機会なので、テクニカルサポートの宣伝をさせていただこうと思います。</p><p>以上、みていただいた通り、テクニカルサポートエンジニアの仕事は多岐にわたり、もちろん電話・メール・Web を使っての技術支援をしますが、それと同時に製品改善やチーム貢献の機会があり、自分から申し出れば (それがビジネス上有用であれば)、新しい取り組みを自分で始めることも可能です。単純にサポート担当の窓口として人を置いているわけではなく、戦略的な位置付けとしてチームを配置しお客様へお役に立つ情報の提供や、トラブルシュート、製品改善に役立てています。また製品のスペシャリストになれるので (場合によっては社内で一番)、その後キャリアを積むうえでも利点が多く、コンサルティングやテクニカルセールス、営業 (アカウントマネージャー)、ピープルマネージャー、開発部門、海外のサポートチーム、等々、多くの方が当サポートエンジニアの仕事を経験したうえで、社内外で活躍されています。</p><p>一方、最近はなかなか先を見通すことができない時代になってきており、実際、クラウドに対するサポート体制が各社でここまで大きく転換をするというのは、2009 年当時、どなたも想像もできていなかったのではと思います。これはおそらく今後も同じで、キャリアを考える上では、「どれが正解」というのが見えづらくなっており、まだ見ぬ製品やサービス・新たな形態でのビジネスが登場してくることも考えられ、むしろキャリアの方向性をよりレジリエントかつ柔軟に考える必要があるのかなと思います。最近の話題として、AIの発展により一部職業がなくなるのではという話があります。テクニカルサポートに関して言うと、将来的にAIが発展しても、一部サポートオペレーションは自動化をできる可能性はもちろんあります。しかし、我々の取り扱う内容は基本的に「人」をベースとしたものであり、技術的に複雑な未知の問題、表出されて来なかった要望、などについては、継続して人の手を介する必要があり、今後はより専門性と問題把握力、コミュニケーション力が必要になっていくものになるのではと思います。</p><p>ご本人の嗜好や方向性もあるので、一概にすべての方におすすめできる仕事ではありませんが、長年の経験から技術職の1つの可能性として考えていただくのもよいのかなと思います。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure サポータビリティチームの平原です。現在、私はグローバルエスカレーションチームに所属しており、世界の各国からのエスカレーションや、サポートプロセス改善、製品改善について仕事していますが、2010 年の Azure リリース当初から一貫してビジネスに関わ</summary>
      
    
    
    
    
    <category term="Other" scheme="https://jpaztech.github.io/blog/tags/Other/"/>
    
    <category term="Support Explained" scheme="https://jpaztech.github.io/blog/tags/Support-Explained/"/>
    
    <category term="IaaS" scheme="https://jpaztech.github.io/blog/tags/IaaS/"/>
    
    <category term="Microsoft Azure" scheme="https://jpaztech.github.io/blog/tags/Microsoft-Azure/"/>
    
  </entry>
  
  <entry>
    <title>Azure IaaS VM で実施されるメンテナンスについて</title>
    <link href="https://jpaztech.github.io/blog/vm/vm-maintenance/"/>
    <id>https://jpaztech.github.io/blog/vm/vm-maintenance/</id>
    <published>2022-10-16T13:40:00.000Z</published>
    <updated>2023-05-26T05:14:04.895Z</updated>
    
    <content type="html"><![CDATA[<p>Azure テクニカル サポートチームの鳥越です。</p><p>Azure をご利用いただいているお客様の中にはメンテナンスによる影響を経験された方もいらっしゃるかと存じます。<br>クラウド環境として、新機能の導入や更なる安定稼働を進めていく上で、このメンテナンスは必要不可欠なものです。<br>しかしながら、このメンテナンスといった言葉の中には、どのようなメンテナンスなのかがよくわからないといったご不安もあるかと推察します。</p><span id="more"></span><p>このような背景もあり、メンテナンスについて、またその影響について可能な限り補足させていただければと、このブログ記事を執筆しました。少しでも本内容がお客様のAzureに対する安心と信頼につながれば幸いでございます。<br>※ なお、今回は IaaS のメンテナンスを中心に記載しております。</p><hr><h2 id="■-そもそもメンテナンスとは何か"><a href="#■-そもそもメンテナンスとは何か" class="headerlink" title="■ そもそもメンテナンスとは何か ?"></a>■ そもそもメンテナンスとは何か ?</h2><p>例えば、オンプレミス環境で言えば、ハードウェア廃止による機材の入れ替えや冗長化などの構成変更、物理的な電気系統の検査、サーバーやネットワーク機器のセキュリティを含む Firmware アップデートなどが該当するかと考えます。</p><p><em>余談ですが、私が以前、オンプレミス環境のサポートを行っていた際には、このような　Firmware のアップデートは深夜の業務停止時間帯に数時間確保した上で計画的実施されておりました。しかし、この Firmware のアップデートは必ずうまくいくといった保証もなく、失敗した際のリカバリ対応も多く経験しました。</em></p><hr><h2 id="■-Azure-環境ではどのように考えるべきか"><a href="#■-Azure-環境ではどのように考えるべきか" class="headerlink" title="■ Azure 環境ではどのように考えるべきか ?"></a>■ Azure 環境ではどのように考えるべきか ?</h2><p>Azure 環境は、物理ホスト サーバー群とその上で複雑に制御された機能をつかさどる各プロセスが稼働しています。また、これらをつなぐネットワーク機器や物理ホスト サーバー群を管理するための機能といった様々なコンポーネントが存在します。</p><p>Azure では、定期的にこのようなプラットフォームを更新して、仮想マシン (VM) のホスト インフラストラクチャーの信頼性、パフォーマンス、セキュリティの向上に努めています。これらの更新の目的は、ホスティング環境のソフトウェア コンポーネントの新機能追加、修正から、ネットワーク コンポーネントのアップグレード、ハードウェアの使用停止まで、広い範囲に及びます。</p><hr><h2 id="■-どのようなメンテナンスがあるか"><a href="#■-どのようなメンテナンスがあるか" class="headerlink" title="■ どのようなメンテナンスがあるか ?"></a>■ どのようなメンテナンスがあるか ?</h2><p>VM における再起動の有無により、大きく分けて、以下の 2 種類が考えられます。</p><ul><li>再起動を必要とするメンテナンス</li><li>再起動を必要としないメンテナンス</li></ul><hr><h2 id="■-再起動を必要とするメンテナンスとは"><a href="#■-再起動を必要とするメンテナンスとは" class="headerlink" title="■ 再起動を必要とするメンテナンスとは ?"></a>■ 再起動を必要とするメンテナンスとは ?</h2><p>再起動を必要とするメンテナンスは、計画メンテナンスとも呼ばれ、VM の再起動を伴うためにお客様に対して事前に通知が行われます。<br>セルフ サービス フェーズと呼ばれる準備期間内には、お客様の任意のタイミングにてメンテナンスを実施することができるため、メンテナンスに伴う VM 再起動による業務影響の発生を避けることが可能です。詳細については、下記公開情報をご確認ください。</p><blockquote><p>参考文献) 再起動を必要とするメンテナンス<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-and-updates#maintenance-that-requires-a-reboot">https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-and-updates#maintenance-that-requires-a-reboot</a></p></blockquote><blockquote><p>参考文献) 計画メンテナンスの通知の処理<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications">https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications</a></p></blockquote><p>メンテナンスの目的としては、ソフトウェアや Firmware 更新、古いハードウェアの更新 (移行) 作業やネットワーク スイッチにおける機器の交換作業などが考えられます。</p><div class="alert is-info"><p class="alert-title">Note</p><p>ネットワーク スイッチにおける機器ついては、現在、ネットワーク スイッチの冗長性を上げて、仮に 1 つのネットワーク スイッチに問題が生じた場合にも、もう 1 つのネットワーク スイッチで問題なく配下の物理ホスト サーバーおよび VM が稼働を続けることができるよう、日々 Azure プラットフォーム側の改善に努めております。</p></div><hr><h2 id="■-再起動を必要としないメンテナンスとは"><a href="#■-再起動を必要としないメンテナンスとは" class="headerlink" title="■ 再起動を必要としないメンテナンスとは ?"></a>■ 再起動を必要としないメンテナンスとは ?</h2><p>Azure では、物理ホスト サーバー群とその上で複雑に制御された機能をつかさどる各プロセスが稼働しており、これらは新しいバージョンのリリースと共に更新が必要となります。これらの更新作業が、再起動を必要としないメンテナンスに該当します。</p><blockquote><p>参考文献) 再起動を必要としないメンテナンス<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-and-updates#maintenance-that-doesnt-require-a-reboot">https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-and-updates#maintenance-that-doesnt-require-a-reboot</a></p></blockquote><p>ほとんどのプラットフォーム更新は、お客様の VM に影響しません。しかしながら影響を及ぼさない更新が不可能な場合、Azure は、お客様の <strong>VM への影響が最小となる更新メカニズム</strong> を利用して更新を行います。</p><h3 id="■-影響が最小となる更新メカニズムとは"><a href="#■-影響が最小となる更新メカニズムとは" class="headerlink" title="■ 影響が最小となる更新メカニズムとは ?"></a>■ 影響が最小となる更新メカニズムとは ?</h3><p>Windows Azure から Azure に名前が変更された 2014 年頃には、物理ホスト サーバーのモジュールの更新であったとしても、メンテナンスとして物理ホスト サーバーの再起動が必要となる場合があり、メンテナンスに伴いお客様の VM は毎回数分間の停止が必要でした。</p><p>このようなお客様への影響を可能な限り最小限にするため、Azure は投資、開発、改善を行い続けている結果、多くのメンテナンスでほとんどお客様が影響を感じないメンテナンスを実現することが可能となりました。</p><p>再起動を必要としないメンテナンスとしては下記のようなものがございます。</p><blockquote><p>参考文献) 影響がゼロまたは影響の少ないメンテナンス テクノロジの進化の変遷<br><a href="https://azure.microsoft.com/ja-jp/blog/advancing-noimpact-and-lowimpact-maintenance-technologies/">https://azure.microsoft.com/ja-jp/blog/advancing-noimpact-and-lowimpact-maintenance-technologies/</a></p></blockquote><blockquote><p>参考文献) Advancing failure prediction and mitigation—introducing Narya<br><a href="https://azure.microsoft.com/en-us/blog/advancing-failure-prediction-and-mitigation-introducing-narya/">https://azure.microsoft.com/en-us/blog/advancing-failure-prediction-and-mitigation-introducing-narya/</a></p></blockquote><h4 id="プラン-A-ホット-パッチ"><a href="#プラン-A-ホット-パッチ" class="headerlink" title="プラン A: ホット パッチ"></a>プラン A: ホット パッチ</h4><p>ホット パッチは、VM に一切ダウンタイムを生じさせることなく、物理ホスト サーバー上の実行中のプロセスに対して変更を行うことができるものであり、Azure では物理ホスト サーバーの更新プログラムを適用する際にできる限り使用しています。これは、物理ホスト サーバー上の機能を新たに呼び出す際、更新されたバージョンにリダイレクトすることで実現しています。</p><p>Azure では 2017 年からホット パッチを使用しており、それ以降、ホット パッチを使用できる範囲の拡大に取り組んでいます。たとえば 2018 年には、ハイパーバイザーに対してホット パッチが使用可能となりました。将来的には、さらなるカスタマー エクスペリエンスの向上のため、これまで “更新にはサーバーの再起動がつきもの” とされてきた Firmware への対応のため、ハードウェア メーカーと連携して検討を勧めています。</p><div class="alert is-important"><p class="alert-title">重要</p><p>ホットパッチのデモは、以下のビデオにて公開されています。</p><p>仮想化ホスト OS における特定のドライバーの置き換えが、人間には認識できないほどのわずかな時間にて成功しています。</p><p>このようなドライバーの更新は、たった 1 つのモジュールの置き換えであっても一般的な OS ではシステム再起動が</p><p>必須となっていたものですが、Azure OS ではこの一部についてはシステムを一切停止させずに更新していくことが可能となっています。</p><blockquote><p>[YouTube] <a href="https://www.youtube.com/watch?v=t3Vo37V9oU8&t=4216s">Inside Azure Datacenter Architecture with Mark Russinovich : Build 2018</a></p></div></blockquote><iframe width="560" height="315" src="https://www.youtube.com/embed/t3Vo37V9oU8?start=4216" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>大規模なホスト更新プログラムの中には、機能レベルのホット パッチでは適用できない変更が含まれているものもございます。それらの更新プログラムについては、メモリ保持メンテナンスを使用するようにしています。</p><h4 id="プラン-B-メモリ保持メンテナンス"><a href="#プラン-B-メモリ保持メンテナンス" class="headerlink" title="プラン B: メモリ保持メンテナンス"></a>プラン B: メモリ保持メンテナンス</h4><p>メモリ保持メンテナンスでは、RAM 内のメモリを保持して VM を “一時停止 (Freeze)” し、物理ホスト サーバーの更新を実施します。更新完了後には VM を再開し、クロックを自動的に同期する作業を実施します。</p><p>Azure では 2018 年からメモリ保持メンテナンスを使用しており、それ以降、3 つの観点で機能の向上を図ってきました。1 つ目は、物理ホスト サーバーを再起動せずに更新が実施できるホスト コンポーネントを対象とした影響の少ないメモリ保持メンテナンスのバリエーションの開発、2 つ目は、VM で発生する一時停止時間の短縮、3 つ目は、メモリ保持メンテナンスによって更新できる VM の種類の拡充です。</p><div class="alert is-important"><p class="alert-title">重要</p><p>メモリ保持メンテナンスのデモは、以下のビデオにて公開されています。</p><p>3D グラフィックスによるリアルタイムな映像が表示されていますが、1 秒未満のゲスト VM の停止時間にて、ホスト OS 側のドライバーの更新を行うことに成功しています。</p><blockquote><p>[YouTube] <a href="https://www.youtube.com/watch?v=t3Vo37V9oU8&t=4149s">Inside Azure Datacenter Architecture with Mark Russinovich : Build 2018</a></p></div></blockquote><iframe width="560" height="315" src="https://www.youtube.com/embed/t3Vo37V9oU8?start=4149" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><div class="alert is-warning"><p class="alert-title">警告</p><p>現状、メモリ保持メンテナンスはさまざまな技術的理由により、M、N、H シリーズなど特定の VM サイズ シリーズに対応できておりません。</p><p>このようなまれなケースでは、より影響の大きな (ホストの再起動や、VM の再展開などを伴う) メンテナンスを行う必要があるため、お客様には事前に通知し、それぞれのワークロードに適したタイミングでメンテナンスを実行できるようにしています。</p></div><h3 id="■-メモリ保持メンテナンスについて"><a href="#■-メモリ保持メンテナンスについて" class="headerlink" title="■ メモリ保持メンテナンスについて"></a>■ メモリ保持メンテナンスについて</h3><p>上記のように、ホットパッチでの対応が難しいものについてはメモリ保持メンテナンスが実施されます　 (逆に言うと、多くのメンテナンスがメモリ保持メンテナンスを用いずにホットパッチ機能を利用して更新が行われるように改善が進められました　)。</p><p>ドキュメントにはこのメンテナンスは通常、最長で 30 秒間といった記載がございます。<br>この記載がメンテナンスは 30 秒間で必ず完了するものといった誤解を生むことにつながりました。</p><h3 id="■-メンテナンス時間-30-秒間について"><a href="#■-メンテナンス時間-30-秒間について" class="headerlink" title="■ メンテナンス時間 30 秒間について"></a>■ メンテナンス時間 30 秒間について</h3><p>Azureをご利用いただく上で必要となるこれらのメンテナンスに対して、少しでもお客様に影響を与えないようカスタマー エクスペリエンスの向上を続けております。<br>その結果、メモリ保持メンテナンスであったとしても、ほとんどのメンテナンスで、99 パーセンタイル (P99) において Azure 基盤側の更新処理が 30 秒以内に完了できるようになりました。</p><div class="alert is-info"><p class="alert-title">Note</p><p>パーセンタイルとは、主に統計で使われる用語であり、最小値から並べてその値がどの位置にいるかを示す単位となります。</p><p>つまり P99 の場合、”99/100 番目の位置は 30 秒以内である” =&gt; “ほぼ 30 秒以内に終わる” ことを示しています。</p></div><p>しかしながら、100　% 完了とはなっておらず、お客様によっては、どうしても 30 秒以上の影響を受けてしまう状況が発生してしまうことは、現在に至っても避けられてはおりません。</p><p>メンテナンス内容によっても影響範囲が大きいもの、小さいものがございます。</p><p>例えば、ホスト サーバー上で動作するモジュールの置き換えであれば、ホットパッチまたは軽微なメモリ保持メンテナンスで解決いたしますが、ホスト サーバーのオペレーティングシステムの (カーネルを含むような) 更新を伴うような大きなメンテナンスの場合には、メモリ保持メンテナンスであったとしても、その影響が色濃く表れることもございます。</p><p>ご利用いただいている VM のオペレーティングシステムにより、古い Linux OS (カーネル) を利用されている場合には、想定以上にメンテナンスに対する影響の時間が長くなることもございます。<br>また、OS だけでなく、ネットワーク インフラストラクチャーにおける更新作業についても、OS やお客様の VM 自体を停止するものではありませんが、TCP/IP の自動的なリトライ ロジックを超えて瞬断が発生する可能性がございます。</p><p><span style="text-decoration:underline;">メンテナンスの影響時間は適用される更新プログラムやその内容により大きく左右されるため、一概にメンテナンス全体で 30 秒間影響を受けるものでは無く、また影響の大きなメンテナンス (メモリ保持メンテナンス) であった場合、多くのお客様で 30 秒以内にメンテナンスが収まっていたとしても、100 % のお客様で 30 秒以内にメンテナンスが完了することをお約束することは叶いません。</span></p><div class="alert is-info"><p class="alert-title">Note</p><p>Azure Virtual Machine の SLA も、これらのメンテナンスの改善と関連し向上しています。</p><p>Azure において、2022 年 10 月現在、過去最後に VM の再起動を伴う大規模なメンテナンスを行ったものは、2018 年 1 月 3 日頃のものとなっております。</p><p>※ 一部リージョンのハードウェアの更改に伴い、VM の再起動を伴うメンテナンスが発生することは局所的に存在します。</p><p>　</p><p>このような背景から、2018 年 3 月には、Azure Virtual Machine の SLA からメンテナンスに関連するダウンタイムの除外を削除しています。</p><p>つまり、たとえ計画されたメンテナンスであったとしても、お客様の VM に分単位のダウンタイムをもたらした場合には、合計 SLA に影響するということとなっています。　</p><blockquote><p>参考文献) Virtual Machines の SLA</p><p><a href="https://azure.microsoft.com/ja-jp/support/legal/sla/virtual-machines/v1_9/">https://azure.microsoft.com/ja-jp/support/legal/sla/virtual-machines/v1_9/</a></p><p>参照箇所: バージョン履歴</p><p>1.7 最終更新: 2018 年 3 月</p><p>リリース ノート:単一インスタンス仮想マシンメンテナンスに関連するダウンタイムの除外を削除</p></div></blockquote><div class="alert is-info"><p class="alert-title">Note</p><p>SLA ダウンタイムは分単位で計算されます。月間での合計 SLA がお客様の VM の稼働時間に対して 99.9 % (単一インスタンス / Premium SSD または Ultra ディスクの場合) を下回る場合に返金となります。　</p><blockquote><p>月間稼働率 (%) = (月内時間 (分) - ダウンタイム) / 月内時間 (分) x 100</p></div></blockquote><hr><h2 id="■-おわりに"><a href="#■-おわりに" class="headerlink" title="■ おわりに"></a>■ おわりに</h2><p>Azure では、引き続きメンテナンスに伴うお客様への影響時間短縮も含めたカスタマー エクスペリエンスの向上に尽力しています。また、将来を見据えて可用性と信頼性を確保するために機械学習ベースの洞察と自動化に多大な投資を行っています。</p><p>現時点では 30 秒程度との記載がございますが、このようなメンテナンスへの私たちの取り組みと、今後もより一層お客様が安心、信頼し Azure をご利用いただけるよう改善を続けていく思いを込めた記載であることをご理解いただけますと幸いでございます。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Azure テクニカル サポートチームの鳥越です。&lt;/p&gt;
&lt;p&gt;Azure をご利用いただいているお客様の中にはメンテナンスによる影響を経験された方もいらっしゃるかと存じます。&lt;br&gt;クラウド環境として、新機能の導入や更なる安定稼働を進めていく上で、このメンテナンスは必要不可欠なものです。&lt;br&gt;しかしながら、このメンテナンスといった言葉の中には、どのようなメンテナンスなのかがよくわからないといったご不安もあるかと推察します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="maintenance" scheme="https://jpaztech.github.io/blog/tags/maintenance/"/>
    
  </entry>
  
</feed>
